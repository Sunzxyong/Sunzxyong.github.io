<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>zhengxiaoyong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhengxiaoyong">
<meta property="og:url" content="http://zhengxiaoyong.me/index.html">
<meta property="og:site_name" content="zhengxiaoyong">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhengxiaoyong">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="zhengxiaoyong" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xswxf.com2.z0.glb.qiniucdn.com/image/icon.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">郑晓勇</a></h1>
		</hgroup>

		
		<p class="header-subtitle">The best always comes last</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/性能优化">性能优化</a></li>
				        
							<li><a href="/categories/技术沉淀">技术沉淀</a></li>
				        
							<li><a href="/categories/Exchange">Exchange</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Sunzxyong" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/p/1005053048730677/home?from=page_100505&mod=TAB#place" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="/1175151739@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Exchange/" style="font-size: 10px;">Exchange</a> <a href="/tags/Fresco原理/" style="font-size: 10px;">Fresco原理</a> <a href="/tags/JsBridge/" style="font-size: 10px;">JsBridge</a> <a href="/tags/Splash页/" style="font-size: 10px;">Splash页</a> <a href="/tags/UrlRouter/" style="font-size: 10px;">UrlRouter</a> <a href="/tags/WebView/" style="font-size: 10px;">WebView</a> <a href="/tags/WebView安全/" style="font-size: 10px;">WebView安全</a> <a href="/tags/兼容性/" style="font-size: 10px;">兼容性</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/内存泄露/" style="font-size: 10px;">内存泄露</a> <a href="/tags/启动速度/" style="font-size: 10px;">启动速度</a> <a href="/tags/异步任务/" style="font-size: 10px;">异步任务</a> <a href="/tags/性能优化点/" style="font-size: 10px;">性能优化点</a> <a href="/tags/消费者/" style="font-size: 10px;">消费者</a> <a href="/tags/生产者/" style="font-size: 10px;">生产者</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/订阅者/" style="font-size: 10px;">订阅者</a> <a href="/tags/路由框架/" style="font-size: 10px;">路由框架</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u010687392">我的CSDN的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">2016届毕业的应届小伙伴，喜欢Android、喜欢探索新技术、喜欢性能优化、喜欢代码的整洁、喜欢...目前就职于微店。微信：zxy1175151739</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">郑晓勇</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xswxf.com2.z0.glb.qiniucdn.com/image/icon.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">郑晓勇</h1>
			</hgroup>
			
			<p class="header-subtitle">The best always comes last</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/性能优化">性能优化</a></li>
		        
					<li><a href="/categories/技术沉淀">技术沉淀</a></li>
		        
					<li><a href="/categories/Exchange">Exchange</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Sunzxyong" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/p/1005053048730677/home?from=page_100505&mod=TAB#place" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="/1175151739@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Exchange" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/25/Exchange/" class="article-date">
  	<time datetime="2016-04-25T07:05:51.000Z" itemprop="datePublished">2016-04-25</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/Exchange/">Exchange</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>图书交换，知识共享，双方互利</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exchange/">Exchange</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Exchange/">Exchange</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-UrlRouter路由框架的设计" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/24/UrlRouter路由框架的设计/" class="article-date">
  	<time datetime="2016-04-24T14:10:36.000Z" itemprop="datePublished">2016-04-24</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/24/UrlRouter路由框架的设计/">UrlRouter路由框架的设计</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UrlRouter的设计"><a href="#UrlRouter的设计" class="headerlink" title="UrlRouter的设计"></a><strong>UrlRouter的设计</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><blockquote>
<p>1、可取代使用startActivity、startActivityForResult跳转的情景，便于协同开发<br>2、通过一串url可任意跳转到指定界面，使用应尽可能简单<br>3、支持各种类型参数传递、界面转场动画<br>4、可获取起跳界面的路径和当前界面路径，以便支持后期埋点等需求<br>5、支持从H5到Native，Native到H5，这是Hybrid开发模式中常用到的需求</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UrlRouter/">UrlRouter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/路由框架/">路由框架</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术沉淀/">技术沉淀</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/04/24/UrlRouter路由框架的设计/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Native与H5交互的那些事" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/20/Native与H5交互的那些事/" class="article-date">
  	<time datetime="2016-04-20T04:55:28.000Z" itemprop="datePublished">2016-04-20</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/Native与H5交互的那些事/">Native与H5交互的那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span><br><span class="line">            alert(obj);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line">                 .getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加<code>@JavascriptInterface</code>注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的<code>prompt</code>方法进行解决，只不过<code>需要和前端协商好一套公共的协议</code>，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JsBridge/">JsBridge</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebView/">WebView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebView安全/">WebView安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/兼容性/">兼容性</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术沉淀/">技术沉淀</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/04/20/Native与H5交互的那些事/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android性能优化之Bitmap的内存优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/23/Android性能优化之Bitmap的内存优化/" class="article-date">
  	<time datetime="2016-02-23T02:53:30.000Z" itemprop="datePublished">2016-02-23</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/23/Android性能优化之Bitmap的内存优化/">Android性能优化之Bitmap的内存优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、BitmapFactory解析Bitmap的原理"><a href="#1、BitmapFactory解析Bitmap的原理" class="headerlink" title="1、BitmapFactory解析Bitmap的原理"></a><strong>1、BitmapFactory解析Bitmap的原理</strong></h2><p>BitmapFactory提供的解析Bitmap的静态工厂方法有以下五种：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bitmap <span class="function"><span class="title">decodeFile</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeResource</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeByteArray</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeStream</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeFileDescriptor</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
<p>其中常用的三个：decodeFile、decodeResource、decodeStream。<br>decodeFile和decodeResource其实最终都是调用decodeStream方法来解析Bitmap，decodeStream的内部则是调用两个native方法解析Bitmap的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">nativeDecodeAsset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">nativeDecodeStream</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这两个native方法只是对应decodeFile和decodeResource、decodeStream来解析的，像decodeByteArray、decodeFileDescriptor也有专门的native方法负责解析Bitmap。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存优化/">内存优化</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/性能优化/">性能优化</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/02/23/Android性能优化之Bitmap的内存优化/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-关于生产者-消费者-订阅者模式的那些事" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/27/关于生产者-消费者-订阅者模式的那些事/" class="article-date">
  	<time datetime="2016-01-27T06:26:30.000Z" itemprop="datePublished">2016-01-27</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/关于生产者-消费者-订阅者模式的那些事/">关于生产者-消费者-订阅者模式的那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者/消费者模式"></a><strong>生产者/消费者模式</strong></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><h3 id="用来干嘛的？"><a href="#用来干嘛的？" class="headerlink" title="用来干嘛的？"></a><strong>用来干嘛的？</strong></h3><p>生产者/消费者模式的产生主要目的就是为了解决非同步的生产与消费之间的问题。</p>
<p><strong>什么是非同步呢？</strong><br>    比如我刚刚生产了某个产品，而此时你正在打游戏，没空来取，要打完游戏来取，这就导致了我生产产品和你取产品是两个非同步的动作，你不知道我什么时候生产完产品，而我也不知道你什么时候来取。</p>
<p>而生产者/消费者模式就是解决这个非同步问题的，因为肯定不可能我生产完一个就给你打个电话叫你来取，然后等你取完我再生产下一个，这是多么低效的一种做法。所以这个模式运用而生，这个模式在生活中也有很好的体现，如：快递员派信这个例子，我就是生产者，快递员就是消费者，而生产者与消费者之间是通过什么来解决这种非同步的问题呢？就是一个存储中介，作为快递员派信这个例子中，信箱就是这个存储中介，每次我只要把写完的信扔入信箱，而快递员隔三差五的就会来取一次信，这两个动作是完全异步的，我把信扔入信箱后就不需要管什么了，之后肯定有快递员来取。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消费者/">消费者</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生产者/">生产者</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/订阅者/">订阅者</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术沉淀/">技术沉淀</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/01/27/关于生产者-消费者-订阅者模式的那些事/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android性能优化之Splash页应该这样设计" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/17/Android性能优化之Splash页应该这样设计/" class="article-date">
  	<time datetime="2016-01-16T16:18:30.000Z" itemprop="datePublished">2016-01-17</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/Android性能优化之Splash页应该这样设计/">Android性能优化之Splash页应该这样设计</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目前SplashActivity的设计"><a href="#目前SplashActivity的设计" class="headerlink" title="目前SplashActivity的设计"></a><strong>目前SplashActivity的设计</strong></h2><p>目前市场上的应用在启动时基本上都会先启动一个SplashActivity，作为一个欢迎界面，为什么这样设计呢？<br>个人总结有三个优点：</p>
<h3 id="1、可以给用户更好的体验"><a href="#1、可以给用户更好的体验" class="headerlink" title="1、可以给用户更好的体验"></a>1、可以给用户更好的体验</h3><p>比如：可以由后台动态的改变欢迎的图片，或者显欢迎xxx回来，新浪微博的就是这种交互。</p>
<h3 id="2、可以缩减App的启动时间"><a href="#2、可以缩减App的启动时间" class="headerlink" title="2、可以缩减App的启动时间"></a>2、可以缩减App的启动时间</h3><p>由上一篇博文中知道app启动的耗时主要是在Application初始化中和MainActivity的界面绘制前，由于MainActivity的业务和布局复杂度肯定比只显示一张图片的界面高，所以，加入一个显示一张图片的Splash页可以优化应用的启动。</p>
<h3 id="3、可以在应用启动时做更多的事"><a href="#3、可以在应用启动时做更多的事" class="headerlink" title="3、可以在应用启动时做更多的事"></a>3、可以在应用启动时做更多的事</h3><p>一般来说SplashActivity一般会设计成停留2到4s不等，或者根据数据的加载程度来动态的设置Splash界面的停留时间，既然停留那么久，那么当然可以在这个界面背后做一些事以备MainActivity的快速显示，比如：数据的预加载、sp的初始化、网络请求等。</p>
<p>当然你可能有些疑问，那这样初始化放在Application中也可以啊？也用异步操作数据也是一样啊？</p>
<p>答案是不一样！正如上篇所说的，Application初始化时并不会加载界面，而是在它创建完和初始化完成后，开始创建Activity时才开始绘制Theme中的background和绘制布局，所以用一个轻量的Splash页给它设置一张背景欢迎图，这样就立马能显示界面了，而在这个界面中还可以做其它的初始化操作，这样在视觉上即达到了app的快速启动，又添加了体验和做数据的初始化。</p>
<p>相反如果过多的放在Application中，则在点击app图标启动时会感觉延迟，必须要把Application中的东西都做完才进入Activity的配置和绘制中。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Splash页/">Splash页</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/性能优化/">性能优化</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/01/17/Android性能优化之Splash页应该这样设计/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android性能优化之加快应用启动速度" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/14/Android性能优化之加快应用启动速度/" class="article-date">
  	<time datetime="2016-01-14T14:51:30.000Z" itemprop="datePublished">2016-01-14</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/14/Android性能优化之加快应用启动速度/">Android性能优化之加快应用启动速度</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="应用的启动"><a href="#应用的启动" class="headerlink" title="应用的启动"></a><strong>应用的启动</strong></h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a><strong>启动方式</strong></h3><p>通常来说，在安卓中应用的启动方式分为两种：冷启动和热启动</p>
<blockquote>
<p>1、冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。</p>
<p>2、热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/启动速度/">启动速度</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/性能优化/">性能优化</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/01/14/Android性能优化之加快应用启动速度/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Fresco图片框架内部实现原理探索" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/04/Fresco图片框架内部实现原理探索/" class="article-date">
  	<time datetime="2016-01-04T03:38:30.000Z" itemprop="datePublished">2016-01-04</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/04/Fresco图片框架内部实现原理探索/">Fresco图片框架内部实现原理探索</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="流行的网络框架"><a href="#流行的网络框架" class="headerlink" title="流行的网络框架"></a><strong>流行的网络框架</strong></h2><p>目前流行的网络图片框架：<br>Picasso、Universal Image Loader、Volley的(ImageLoader、NetworkImageView)、Glide和Fresco</p>
<p>简明的介绍下（具体细节和功能可看源码和wiki）：<br>其中Picasso和Universal Image Loader相比其它的算是最轻量级的图片框架了，它们拥有较少的方法数，Universal Image Loader是这五个框架中定制性最强的，它内部实现还是按网络框架的套路走：HttpUrlConnection+线程池+Handler，支持渐显效果。<br>而Picasso只有一些图片加载框架应有的基本功能，所以因此它是最轻量的，在需求只要基本的图片加载与双缓存功能下，可以选Picasso作为项目的基础库，Picasso它内部默认是使用OkHttpClient作为加载网络图片的下载器，毕竟不用自家用谁的，在OkHttpClient没有的情况下则使用HttpUrlConnection，同上面一样，下载器+线程池+Handler，不过它内部的线程池比较有意思，线程池的线程数量是根据当前的网络环境来动态改变的，wifi网络下为4，4G为3，3G为2，2G为1，其它情况下默认为3，支持渐显效果。<br>Volley的没什么可说的，基本功能都有，网络框架的附赠功能。</p>
<p>Glide的话，Google官方推荐，支持Gif、图片缩略图、本地视频解码、请求和动画生命周期的自动管理、渐显动画、支持OkHttp和Volley等等，默认是使用HttpUrlConnection加载图片的，源码灰常多，200多个类，不想看</p>
<p>Fresco我认为是这几个框架中性能最佳的一个框架，着重介绍，它内部用了大量的建造者模式、单例模式、静态工厂模式、生产/消费者模式。内部实现比较复杂，就拿图片加载来说，是通过在异步线程中回调图片的输入流，然后通过一系列读取、写入、转化成EncodedImage，然后再Decode成Bitmap，通过Handler转给UI线程显示，通过IO操作存储在硬盘缓存目录下。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fresco原理/">Fresco原理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术沉淀/">技术沉淀</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2016/01/04/Fresco图片框架内部实现原理探索/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android性能优化之被忽视的优化点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/25/Android性能优化之被忽视的优化点/" class="article-date">
  	<time datetime="2015-11-25T07:42:30.000Z" itemprop="datePublished">2015-11-25</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/25/Android性能优化之被忽视的优化点/">Android性能优化之被忽视的优化点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于性能优化这个知识点来说，实在是太广了，博主本人也一直非常关注这方面的学习，而对于性能优化来说它包括了非常非常非常多方面，比如：I/O的优化、网络操作的优化、内存的优化、数据结构的优化、代码层次的优化、UI渲染优化、CPU资源使用率的优化、异常处理的优化等等等等。。。</p>
<p>本篇文章就博主本人的理解来讲述一些在Android开发中可以优化的地方</p>
<h2 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a><strong>ArrayList和Vector</strong></h2><p>ArrayList和Vector都是内部以数组实现的List，它们两唯一的区别就是对多线程的支持，ArrayList是线程不安全的，而Vector内部对大多数方法都做了同步，是线程安全的，既然是线程安全的，所以性能方面肯定不如ArrayList了（当然想法肯定是对的），不过这需要看哪方面了，ArrayList在add、get、remove等操作效率肯定是高于Vector的，而在内存方面，Vector却比ArrayList表现的更好，这归根都是ArrayList的扩容策略导致的，稍后分析<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化点/">性能优化点</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/性能优化/">性能优化</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/11/25/Android性能优化之被忽视的优化点/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android性能优化之常见的内存泄漏" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/23/Android性能优化之常见的内存泄漏/" class="article-date">
  	<time datetime="2015-11-23T14:37:30.000Z" itemprop="datePublished">2015-11-23</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/23/Android性能优化之常见的内存泄漏/">Android性能优化之常见的内存泄露</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：<br>1、<a href="http://bugly.qq.com/blog/?p=832">内存泄露从入门到精通三部曲之基础知识篇</a><br>2、<a href="http://bugly.qq.com/blog/?p=872">内存泄露从入门到精通三部曲之排查方法篇</a><br>3、<a href="http://bugly.qq.com/blog/?p=884">内存泄露从入门到精通三部曲之常见原因与用户实践</a></p>
<p>关于性能优化的文章，出自Realm.io：<br><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/">10 条提升 Android 性能的建议</a><br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存泄露/">内存泄露</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/性能优化/">性能优化</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/11/23/Android性能优化之常见的内存泄漏/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="outer">
	
    <div id="footer-info">
	<div class="footer-center” style="font-size:14px”>
		<span id="busuanzi_container_site_pv" style="color:red”>
    		您是本站的第<span id="busuanzi_value_site_pv" style="font-size:16px"></span>位访客小伙伴</span>
		<span style="font-size:12px">
    			&nbsp;| &copy; 2016 郑晓勇
    	</span>
	</div>
    </div>
  </div>

</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>