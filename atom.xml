<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengxiaoyong</title>
  <subtitle>生活不止眼前的苟且，还有诗，和远方.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhengxiaoyong.me/"/>
  <updated>2016-11-20T13:09:10.000Z</updated>
  <id>http://zhengxiaoyong.me/</id>
  
  <author>
    <name>郑晓勇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述RTMPDump与编译移植</title>
    <link href="http://zhengxiaoyong.me/2016/11/20/%E7%AE%80%E8%BF%B0RTMPDump%E4%B8%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/"/>
    <id>http://zhengxiaoyong.me/2016/11/20/简述RTMPDump与编译移植/</id>
    <published>2016-11-20T11:47:59.000Z</published>
    <updated>2016-11-20T13:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTMPDump概述"><a href="#RTMPDump概述" class="headerlink" title="RTMPDump概述"></a><strong>RTMPDump概述</strong></h2><p><a href="http://rtmpdump.mplayerhq.hu/" target="_blank" rel="external">RTMPDump主页</a>，RTMPDump库主要包含三部分：</p>
<blockquote>
<p>1、一个基本的客户端程序<br>2、两个服务器程序（rtmpsrv、rtmpsuck）<br>3、一个支持rtmp协议的库—librtmp</p>
</blockquote>
<p>下载RTMPDump最新源码，可以通过git拉取master分支上的最新代码：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://git.ffmpeg.org/rtmpdump</span><br></pre></td></tr></table></figure>
<p>或者下载以前版本的代码—<a href="http://rtmpdump.mplayerhq.hu/download/" target="_blank" rel="external">Download old version</a></p>
<p>下面主要介绍librtmp和librtmp的编译</p>
<h3 id="librtmp概述"><a href="#librtmp概述" class="headerlink" title="librtmp概述"></a><strong>librtmp概述</strong></h3><p>librtmp库提供了大量客户端函数和少部分的服务器端的函数用来支持RTMP、RTMPT（RTMP使用Http通道），RTMPE（加密的RTMP），RTMPS（基于SSL/TLS的RTMP）和RTMPTE、RTMPTS（使用Http通道的加密和基于SSL/TLS的RTMP）协议</p>
<p>使用librtmp库进行的流媒体交互都是使用<strong>FLV</strong>封包格式进行传输的，当然编码不限定，不过为了拉流端同时也支持<strong>HLS</strong>协议，最好使用<strong>H264</strong>编码视频和<strong>AAC</strong>编码音频数据</p>
<a id="more"></a>
<p>使用librtmp通过<strong><code>RTMP[T][E|S]</code></strong>协议进行一次流媒体交互的基本过程为：</p>
<blockquote>
<p><strong>推流端</strong>：</p>
<ol>
<li><strong>RTMP_Alloc()</strong>-创建一个RTMP会话句柄</li>
<li><strong>RTMP_Init()</strong>-初始化RTMP句柄</li>
<li><strong>RTMP_SetupURL()</strong>-设置推流RTMP Url</li>
<li><strong>RTMP_EnableWrite()</strong>-配置该媒体流可进行写操作</li>
<li><strong>RTMP_Connect()</strong>-建立RTMP网络连接</li>
<li><strong>RTMP_ConnectStream()</strong>-建立RTMP流连接</li>
<li><strong>RTMP_Write()</strong>-对该媒体流进行写入流媒体信息</li>
<li><strong>RTMP_Close()</strong>-关闭RTMP连接</li>
<li><strong>RTMP_Free()</strong>-释放此次连接的会话句柄</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p><strong>播放端</strong>：</p>
<ol>
<li><strong>RTMP_Alloc()</strong>-创建一个RTMP会话句柄</li>
<li><strong>RTMP_Init()</strong>-初始化RTMP句柄</li>
<li><strong>RTMP_SetupURL()</strong>-设置拉流RTMP Url</li>
<li><strong>RTMP_Connect()</strong>-建立RTMP网络连接</li>
<li><strong>RTMP_ConnectStream()</strong>-建立RTMP流连接</li>
<li><strong>RTMP_Read()</strong>-读取媒体流数据，返回0时则媒体流读取完毕</li>
<li><strong>RTMP_Pause()</strong>-暂停读取媒体流数据或取消暂停（options）</li>
<li><strong>RTMP_Seek()</strong>-可通过它改变流播放的位置（options）</li>
<li><strong>RTMP_Close()</strong>-当媒体流读取完毕后进行RTMP连接的关闭</li>
<li><strong>RTMP_Free()</strong>-释放此次连接的会话句柄</li>
</ol>
</blockquote>
<p>上述方法的具体实现可以在librtmp包中的<code>rtmp.c</code>文件中找到，同时，它还提供了其它众多方法来处理RTMP的流媒体交互过程</p>
<h3 id="librtmp的RTMP-URL格式"><a href="#librtmp的RTMP-URL格式" class="headerlink" title="librtmp的RTMP URL格式"></a><strong>librtmp的RTMP URL格式</strong></h3><p>一个基本的RTMP URL格式为：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp[<span class="link_label">t</span>][<span class="link_reference">e|s</span>]://host[<span class="link_label">:port</span>][<span class="link_reference">/app[/playpath</span>]]</span><br></pre></td></tr></table></figure>
<p>和http类似，不过某些地方不一样，下面简单说说：<br>scheme为rtmp或者rtmp协议的诸多变种之一，这就不需要多解释了，像websocket协议scheme为ws或者wss，http协议scheme为http或https。<br>host为主机名，后面紧接着为端口号，如果不指定，rtmp协议默认端口号为1935.<br>app代表服务器上的一个Application应用程序，这个名称是由服务器定义的，如：live。<br>playpath则是表示该Application下的一个媒体流的路径，如：room100。</p>
<p>当然也可以追加额外的参数，只不过这和我们使用http协议追加参数的方式不同，librtmp是采取空格为分隔符，通过追加”key=value”的方式进行追加额外的参数，如：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rtmp://localhost:1935/live/room100 app=happylive"</span></span><br></pre></td></tr></table></figure>
<p>这就追加了额外的key为app，value为happylive的参数，表示使用happylive应用来连接而代替rtmp url中的live应用</p>
<p>关于librtmp的更多额外的参数配置，可以看<a href="http://rtmpdump.mplayerhq.hu/librtmp.3.html" target="_blank" rel="external">librtmp文档</a></p>
<h3 id="librtmp编译"><a href="#librtmp编译" class="headerlink" title="librtmp编译"></a><strong>librtmp编译</strong></h3><p>由于librtmp默认依赖zlib和openssl这两个库，所以编译时需要链接这两个库，由于NDK自带了zlib库，所以不需要单独去下载和编译，在编译librtmp时配置<code>Android.mk</code>文件的<code>LOCAL_LDLIBS</code>属性为<code>-lz</code>链接即可，编译时会在指定的platforms的arch-xxx/usr/lib/目录下搜索</p>
<p>编译librtmp，在librtmp目录下新建Android.mk文件，内容如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译模块输出的名称</span></span><br><span class="line">LOCAL_MODULE := rtmp</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译所需的头文件路径</span></span><br><span class="line">LOCAL_C_INCLUDES += \</span><br><span class="line">$(LOCAL_PATH)/</span><br><span class="line"><span class="preprocessor">#$(LOCAL_PATH)/../openssl/include/ #链接openssl库</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译所需的源文件路径</span></span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">amf.c       \</span><br><span class="line">log.c       \</span><br><span class="line">parseurl.c  \</span><br><span class="line">rtmp.c      \</span><br><span class="line">hashswf.c</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译时候需要链接的动态库库存在静态库形式，将会链接到对应的静态库而不是动态库</span></span><br><span class="line"><span class="preprocessor"># LOCAL_FORCE_STATIC_EXECUTABLE := true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 添加编译配置选项，一些常用编译配置：</span></span><br><span class="line"><span class="preprocessor"># -fPIC:编译位置无关的代码，一般用于编译动态库</span></span><br><span class="line"><span class="preprocessor"># -02:编译优化程度</span></span><br><span class="line"><span class="preprocessor"># -lxxx:链接名为libxxx库</span></span><br><span class="line"><span class="preprocessor"># -I添加编译器搜索-l指定的库文件的搜索</span></span><br><span class="line"><span class="preprocessor"># -D:加入宏定义，如：NO_CRYPTO，不使用加密</span></span><br><span class="line">LOCAL_CFLAGS += -DRTMPDUMP_VERSION=v2<span class="number">.4</span> -DNO_CRYPTO -Wall -fPIC -O2 </span><br><span class="line"><span class="preprocessor">#LOCAL_CFLAGS += -I$(LOCAL_PATH)/../openssl -lssl -lcrypto #可选添加openssl支持，需去除-DNO_CRYPTO</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 添加编译时需要链接器链接的那些存在于NDK目录下的其它库，所链接库的以“-lxxx”格式命名，如：-lz 表示编译时会加载libz.so库</span></span><br><span class="line">LOCAL_LDLIBS += -lz</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># include $(BUILD_STATIC_LIBRARY)</span></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>关于mk文件的编写和参数配置，可以阅读<a href="https://developer.android.com/ndk/guides/android_mk.html" target="_blank" rel="external">mk官网文档</a>，上面也给出了全部编译时参数配置的注释，由于上面配置加入了<code>NO_CRYPTO</code>定义，没有链接openssl库，需要的可以自己加或者使用<a href="https://tls.mbed.org/" target="_blank" rel="external">PolarSSL</a>、<a href="http://www.gnu.org/software/gnutls/" target="_blank" rel="external">GnuTLS</a>来替代<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a></p>
<p>然后在rtmpdump目录下也建立个Android.mk文件，内容为：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">LOCAL_PATH</span> := <span class="variable">$(</span>call my-dir)</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(</span><span class="constant">CLEAR_VARS</span>)</span><br><span class="line">subdirs := <span class="variable">$(</span>addprefix <span class="variable">$(</span><span class="constant">LOCAL_PATH</span>)/,<span class="variable">$(</span>addsuffix /<span class="constant">Android</span>.mk, \</span><br><span class="line">librtmp \</span><br><span class="line">))</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(</span>subdirs)</span><br></pre></td></tr></table></figure>
<p>其实不需要这个也行，不过加入该文件目的是为了能够统一rtmpdump文件夹下和子目录中的mk的编译运行入口，这样只需调用这一个mk文件即可，上面配置的只会运行librtmp目录下的mk文件，如果需要加入其它的，则在<code>subdirs</code>中加入即可，如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subdirs </span>:= $(<span class="keyword">addprefix </span>$(LOCAL_PATH)/,$(<span class="keyword">addsuffix </span>/<span class="keyword">Android.mk, </span>\</span><br><span class="line"><span class="label">librtmp</span> \</span><br><span class="line"><span class="label">otherdir</span> \</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>最后在rtmpdump中新建jni目录，新建Application.mk文件，内容为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NDK_TOOLCHAIN_VERSION</span> := 4.9</span><br><span class="line"><span class="constant">APP_PLATFORM</span> := android-14</span><br><span class="line"><span class="constant">APP_ABI</span> := all</span><br><span class="line"><span class="constant">APP_OPTIM</span> := release</span><br><span class="line"><span class="constant">APP_PROJECT_PATH</span> := <span class="variable">$(shell pwd)</span></span><br><span class="line"><span class="constant">APP_BUILD_SCRIPT</span> := <span class="variable">$(APP_PROJECT_PATH)</span>/Android.mk</span><br></pre></td></tr></table></figure>
<p>主要是对编译时的编译配置进行配置，<code>APP_ABI := all</code>表示支持当前平台支持的的全部CPU架构</p>
<p>然后新建一个开始执行编译的脚本文件，内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">NDK=<span class="variable">$HOME</span>/Library/Android/sdk/ndk-bundle</span><br><span class="line"><span class="variable">$NDK</span>/ndk-build NDK_APPLICATION_MK=./jni/Application.mk NDK_PROJECT_PATH=./</span><br></pre></td></tr></table></figure>
<p>其中NDK路径替换为自己的即可，开始编译：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> rtmpdump</span><br><span class="line">./build_librtmp.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>成功后，可以在rtmpdump目录下看到obj和libs两个文件夹，libs存放着编译出来的动态库，而obj则是存放静态库，这取决于所配置的是<code>BUILD_SHARED_LIBRARY</code>还是<code>BUILD_STATIC_LIBRARY</code></p>
<p>当然其它库也可以用这种方式进行编译</p>
<h2 id="在FFmpeg中使用librtmp"><a href="#在FFmpeg中使用librtmp" class="headerlink" title="在FFmpeg中使用librtmp"></a><strong>在FFmpeg中使用librtmp</strong></h2><p>由于FFmpeg本身默认自带就支持rtmp、rtmpt协议，不过也可以扩展以便支持rtmp协议的多种变种协议（rtmps、rtmpt、rtmpts、rtmpte和rtmpe协议），在FFmpeg加入openssl库的支持，可以支持rtmps、rtmpts协议，加入libgcrypt库的支持，可以支持rtmpe、rtmpte协议，这样支持相对麻烦，可以直接使用librtmp来支持rtmp以及它的多种变种协议，可通过链接librtmp库来支持，在FFmpeg的编译脚本中加入以下配置：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--enable-librtmp</span><br><span class="line">--extra-cflags=-I/<span class="variable">$LIBRTMP</span>_INCLUDE_PATH</span><br><span class="line">--extra-ldflags=-L/<span class="variable">$LIBRTMP</span>_LIB_PATH</span><br></pre></td></tr></table></figure>
<p>上面的<code>$LIBRTMP_INCLUDE_PATH</code>和<code>$LIBRTMP_LIB_PATH</code>分别是librtmp头文件和静态库的路径<br>关于FFmpeg如何链接第三方库请看我的这篇文章<a href="http://zhengxiaoyong.me/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/">初识FFmpeg编译那些事</a></p>
<p>如果在编译时发生错误或警告<code>xxx-pkg-config not found</code>，请找到FFmpeg的configure文件中的如下内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enabled librtmp           &amp;&amp; require_pkg_config librtmp librtmp/rtmp<span class="class">.h</span> RTMP_Socket</span><br></pre></td></tr></table></figure>
<p>将后面的<code>&amp;&amp; require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket</code>删了，因为FFmpeg在链接librtmp时会运行pkg-config，此时找不到pkg-config则会报错，当然还有链接其它库时如果发生类似错误也可以用同样的方法解决</p>
<h2 id="Librtmp编译源码"><a href="#Librtmp编译源码" class="headerlink" title="Librtmp编译源码"></a><strong>Librtmp编译源码</strong></h2><p><a href="https://github.com/Sunzxyong/Librtmp-Compile-For-Android" target="_blank" rel="external">librtmp编译源码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RTMPDump概述&quot;&gt;&lt;a href=&quot;#RTMPDump概述&quot; class=&quot;headerlink&quot; title=&quot;RTMPDump概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;RTMPDump概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://rtmpdump.mplayerhq.hu/&quot;&gt;RTMPDump主页&lt;/a&gt;，RTMPDump库主要包含三部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、一个基本的客户端程序&lt;br&gt;2、两个服务器程序（rtmpsrv、rtmpsuck）&lt;br&gt;3、一个支持rtmp协议的库—librtmp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载RTMPDump最新源码，可以通过git拉取master分支上的最新代码：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;git&lt;/span&gt;://git.ffmpeg.org/rtmpdump&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者下载以前版本的代码—&lt;a href=&quot;http://rtmpdump.mplayerhq.hu/download/&quot;&gt;Download old version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面主要介绍librtmp和librtmp的编译&lt;/p&gt;
&lt;h3 id=&quot;librtmp概述&quot;&gt;&lt;a href=&quot;#librtmp概述&quot; class=&quot;headerlink&quot; title=&quot;librtmp概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;librtmp概述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;librtmp库提供了大量客户端函数和少部分的服务器端的函数用来支持RTMP、RTMPT（RTMP使用Http通道），RTMPE（加密的RTMP），RTMPS（基于SSL/TLS的RTMP）和RTMPTE、RTMPTS（使用Http通道的加密和基于SSL/TLS的RTMP）协议&lt;/p&gt;
&lt;p&gt;使用librtmp库进行的流媒体交互都是使用&lt;strong&gt;FLV&lt;/strong&gt;封包格式进行传输的，当然编码不限定，不过为了拉流端同时也支持&lt;strong&gt;HLS&lt;/strong&gt;协议，最好使用&lt;strong&gt;H264&lt;/strong&gt;编码视频和&lt;strong&gt;AAC&lt;/strong&gt;编码音频数据&lt;/p&gt;
    
    </summary>
    
      <category term="流媒体" scheme="http://zhengxiaoyong.me/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="RTMPDump" scheme="http://zhengxiaoyong.me/tags/RTMPDump/"/>
    
      <category term="librtmp" scheme="http://zhengxiaoyong.me/tags/librtmp/"/>
    
      <category term="librtmp编译" scheme="http://zhengxiaoyong.me/tags/librtmp%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>初识FFmpeg编译那些事</title>
    <link href="http://zhengxiaoyong.me/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://zhengxiaoyong.me/2016/11/13/初识FFmpeg编译那些事/</id>
    <published>2016-11-13T12:45:10.000Z</published>
    <updated>2016-11-23T10:24:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FFmpeg简介"><a href="#FFmpeg简介" class="headerlink" title="FFmpeg简介"></a><strong>FFmpeg简介</strong></h2><p>FFMPEG是一套具有非常强大功能的多媒体处理工具，它几乎涵盖了目前所有主流的多媒体数据封装格式、多媒体传输协议以及音视频编解码器，并且支持多媒体后处理，视频色彩转换、滤镜和缩放等，也支持众多主流的协议：HTTP、RTP、RTSP、RTMP、HLS、UDP等<br>安装可以通过Homebrew</p>
<p>FFmpeg它主要含有以下几个核心库：</p>
<blockquote>
<p>1、libavcodec-提供了更加全面的编解码实现的合集<br>2、libavformat-提供了更加全面的音视频容器格式的封装和解析以及所支持的协议<br>3、libavutil-提供了一些公共函数<br>4、libavfilter-提供音视频的过滤器，如视频加水印、音频变声等<br>5、libavdevice-提供支持众多设备数据的输入与输出，如读取摄像头数据、屏幕录制<br>6、libswresample,libavresample-提供音频的重采样工具<br>7、libswscale-提供对视频图像进行色彩转换、缩放以及像素格式转换，如图像的YUV转换<br>8、libpostproc-多媒体后处理器</p>
</blockquote>
<p>以及包含以下几个工具：</p>
<blockquote>
<p>1、ffmpeg-一个流媒体的编解码、格式转换以及多媒体流的内容处理工具<br>2、ffplay-一个使用FFmpeg编解码的播放器<br>3、ffprobe-一个多媒体分析工具<br>4、ffserver-一个流多媒体服务器</p>
</blockquote>
<a id="more"></a>
<h2 id="FFmpeg命令"><a href="#FFmpeg命令" class="headerlink" title="FFmpeg命令"></a><strong>FFmpeg命令</strong></h2><p>一些命令：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助</span></span><br><span class="line">ffmpeg -help</span><br><span class="line"><span class="comment">//支持的格式</span></span><br><span class="line">ffmpeg -formats</span><br><span class="line"><span class="comment">//支持的解码</span></span><br><span class="line">ffmpeg -decoders</span><br><span class="line"><span class="comment">//支持的编码</span></span><br><span class="line">ffmpeg -encoders</span><br><span class="line"><span class="comment">//支持的协议</span></span><br><span class="line">ffmpeg -protocols</span><br><span class="line"><span class="comment">//本地视频文件推流至指定rtmp流媒体服务器</span></span><br><span class="line">ffmpeg -re -<span class="tag">i</span> movie<span class="class">.mp4</span> -c copy -f flv rtmp:<span class="comment">//localhost:1935/live/room</span></span><br><span class="line"><span class="comment">//媒体流保存为视频文件</span></span><br><span class="line">ffmpeg -<span class="tag">i</span> rtmp:<span class="comment">//localhost:1935/live/room -c copy moive.flv</span></span><br></pre></td></tr></table></figure>
<p>更多命令请看文档<a href="http://ffmpeg.org/documentation.html" target="_blank" rel="external">FFmpeg文档</a></p>
<h2 id="FFmpeg编译"><a href="#FFmpeg编译" class="headerlink" title="FFmpeg编译"></a><strong>FFmpeg编译</strong></h2><p>首先在官网下载<a href="http://ffmpeg.org/" target="_blank" rel="external">FFmpeg</a></p>
<p>在root dir编辑configure文件，把以下内容</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">SLIBNAME_WITH_MAJOR</span>='<span class="variable">$(SLIBNAME)</span>.<span class="variable">$(LIBMAJOR)</span>'</span><br><span class="line"><span class="constant">LIB_INSTALL_EXTRA_CMD</span>='$<span class="variable">$(RANLIB)</span> "<span class="variable">$(LIBDIR)</span>/<span class="variable">$(LIBNAME)</span>"'</span><br><span class="line"><span class="constant">SLIB_INSTALL_NAME</span>='<span class="variable">$(SLIBNAME_WITH_VERSION)</span>'</span><br><span class="line"><span class="constant">SLIB_INSTALL_LINKS</span>='<span class="variable">$(SLIBNAME_WITH_MAJOR)</span> <span class="variable">$(SLIBNAME)</span>'</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">SLIBNAME_WITH_MAJOR</span>='<span class="variable">$(SLIBPREF)</span><span class="variable">$(FULLNAME)</span>-<span class="variable">$(LIBMAJOR)</span><span class="variable">$(SLIBSUF)</span>'</span><br><span class="line"><span class="constant">LIB_INSTALL_EXTRA_CMD</span>='$<span class="variable">$(RANLIB)</span> "<span class="variable">$(LIBDIR)</span>/<span class="variable">$(LIBNAME)</span>"'</span><br><span class="line"><span class="constant">SLIB_INSTALL_NAME</span>='<span class="variable">$(SLIBNAME_WITH_MAJOR)</span>'</span><br><span class="line"><span class="constant">SLIB_INSTALL_LINKS</span>='<span class="variable">$(SLIBNAME)</span>'</span><br></pre></td></tr></table></figure>
<p>目的是修改so的文件名，为了编译出来的so能够被android平台正常使用，否则将编译出<code>libavcodec.so.57.64.100</code>这种类型的so，替换后将编译成我们能正常使用的<code>libavcodec-57.so</code>动态链接库，后面的数字为版本号</p>
<p>一般对于so，我们只需兼容arm cpu架构的即可，在root dir下新建bash脚本文件，内容为：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">NDK=$HOME/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=$NDK/platforms/android-14/arch-arm/</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64</span><br><span class="line"></span><br><span class="line">CPU=arm</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">ADDI_CFLAGS=""</span><br><span class="line">ADDI_LDFLAGS=""</span><br><span class="line"></span><br><span class="line">function build_arm</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    -<span class="ruby">-prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line"></span>    -<span class="ruby">-enable-shared \</span><br><span class="line"></span>    -<span class="ruby">-disable-static \</span><br><span class="line"></span>    -<span class="ruby">-disable-doc \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffmpeg \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffplay \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffprobe \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffserver \</span><br><span class="line"></span>    -<span class="ruby">-disable-symver \</span><br><span class="line"></span>    -<span class="ruby">-enable-avresample \</span><br><span class="line"></span>    -<span class="ruby">-enable-small \</span><br><span class="line"></span>    -<span class="ruby">-cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \</span><br><span class="line"></span>    -<span class="ruby">-target-os=linux \</span><br><span class="line"></span>    -<span class="ruby">-arch=arm \</span><br><span class="line"></span>    -<span class="ruby">-enable-cross-compile \</span><br><span class="line"></span>    -<span class="ruby">-sysroot=<span class="variable">$SYSROOT</span> \</span><br><span class="line"></span>    -<span class="ruby">-extra-cflags=<span class="string">"-Os -fpic $ADDI_CFLAGS"</span> \</span><br><span class="line"></span>    -<span class="ruby">-extra-ldflags=<span class="string">"$ADDI_LDFLAGS"</span> \</span><br><span class="line"></span>    $ADDITIONAL_CONFIGURE_FLAG</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_arm</span><br></pre></td></tr></table></figure>
<p>NDK目录改为自己的NDK目录即可，关于configure配置，可以根据自己需要进行配置，可配置的属性在FFmpeg root dir的configure文件中show_help方法中查看，我摘一段：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Program options:</span><br><span class="line">-<span class="ruby">-disable-programs       <span class="keyword">do</span> <span class="keyword">not</span> build command line programs</span><br><span class="line"></span>-<span class="ruby">-disable-ffmpeg         disable ffmpeg build</span><br><span class="line"></span>-<span class="ruby">-disable-ffplay         disable ffplay build</span><br><span class="line"></span>-<span class="ruby">-disable-ffprobe        disable ffprobe build</span><br><span class="line"></span>-<span class="ruby">-disable-ffserver       disable ffserver build</span></span><br></pre></td></tr></table></figure>
<p><code>--disable-ffmpeg</code>意为禁用ffmpeg工具，编译时不编译出ffmpeg工具，<code>--enable-ffmpeg</code>为启用，但是configure文件配置有个特点，FFmpeg的默认的配置不是以show_help方法中的配置配置的，而是以前缀<code>disable</code>or<code>enable</code>取反配置的，也就是FFmpeg中各属性默认的配置把show_help中各个配置的前缀取反即可，<code>disable</code>变为<code>enable</code>，<code>enable</code>变为<code>disable</code>，如：在上面那段配置中，<code>--disable-ffmpeg</code>意为启用ffmpeg工具。</p>
<p>但是我们编译的bash脚本中却不是这样，而是配置的实意配置，<code>disable</code>就是<code>disable</code>。</p>
<p>运行上面的bash脚本：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ffmpeg-3.2</span><br><span class="line">./build_ffmpeg_arm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>编译完成后可以发现在FFmpeg的root目录下多了一个android目录，该目录就是所生成对应cup架构的so目录<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-11-14788686122391.jpg" alt=""></p>
<hr>
<p>按以上配置的bash脚本，会发现<code>libavcodec-57.so</code>比较大，有7.6M，肯定不能在Android中使用，所以，在编译时，我们可以针对自己需要的功能来进行配置，更改bash脚本，加入配置：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--disable-everything</span></span><br></pre></td></tr></table></figure>
<p>该属性会把下列所有的组件都不加入编译：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Individual component options:</span><br><span class="line">-<span class="ruby">-disable-everything     disable all components listed below</span><br><span class="line"></span>-<span class="ruby">-disable-encoder=<span class="constant">NAME</span>   disable encoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-encoder=<span class="constant">NAME</span>    enable encoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-encoders       disable all encoders</span><br><span class="line"></span>-<span class="ruby">-disable-decoder=<span class="constant">NAME</span>   disable decoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-decoder=<span class="constant">NAME</span>    enable decoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-decoders       disable all decoders</span><br><span class="line"></span>-<span class="ruby">-disable-hwaccel=<span class="constant">NAME</span>   disable hwaccel <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-hwaccel=<span class="constant">NAME</span>    enable hwaccel <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-hwaccels       disable all hwaccels</span><br><span class="line"></span>-<span class="ruby">-disable-muxer=<span class="constant">NAME</span>     disable muxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-muxer=<span class="constant">NAME</span>      enable muxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-muxers         disable all muxers</span><br><span class="line"></span>-<span class="ruby">-disable-demuxer=<span class="constant">NAME</span>   disable demuxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-demuxer=<span class="constant">NAME</span>    enable demuxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-demuxers       disable all demuxers</span><br><span class="line"></span>-<span class="ruby">-enable-parser=<span class="constant">NAME</span>     enable parser <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-parser=<span class="constant">NAME</span>    disable parser <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-parsers        disable all parsers</span><br><span class="line"></span>-<span class="ruby">-enable-bsf=<span class="constant">NAME</span>        enable bitstream filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-bsf=<span class="constant">NAME</span>       disable bitstream filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-bsfs           disable all bitstream filters</span><br><span class="line"></span>-<span class="ruby">-enable-protocol=<span class="constant">NAME</span>   enable protocol <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-protocol=<span class="constant">NAME</span>  disable protocol <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-protocols      disable all protocols</span><br><span class="line"></span>-<span class="ruby">-enable-indev=<span class="constant">NAME</span>      enable input device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-indev=<span class="constant">NAME</span>     disable input device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-indevs         disable input devices</span><br><span class="line"></span>-<span class="ruby">-enable-outdev=<span class="constant">NAME</span>     enable output device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-outdev=<span class="constant">NAME</span>    disable output device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-outdevs        disable output devices</span><br><span class="line"></span>-<span class="ruby">-disable-devices        disable all devices</span><br><span class="line"></span>-<span class="ruby">-enable-filter=<span class="constant">NAME</span>     enable filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-filter=<span class="constant">NAME</span>    disable filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-filters        disable all filters</span></span><br></pre></td></tr></table></figure>
<p>而我们生成的<code>libavcodec-57.so</code>过大也是由于加入了过多我们不需要使用的组件，禁用了所有的，接下来就是把自己需要的加入到bash脚本中配置即可，比如加入下面两个配置确保h264和aac的解码功能的保留：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-enable-decoder=h264</span><br><span class="line"></span>-<span class="ruby">-enable-decoder=aac</span></span><br></pre></td></tr></table></figure>
<p>等等，当然还有其它的，可以参考上面禁用的配置进行选择性保留。</p>
<h2 id="编译支持H-264编码的FFmpeg动态链接库"><a href="#编译支持H-264编码的FFmpeg动态链接库" class="headerlink" title="编译支持H.264编码的FFmpeg动态链接库"></a><strong>编译支持H.264编码的FFmpeg动态链接库</strong></h2><h3 id="x264"><a href="#x264" class="headerlink" title="x264"></a><strong>x264</strong></h3><p>首先下载<a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="external">x264源码</a><br>x264是一个开源的H.264编码器，据说是最好的视频有损编码器，和编译FFmpeg类似，要编译x264成动态so库，一样通过configure配置文件，需要先修改configure文件中的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"SOSUFFIX=so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SONAME=libx264.so.$API"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SOFLAGS=-shared -Wl,-soname,\$(SONAME) $SOFLAGS"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"SOSUFFIX=so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SONAME=libx264-$API.so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SOFLAGS=-shared -Wl,-soname,\$(SONAME) $SOFLAGS"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br></pre></td></tr></table></figure>
<p>目的一样，确保可以在Android平台下可用，然后使用下面的bash脚本进行编译，arm为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">NDK=<span class="variable">$HOME</span>/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=<span class="variable">$NDK</span>/platforms/android-<span class="number">14</span>/arch-arm/</span><br><span class="line">TOOLCHAIN=<span class="variable">$NDK</span>/toolchains/arm-linux-androideabi-<span class="number">4.9</span>/prebuilt/darwin-x86_64</span><br><span class="line"></span><br><span class="line">CPU=arm</span><br><span class="line">PREFIX=$(<span class="built_in">pwd</span>)/android/<span class="variable">$CPU</span></span><br><span class="line">ADDI_CFLAGS=<span class="string">""</span></span><br><span class="line">ADDI_LDFLAGS=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> build_arm</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    --prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --disable-asm \</span><br><span class="line">    --enable-pic \</span><br><span class="line">    --enable-strip \</span><br><span class="line">    --host=arm-linux-androideabi \</span><br><span class="line">    --cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \</span><br><span class="line">    --sysroot=<span class="variable">$SYSROOT</span></span><br><span class="line">    --extra-cflags=<span class="string">"-Os -fpic <span class="variable">$ADDI_CFLAGS</span>"</span> \</span><br><span class="line">    --extra-ldflags=<span class="string">"<span class="variable">$ADDI_LDFLAGS</span>"</span> \</span><br><span class="line">    <span class="variable">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_arm</span><br></pre></td></tr></table></figure>
<p>NDK目录同样改为自己的<br>运行上面脚本：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> x264</span><br><span class="line">./build_x264_arm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>编译完成后可以android目录找到<code>libx264-148.so</code>库</p>
<h3 id="静态链接x264编译"><a href="#静态链接x264编译" class="headerlink" title="静态链接x264编译"></a><strong>静态链接x264编译</strong></h3><p>FFmpeg默认是不支持H.264的编码，不过支持H.264解码，但是FFmpeg为我们提供了众多配置，可添加额外功能库的支持，方便我们自己链接所需要额外功能的库，在FFmpeg的configure文件配置中，可以看到这么一段配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">External library support:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">-<span class="ruby">-enable-libfdk-aac      enable <span class="constant">AAC</span> de/encoding via libfdk-aac [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libopenh264     enable <span class="constant">H</span>.<span class="number">264</span> encoding via <span class="constant">OpenH264</span> [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libopenjpeg     enable <span class="constant">JPEG</span> <span class="number">2000</span> de/encoding via <span class="constant">OpenJPEG</span> [no]</span><br><span class="line"></span>-<span class="ruby">-enable-librtmp         enable <span class="constant">RTMP</span>[<span class="constant">E</span>] support via librtmp [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libwebp         enable <span class="constant">WebP</span> encoding via libwebp [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libx264         enable <span class="constant">H</span>.<span class="number">264</span> encoding via x264 [no]</span><br><span class="line"></span>-<span class="ruby">-enable-opengl          enable <span class="constant">OpenGL</span> rendering [no]</span><br><span class="line"></span>-<span class="ruby">-enable-openssl         enable openssl, needed <span class="keyword">for</span> https support</span><br><span class="line"></span>if gnutls is not used [no]</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>避免篇幅太长，做了一部分删减，留了一些比较眼熟的，FFmpeg可以让我们自己配置添加需要的功能库，如使用fdk-aac库来做aac的编解码，H.264编码可选x264或openh264以及可选其它功能库的支持</p>
<p>要编译支持x264编码的FFmpeg动态链接库，首先是编译出x264静态链接库<code>libx264.a</code>，然后修改FFmpeg的编译脚本，配置x264静态链接库和头文件路径，接下来即可编译了</p>
<h4 id="1、编译x264静态链接库"><a href="#1、编译x264静态链接库" class="headerlink" title="1、编译x264静态链接库"></a><strong>1、编译x264静态链接库</strong></h4><p>因为FFmpeg是使用静态链接方式链接其它额外的外部功能库，所以需要把x264库编译成<code>.a</code>静态库，通过<code>--enable-static</code>配置参数来编译出<code>.a</code>静态库，而<code>--enable-shared</code>则是编译动态链接so库，所以只需在上面的x264脚本中增加个配置：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-<span class="keyword">static</span></span><br></pre></td></tr></table></figure>
<p>编译成功后可以看到如下目录结构：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-13-14789707702522.jpg" alt=""></p>
<h4 id="2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译"><a href="#2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译" class="headerlink" title="2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译"></a><strong>2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译</strong></h4><p>在此之前，先安装yasm：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install yasm</span><br></pre></td></tr></table></figure>
<p>然后在之前FFmpeg的脚本基础上添加以下配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-enable-gpl \</span><br><span class="line"></span>-<span class="ruby">-enable-libx264 \</span><br><span class="line"></span>-<span class="ruby">-enable-yasm \</span><br><span class="line"></span>-<span class="ruby">-extra-cflags=<span class="string">"-I../x264/android/arm/include"</span> \</span><br><span class="line"></span>-<span class="ruby">-extra-ldflags=<span class="string">"-L../x264/android/arm/lib"</span> \</span></span><br></pre></td></tr></table></figure>
<p>FFmpeg默认的LICENSE是LGPL，而libx264需要GPL，所以加入<code>--enable-gpl</code>，最后面两项配置是配置编译x264出的头文件和静态链接库路径，在这里我把x264和FFmpeg放在了同一目录层级，故可这样配置。<br>如果你需要修改<code>--extra-cflags</code>和<code>--extra-ldflags</code>路径为自己x264头文件和静态链接库路径，必须符合<code>--extra-cflags</code>以-I开头，<code>--extra-ldflags</code>以-L开头，这些参数含义为：</p>
<blockquote>
<p>-D：用于在编译时定义宏<br>-I：编译阶段生效的参数，用于指定头文件的搜索路径<br>-L：链接阶段生效的参数，用于指定链接库的搜索路径，-l用于指定链接库的名称，一般两者一起使用的话，就可以指定动态链接库</p>
</blockquote>
<p>比如x264在桌面上，路径为：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-extra-cflags=<span class="string">"-I/Users/Sunzxyong/Desktop/x264/android/arm/include"</span> \</span><br><span class="line"></span>-<span class="ruby">-extra-ldflags=<span class="string">"-L/Users/Sunzxyong/Desktop/x264/android/arm/lib"</span> \</span></span><br></pre></td></tr></table></figure>
<p>然后进行编译，编译中可以看到encode的支持选择中，多了libx264的支持：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-13-14790203252342.jpg" alt=""></p>
<p>其它外部添加库如fdk-aac、openh264等也类似方式链接编译</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h2><p><a href="https://github.com/Sunzxyong/FFmpeg-Compile-For-Android" target="_blank" rel="external">FFmpeg编译脚本</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;FFmpeg简介&quot;&gt;&lt;a href=&quot;#FFmpeg简介&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;FFmpeg简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;FFMPEG是一套具有非常强大功能的多媒体处理工具，它几乎涵盖了目前所有主流的多媒体数据封装格式、多媒体传输协议以及音视频编解码器，并且支持多媒体后处理，视频色彩转换、滤镜和缩放等，也支持众多主流的协议：HTTP、RTP、RTSP、RTMP、HLS、UDP等&lt;br&gt;安装可以通过Homebrew&lt;/p&gt;
&lt;p&gt;FFmpeg它主要含有以下几个核心库：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、libavcodec-提供了更加全面的编解码实现的合集&lt;br&gt;2、libavformat-提供了更加全面的音视频容器格式的封装和解析以及所支持的协议&lt;br&gt;3、libavutil-提供了一些公共函数&lt;br&gt;4、libavfilter-提供音视频的过滤器，如视频加水印、音频变声等&lt;br&gt;5、libavdevice-提供支持众多设备数据的输入与输出，如读取摄像头数据、屏幕录制&lt;br&gt;6、libswresample,libavresample-提供音频的重采样工具&lt;br&gt;7、libswscale-提供对视频图像进行色彩转换、缩放以及像素格式转换，如图像的YUV转换&lt;br&gt;8、libpostproc-多媒体后处理器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及包含以下几个工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、ffmpeg-一个流媒体的编解码、格式转换以及多媒体流的内容处理工具&lt;br&gt;2、ffplay-一个使用FFmpeg编解码的播放器&lt;br&gt;3、ffprobe-一个多媒体分析工具&lt;br&gt;4、ffserver-一个流多媒体服务器&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="流媒体" scheme="http://zhengxiaoyong.me/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="FFmpeg" scheme="http://zhengxiaoyong.me/tags/FFmpeg/"/>
    
      <category term="FFmpeg编译" scheme="http://zhengxiaoyong.me/tags/FFmpeg%E7%BC%96%E8%AF%91/"/>
    
      <category term="x264" scheme="http://zhengxiaoyong.me/tags/x264/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时Crash自动恢复框架-Recovery</title>
    <link href="http://zhengxiaoyong.me/2016/09/05/Android%E8%BF%90%E8%A1%8C%E6%97%B6Crash%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E6%A1%86%E6%9E%B6-Recovery/"/>
    <id>http://zhengxiaoyong.me/2016/09/05/Android运行时Crash自动恢复框架-Recovery/</id>
    <published>2016-09-05T11:35:32.000Z</published>
    <updated>2016-09-08T09:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><blockquote>
<p>App Crash的恢复，这个想法很早之前就有，目前有些时间就实现了一把，主要是对App运行时发生Crash后，对Activity的堆栈和数据进行恢复，或者重启应用，或者重启并清空缓存，避免因本地的数据类型或格式错误而导致App在读取时一直Crash，Debug模式还包括Crash信息的显示和保存，便于在开发、测试时查看相应CrashInfo</p>
</blockquote>
<h1 id="Crash的处理"><a href="#Crash的处理" class="headerlink" title="Crash的处理"></a><strong>Crash的处理</strong></h1><p>对于应用的Crash，一般的做法我们往往都是实现个自定义<code>UncaughtExceptionHandler</code>，而这个自定义的CustomUncaughtHandler我们一般都用于捕捉Crash信息进行上报和监控是否发生Crash，还有一个作用就是可以屏蔽系统默认的Crash对话框，也就是拦截Crash后不把系统默认的UncaughtHandler设置进去，而是直接进行KillProcess，这个过程就是屏蔽了系统的默认Crash处理流程，原因是系统的处理其中在AMS的crashApplication()中会执行这么一段代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> msg = <span class="type">Message</span>.obtain();</span><br><span class="line">msg.what = <span class="type">SHOW_ERROR_MSG</span>;</span><br><span class="line"><span class="type">HashMap</span> data = new <span class="type">HashMap</span>();</span><br><span class="line">data.put(<span class="string">"result"</span>, <span class="literal">result</span>);</span><br><span class="line">data.put(<span class="string">"app"</span>, r);</span><br><span class="line">msg.obj = data;</span><br><span class="line">mUiHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>发送一个显示Dialog的消息，之后便创建一个AppErrorDialog进行显示。<br><a id="more"></a><br>当然还有另外一种屏蔽系统默认ErrorDialog的方法，就是对AMP进行Hook，拦截handleApplicationCrash()方法后进行KillProcess，这样的话永远都将不会出现系统默认对话框，即使把系统默认的设置进去了，这个方法建议App内对AMP进行了Hook的做，其它App反而只为实现这个小功能而进行Hook成本太高，还是用自定义的做法进行屏蔽。</p>
<h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a><strong>Recovery</strong></h1><h2 id="Crash处理流程"><a href="#Crash处理流程" class="headerlink" title="Crash处理流程"></a><strong>Crash处理流程</strong></h2><p>对于Recovery，在应用发生Crash时，会进入一个Recovery界面，在该界面可以进行界面的恢复、应用的重启，或进入debug模式进行Crash信息的查看与保存</p>
<h2 id="接入"><a href="#接入" class="headerlink" title="接入"></a><strong>接入</strong></h2><h3 id="请戳这里"><a href="#请戳这里" class="headerlink" title="请戳这里"></a><a href="https://github.com/Sunzxyong/Recovery/blob/master/README.md" target="_blank" rel="external">请戳这里</a></h3><h2 id="RecoveryActivity"><a href="#RecoveryActivity" class="headerlink" title="RecoveryActivity"></a><strong>RecoveryActivity</strong></h2><p>在应用发生Crash后，将进入RecoveryActivity界面<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/Recovery.png" alt="Recovery"></p>
<h2 id="ActivityStack的恢复"><a href="#ActivityStack的恢复" class="headerlink" title="ActivityStack的恢复"></a><strong>ActivityStack的恢复</strong></h2><p>对于恢复界面，默认是恢复整个Activity的堆栈，以便保护用户之前的数据</p>
<p>当应用在前台时崩溃无非就三种：<br>1、界面一创建就崩溃，可能在onCreate等方法中读取数据造成的Crash<br>2、界面创建且绘制完成正常显示，在用户执行某个操作，如点击按钮执行某个操作等造成的Crash<br>3、其它异步线程、服务等在后台执行任务时导致的Crash</p>
<p>上面的情况都应恢复绘制完成后的界面，也就是栈顶Activity是在Crash之前用户所看到的界面，而之前创建且未销毁的Activity也应该进行恢复。</p>
<p>当应用在后台时：<br>1、进程未挂，无非就是异步线程、server等后台任务发生异常时导致的Crash<br>2、进程已挂，进程被360等工具杀死了，常见的是push过来了然后唤起App进程，在解析push信息时候导致Crash</p>
<p>上面的情况App在后台时导致的Crash，Recovery提供了一个参数（recoverInBackgroud），用来设置是否在后台Crash时进行恢复。</p>
<p>ActivityStack恢复的操作，都是先恢复栈中的Activity，无Activity时则重启应用</p>
<h2 id="主页的回退"><a href="#主页的回退" class="headerlink" title="主页的回退"></a><strong>主页的回退</strong></h2><p>在进行恢复Activity时，如果只是恢复栈顶Activity，当用户在这个界面不进行跳转操作而是直接按返回键，这将导致直接退出程序，所以对于这个情况应该是回退到应用的主页，Recovery中有个参数mainPage，如果设置了就表示需要回退到主页，没有设置则不进行回退</p>
<p>这个过程中涉及到获取App内Activity栈内的数量和栈底Activity，是开发人员应该都知道获取这两个信息是通过getRunningTasks来获取，不过可惜，在5.0以后Google对权限进行了收敛，目地是保护App的信息安全，这个方法在5.0以后将失效，所以需要另外一种方法进行兼容，于是乎看6.0源码又发现Google在5.0收敛了整个权限，导致本App的都获取不到，但是在6.0又放出来了，不过只能获取本应用的数据，所以兼容的策略是5.0~6.0自己维护一个ActivityStack</p>
<h2 id="连续Crash的处理"><a href="#连续Crash的处理" class="headerlink" title="连续Crash的处理"></a><strong>连续Crash的处理</strong></h2><p>如果一分钟内进行了两次恢复后还导致Crash，则不进行恢复而是重启应用，或者重启并清空缓存，以便恢复App刚安装时的状态</p>
<h2 id="静默恢复"><a href="#静默恢复" class="headerlink" title="静默恢复"></a><strong>静默恢复</strong></h2><p>对于应用运行时发生Crash后的恢复，默认是显示RecoveryActivity，也就是上图的界面来让用户选择是否需要进行恢复，同时也支持静默恢复，也就是不显示界面，在发生Crash后根据所配置参数自动的恢复（重启、恢复ActivityStack、恢复栈顶Activity、重启并清空缓存）</p>
<h2 id="无图言屌"><a href="#无图言屌" class="headerlink" title="无图言屌"></a><strong>无图言屌</strong></h2><p>下面是效果图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/recovery.gif" alt="Gif"></p>
<p>静默恢复的效果图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/recovery_silence.gif" alt="silence"></p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><strong>项目地址</strong></h2><p>欢迎star或提建议</p>
<h3 id="还是戳我"><a href="#还是戳我" class="headerlink" title="还是戳我"></a><a href="https://github.com/Sunzxyong/Recovery" target="_blank" rel="external">还是戳我</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;App Crash的恢复，这个想法很早之前就有，目前有些时间就实现了一把，主要是对App运行时发生Crash后，对Activity的堆栈和数据进行恢复，或者重启应用，或者重启并清空缓存，避免因本地的数据类型或格式错误而导致App在读取时一直Crash，Debug模式还包括Crash信息的显示和保存，便于在开发、测试时查看相应CrashInfo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Crash的处理&quot;&gt;&lt;a href=&quot;#Crash的处理&quot; class=&quot;headerlink&quot; title=&quot;Crash的处理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Crash的处理&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对于应用的Crash，一般的做法我们往往都是实现个自定义&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，而这个自定义的CustomUncaughtHandler我们一般都用于捕捉Crash信息进行上报和监控是否发生Crash，还有一个作用就是可以屏蔽系统默认的Crash对话框，也就是拦截Crash后不把系统默认的UncaughtHandler设置进去，而是直接进行KillProcess，这个过程就是屏蔽了系统的默认Crash处理流程，原因是系统的处理其中在AMS的crashApplication()中会执行这么一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Message&lt;/span&gt; msg = &lt;span class=&quot;type&quot;&gt;Message&lt;/span&gt;.obtain();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg.what = &lt;span class=&quot;type&quot;&gt;SHOW_ERROR_MSG&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;HashMap&lt;/span&gt; data = new &lt;span class=&quot;type&quot;&gt;HashMap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.put(&lt;span class=&quot;string&quot;&gt;&quot;result&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.put(&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg.obj = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mUiHandler.sendMessage(msg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发送一个显示Dialog的消息，之后便创建一个AppErrorDialog进行显示。&lt;br&gt;
    
    </summary>
    
      <category term="技术沉淀" scheme="http://zhengxiaoyong.me/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/"/>
    
    
      <category term="ActivityStack恢复" scheme="http://zhengxiaoyong.me/tags/ActivityStack%E6%81%A2%E5%A4%8D/"/>
    
      <category term="Crash恢复" scheme="http://zhengxiaoyong.me/tags/Crash%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android端应用秒开优化体验</title>
    <link href="http://zhengxiaoyong.me/2016/07/18/Android%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C/"/>
    <id>http://zhengxiaoyong.me/2016/07/18/Android端应用秒开优化体验/</id>
    <published>2016-07-18T13:43:26.000Z</published>
    <updated>2016-09-08T10:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近部门内抛出了一个问题，应用启动很慢、卡图标？主要表现在中低端机型中。究其这个问题，由于对性能优化比较感兴趣，借了个低端机和一个中端机来一看究竟，对同一应用分别测了下它在中低端机的启动时间，下面为启动耗时情况：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_one.jpg" alt=""></p>
<p>启动了三次，基本都在4s左右。<br><a id="more"></a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a><strong>原因</strong></h2><p>究其原因，主要因素是任务在界面绘制前过于集中化。</p>
<p>应用启动过程从用户点击launcher图标到看到第一帧这个过程中，主要会经过以下这些过程：</p>
<blockquote>
<p>main()-&gt;Application:attachBaseContext()-&gt;onCreate()-&gt;Activity:onCreate()-&gt;onStart()-&gt;onPostCreate()-&gt;onResume()-&gt;onPostResume()</p>
</blockquote>
<p>而一般我们的初始化任务主要都会集中化在Application:onCreate()方法中，这就使得初始化任务在第一帧绘制之前得完成，这就造成了卡图标、应用启动慢。那么把任务打散呢？分散在LaunchActivity中去分段初始化？还是不行的，因为界面开始绘制是在onResume()方法开始后才开始绘制，所以，得从Activity的创建过程找办法。</p>
<p>main-&gt;Activity创建的这个过程会经过一系列framework层的操作，这些操作都是系统自动执行的，不易进行优化，不过可以在Activity创建这个过程前后来找一些蛛丝马迹，因为Activity的创建都会辗转到ActivityThread:performLaunchActivity()这个方法中，在这个方法中可以知道这么几件事：<br>1、先通过Instrumentation:newActivity()来创建一个Activity实例<br>2、再判断Application实例是否已创建，已创建则直接返回，否则调用<br>Instrumentation:newApplication()来创建Application实例，在这个过程中会依次执行attachBaseContext()和onCreate()方法<br>3、之后Activity:attach()方法会创建一个PhoneWindow对象，它就是界面，它有一个DecorView，调用setContentView()时会给配置DecorView，其中就会设置一个背景：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launc_code.jpg" alt=""></p>
<p>我们的View也是add进DecorView中显示，它作为RootView肯定是最先显示，所以可以给它设置个默认背景<br>4、最后依次调用Activity的onCreate、onStart等方法</p>
<h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a><strong>措施</strong></h2><blockquote>
<p>1、任务分级<br>2、任务并行<br>3、界面预显示</p>
</blockquote>
<p>对于任务集中初始化化、耗时初始化原因导致应用在中低端机启动过慢，而Activity界面绘制的时机导致简单的将任务分给Activity初始化也不起作用，我们必须找一个切入点</p>
<blockquote>
<p>界面的创建和界面的绘制，这两个过程第一个是Application的attachBaseConte和onCreate这两个方法影响的，第二个则是Application创建一直到界面绘制</p>
</blockquote>
<p>所以，可以对任务进行分级的临界点可以这样分：</p>
<blockquote>
<p>1、CoreSDK——Application的创建<br>2、HighPrioritySDK——Activity的创建<br>3、LowPrioritySDK——Activity界面完成绘制<br>4、AsyncSDK——Activity的创建</p>
</blockquote>
<p>如图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/launch.png" alt="launch"></p>
<p>对任务这样分级后，测了一下，应用的启动即使在低端机上，也能秒开:<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_two.jpg" alt=""></p>
<h2 id="分级带来的问题"><a href="#分级带来的问题" class="headerlink" title="分级带来的问题"></a><strong>分级带来的问题</strong></h2><p>正常启动过程那肯定是没问题的，不过有这么几种场景：</p>
<blockquote>
<p>1、App切回后台，内存不足导致Application被回收，从最近任务列表中恢复界面时Application需重新创建<br>2、应用没挂起时，Push推送需从Notification跳入应用内某界面<br>3、应用没挂起时，浏览器外链需跳入应用内某界面</p>
</blockquote>
<p>这些Case可能导致的问题是被跳入的界面使用到了未初始化的SDK，可能导致Crash或者数据异常，所以目标页面启动前必须确保SDK已经初始化，这个过程的原因是没有唤起启动页来初始化SDK，可以通过hook newActivity解决，其中判断Application是否初始化和各个SDK是否初始化，并且判断该次启动不来自系统的Launcher。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InitializeOptimizer.isApplicationCreated()</span><br><span class="line">            &amp;&amp; (!InitializeOptimizer.isHighSDKInitialized()</span><br><span class="line">            || !InitializeOptimizer.isLowSDKInitialized()</span><br><span class="line">            || !InitializeOptimizer.isAsyncSDKInitialized()) &amp;&amp; !InitializeUtil.isAppLauncher(intent)) &#123;</span><br><span class="line">        InitializeOptimizer.setApplicationCreated(<span class="keyword">false</span>);</span><br><span class="line">        intent.addCategory(InitializeUtil.INITIALIZE_CATEGORY);</span><br><span class="line">        <span class="keyword">return</span> (Activity) cl.loadClass(WDInitializeOptimizer.getLaunchClassName()).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    InitializeOptimizer.setApplicationCreated(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">newActivity</span><span class="params">(cl, className, intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近部门内抛出了一个问题，应用启动很慢、卡图标？主要表现在中低端机型中。究其这个问题，由于对性能优化比较感兴趣，借了个低端机和一个中端机来一看究竟，对同一应用分别测了下它在中低端机的启动时间，下面为启动耗时情况：&lt;br&gt;&lt;img src=&quot;http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_one.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;启动了三次，基本都在4s左右。&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="启动优化" scheme="http://zhengxiaoyong.me/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="应用秒开" scheme="http://zhengxiaoyong.me/tags/%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>UrlRouter路由框架的设计</title>
    <link href="http://zhengxiaoyong.me/2016/04/24/UrlRouter%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zhengxiaoyong.me/2016/04/24/UrlRouter路由框架的设计/</id>
    <published>2016-04-24T14:10:36.000Z</published>
    <updated>2016-07-17T08:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UrlRouter的设计"><a href="#UrlRouter的设计" class="headerlink" title="UrlRouter的设计"></a><strong>UrlRouter的设计</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><blockquote>
<p>1、可取代使用startActivity、startActivityForResult跳转的情景，便于协同开发<br>2、通过一串url可任意跳转到指定界面，使用应尽可能简单<br>3、支持各种类型参数传递、界面转场动画<br>4、可获取起跳界面的路径和当前界面路径，以便支持后期埋点等需求<br>5、支持从H5到Native，Native到H5，这是Hybrid开发模式中常用到的需求<br>6、对于push、浏览器外链跳转等可方便配置化，通过一个url来跳转指定界面</p>
</blockquote>
<a id="more"></a>
<h3 id="url格式"><a href="#url格式" class="headerlink" title="url格式"></a><strong>url格式</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">scheme:</span><span class="comment">//host/path</span></span><br></pre></td></tr></table></figure>
<p>scheme：APP内自己定义的，不过这个在H5内跳Native时，需要和前端协商定义好，本地间的跳转可以随自己定义，比如：activity<br>host：这个尽可能按各个Activity的所在模块命名<br>path：各个Activity的功能名</p>
<p>这样一来，比如我跳转到商品详情页的url：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">activity:</span><span class="comment">//product/detail</span></span><br></pre></td></tr></table></figure>
<h3 id="匹配对应的Activity"><a href="#匹配对应的Activity" class="headerlink" title="匹配对应的Activity"></a><strong>匹配对应的Activity</strong></h3><p>刚刚我们定义好了跳转的url规则，那么就需要把这个规则配置给对应的Activity，对于规则的配置，要哪种方式好呢？目前网络上的路由框架大致都是通过注解或维护一套映射表来实现的，内部处理也比较麻烦。因此我们需要一套简单的方式来处理，在Android系统中，我们知道startActivity打开界面的原理是在manifest文件中对Intent进行匹配，如果找到了符合该Intent的Activity则打开，否则将报一个异常：<code>ActivityNotFoundException</code>，我想大部分同学在startActivity时可能没有注意到这个异常，因为以往我们都是通过显示的设置一个<code>Activity.class</code>字节码对象给Intent，这在manifest中自然会找到，如果我们设置一个不存在的包名或者类名，那么在跳转时就会抛出这个异常，所以一个良好的实践是在startActivity时判断该Intent是否已经正确匹配到目标Activity，匹配成功则跳转，失败则自己处理，代码如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isIntentAvailable(Context context, Intent intent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || intent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">    <span class="keyword">List</span>&lt;ResolveInfo&gt; <span class="keyword">list</span> = packageManager.queryIntentActivities(intent,</span><br><span class="line">            PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是通过在manifest中匹配Intent来跳转到指定界面，那么我们可以通过配置Activity的<code>intent-filter</code>规则来匹配，其中Action、Category、Data需要配置，而Action、Category我们可以固定为VIEW和DEFAULT，而Data则才是用来匹配目标Intent的，如下是匹配刚刚商品详情页的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".DetailActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"product"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/detail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假如这个界面也需要支持从H5界面唤起，那么在保持native的跳转功能之外，还可以把前端定义的规则一起加进来，比如前端定义的唤起商品详情页的url为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h5</span>:<span class="comment">//webview/goods_detail</span></span><br></pre></td></tr></table></figure>
<p>当然这是我乱写的，具体的应该定义的更有意义些，这里为了区分就随便定义了下，还有后面肯定是带了参数的，用来传递给打开的界面，为了简洁我给省略了。同时要支持上面这串url，我们只需在指定的Activity配置相应data即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".DetailActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"product"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/detail"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"h5"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"webview"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/goods_detail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面既然配置好了Activity，那么Intent就可以这样设置了：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>();</span><br><span class="line"><span class="type">intent</span>.setAction(<span class="type">Intent</span>.ACTION_VIEW);</span><br><span class="line"><span class="type">intent</span>.addCategory(<span class="type">Intent</span>.CATEGORY_DEFAULT);</span><br><span class="line"><span class="type">intent</span>.setData(Uri.parse(<span class="string">"activity://product/detail"</span>));</span><br></pre></td></tr></table></figure>
<p>不过还没设置目标Activity的信息，所以这就需要通过<code>packageManager.queryIntentActivities()</code>来查询是否正确匹配符合我们url规则的Activity，有则最终我们会得到一个<code>ResolveInfo</code>对象，通过该对象我们可以得到目标Activity的包名、类名等信息，所以再设置给Intent用来start</p>
<h3 id="参数应怎么传递"><a href="#参数应怎么传递" class="headerlink" title="参数应怎么传递"></a><strong>参数应怎么传递</strong></h3><p>对于参数传递，我相信在使用url的情况下，很容易想到在url后面拼接json、KV或者其它自定义的格式，这种方式在处理普通的int、布尔、字符串确实非常方便，不过在传递对象、List集合情况下就不好处理了，所以，基于这个，可以这样定义，在传递字符串、int、布尔类型时直接使用url拼接形式，涉及到其它复杂的数据类型时使用Bundle传递</p>
<h3 id="匹配到多个Activity的处理"><a href="#匹配到多个Activity的处理" class="headerlink" title="匹配到多个Activity的处理"></a><strong>匹配到多个Activity的处理</strong></h3><p>对于匹配过程中，可能存在一个Intent匹配到多个Activity，这时候就需要处理了，因为最终我们只需要打开一个Activity就行了，这时候千万别使用设置intent-filter的优先级来处理，也即：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:priority</span>=<span class="value">"10"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种做法是错误的，因为这个优先级只对有序广播有效，其它情况下获取到的值都为0，所以正确的处理规则如下：<br>由于系统在匹配过程中，当匹配到多个时，会依匹配符合程度按循序排序好返回给我们，不过这时候难免会有第三方包的Activity，需优先匹配本应用包中的Activity，本包中没有再返回系统最匹配的，代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResolveInfo queryActivity(Context context, Intent intent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || intent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">    List&lt;ResolveInfo&gt; resolveInfoList = packageManager.queryIntentActivities(intent,</span><br><span class="line">            PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">    <span class="keyword">if</span> (resolveInfoList == <span class="keyword">null</span> || resolveInfoList.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">size</span> = resolveInfoList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> resolveInfoList.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">String</span> appPackageName = context.getApplicationContext().getPackageName();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        ResolveInfo resolveInfo = resolveInfoList.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">String</span> activityName = resolveInfo.activityInfo.name;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(activityName))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (activityName.startsWith(appPackageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolveInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveInfoList.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外置浏览器跳App内页面的处理"><a href="#外置浏览器跳App内页面的处理" class="headerlink" title="外置浏览器跳App内页面的处理"></a><strong>外置浏览器跳App内页面的处理</strong></h3><p>要支持外置浏览器跳App页面，必须在manifest文件中给相应的Activity的<code>intent-filter</code>添加<code>&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</code> 属性，因为从浏览器中发起的intent的Category就是<code>android.intent.category.BROWSABLE</code>，所以要让App中相应的界面接收到浏览器的intent，则必须设置这个Category<br>下面这个filter就支持浏览器跳App内页面:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.BROWSABLE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="UrlRouter框架跳转方式"><a href="#UrlRouter框架跳转方式" class="headerlink" title="UrlRouter框架跳转方式"></a><strong>UrlRouter框架跳转方式</strong></h3><p>最终我们可以封成使用这样的方式来跳转的一个UrlRouter框架：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.<span class="keyword">from</span>(<span class="keyword">this</span>).jump(<span class="string">"activity://native/login"</span>);</span><br></pre></td></tr></table></figure>
<p>当需设置其它params、requestCode、转场动画时，可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.from(<span class="keyword">this</span>)</span><br><span class="line">        .params(bundle)</span><br><span class="line">        .requestCode(REQUEST_LOGIN)</span><br><span class="line">        .transitionAnim(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        .jump(<span class="string">"activity://native/login"</span>);</span><br></pre></td></tr></table></figure>
<p>对于需要跳转到主页时，应单独实现一个方法，因为主页的intent的action和category比较特殊，所以主页Activity应这样配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span></span><br><span class="line">    <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme.NoActionBar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">            <span class="attribute">android:host</span>=<span class="value">"native"</span></span><br><span class="line">            <span class="attribute">android:path</span>=<span class="value">"/main"</span></span><br><span class="line">            <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>跳转代码为：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.<span class="keyword">from</span>(<span class="keyword">this</span>).jumpToMain(<span class="string">"activity://native/main"</span>);</span><br></pre></td></tr></table></figure>
<p>这样的方式非常简洁，而且维护也非常方便，因为统一都是在manifest文件中配置，最重要的是没有其它UrlRouter框架那么复杂繁重，最终封的框架只有三个类，简洁精悍！！！</p>
<h2 id="UrlRouter地址"><a href="#UrlRouter地址" class="headerlink" title="UrlRouter地址"></a><strong>UrlRouter地址</strong></h2><p>UrlRouter：<a href="https://github.com/Sunzxyong/UrlRouter" target="_blank" rel="external">github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UrlRouter的设计&quot;&gt;&lt;a href=&quot;#UrlRouter的设计&quot; class=&quot;headerlink&quot; title=&quot;UrlRouter的设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;UrlRouter的设计&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、可取代使用startActivity、startActivityForResult跳转的情景，便于协同开发&lt;br&gt;2、通过一串url可任意跳转到指定界面，使用应尽可能简单&lt;br&gt;3、支持各种类型参数传递、界面转场动画&lt;br&gt;4、可获取起跳界面的路径和当前界面路径，以便支持后期埋点等需求&lt;br&gt;5、支持从H5到Native，Native到H5，这是Hybrid开发模式中常用到的需求&lt;br&gt;6、对于push、浏览器外链跳转等可方便配置化，通过一个url来跳转指定界面&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术沉淀" scheme="http://zhengxiaoyong.me/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/"/>
    
    
      <category term="UrlRouter" scheme="http://zhengxiaoyong.me/tags/UrlRouter/"/>
    
      <category term="路由框架" scheme="http://zhengxiaoyong.me/tags/%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Native与H5交互的那些事</title>
    <link href="http://zhengxiaoyong.me/2016/04/20/Native%E4%B8%8EH5%E4%BA%A4%E4%BA%92%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://zhengxiaoyong.me/2016/04/20/Native与H5交互的那些事/</id>
    <published>2016-04-20T04:55:28.000Z</published>
    <updated>2016-05-18T05:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span><br><span class="line">            alert(obj);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line">                 .getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加<code>@JavascriptInterface</code>注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的<code>prompt</code>方法进行解决，只不过<code>需要和前端协商好一套公共的协议</code>，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互<br><a id="more"></a></p>
<h2 id="Native与H5怎样安全的进行交互？"><a href="#Native与H5怎样安全的进行交互？" class="headerlink" title="Native与H5怎样安全的进行交互？"></a><strong>Native与H5怎样安全的进行交互？</strong></h2><p>要使得H5内的Js与Native之间安全的相互进行调用，我们除了可以通过添加<code>@JavascriptInterface</code>注解来解决（&gt;=4.2），还有通过<code>prompt</code>的方式，不过如果使用官方的方式，这就需要对4.2以下做兼容了，这样使得我们一个app中有两套Js与Native交互的方式，这样极其不好维护，我们应该只需要一套Js与Native交互的方式，所以，我们借助Js中的<code>prompt</code>方法来实现<code>一套安全的Js与Native交互的JsBridge框架</code></p>
<h3 id="Js与Native代码相互调用"><a href="#Js与Native代码相互调用" class="headerlink" title="Js与Native代码相互调用"></a><strong>Js与Native代码相互调用</strong></h3><p><strong>Native Invoke Js:</strong><br>我们知道如果Native需要调用Js中的方法，只需要使用<code>WebView:loadUrl();</code>方法即可直接调用指定Js代码，如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView<span class="class">.loadUrl</span>("javascript<span class="value">:<span class="function">setUserName</span>(<span class="string">'zhengxiaoyong'</span>);</span>");</span><br></pre></td></tr></table></figure>
<p>这样就直接调用了Js中的<code>setUserName</code>方法并把<code>zhengxiaoyong</code>这个名字传到这个方法中去了，接下来就是Js自己处理了</p>
<p><strong>Js Invoke Native:</strong><br>而如果Js要调用Native中的Java方法呢？这就需要我们自己实现了，因为我们不采取<code>JavascriptInterface</code>的方式，而采取prompt方式<br>对WebView熟悉的同学们应该都知道Js中对应的<code>window.alert()</code>、<code>window.confirm()</code>、<code>window.prompt()</code>这三个方法的调用在<code>WebChromeClient</code>中都有对应的回调方法，分别为：<br><code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt()</code>，对于它们传入的<code>message</code>，都可以在相应的回调方法中接收到，所以，对于Js调Native方法，我们可以借助这个信道，和前端协定好一段特定规则的<code>message</code>，这个规则中应至少包含这些信息：</p>
<blockquote>
<p>所调用Native方法所在类的类名<br>所调用Native的方法名<br>Js调用Native方法所传入的参数</p>
</blockquote>
<p>所以基于这些信息，很容易想到使用http协议的格式来协定规则，如下格式：</p>
<blockquote>
<p><strong>scheme://host:port/path?query</strong><br>对应的我们协定<code>prompt</code>传入<code>message</code>的格式为:<br><strong>jsbridge://class:port/method?params</strong></p>
</blockquote>
<p>这样以来，前端和app端协商好后，以后前端需要通过Js调用Native方法来获取一些信息或功能，就只需要按照协议的格式把需要调用的类名、方法名、参数放入对应得位置即可，而我们会在<code>onJsPrompt</code>方法中接受到，所以我们根据与前端协定好的协议来进行解析，我们可以用一个<code>Uri</code>来包装这段协议，然后通过<code>Uri:getHost、getPath、getQuery</code>方法获取对应的类名，方法名，参数数据，最后通过反射来调用指定类中指定的方法</p>
<p>而此时会有人问？<code>port</code>是用来干嘛的？params格式是KV还是什么格式？<br>当然，既然和前端协定好了协议的格式了，那么params肯定也是需要协定好的，可以用KV格式，也可以用一串Json字符串表示，为了解析方便，还是建议使用<code>Json格式</code><br>而<code>port</code>是用来干嘛的呢？</p>
<blockquote>
<p><code>port</code>我们并不会直接操作它，它是由Js代码自动生成的，port的作用是为了标识Js中的回调<code>function</code>,当Js调用Native方法时，我们会得到本次调用的<code>port</code>号，我们需要在Native方法执行完毕后再把该<code>port</code>、执行的后结果、是否调用成功、调用失败的msg等信息通过调用Js的<code>onComplete</code>方法传入，这时候Js凭什么知道你本次返回的信息是哪次调用的结果呢？就是通过<code>port</code>号，因为在Js调用Native方法时我们会把自动生成的<code>port</code>号和此次回调的<code>function</code>绑定在一起，这样以来Native方法返回结果时把<code>port</code>也带过来，就知道是哪次回调该用哪个<code>function</code>方法来处理</p>
</blockquote>
<p>自动生成<code>port</code>和绑定<code>function回调</code>的Js代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">generatePort: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Math</span>.floor(<span class="type">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">50</span>)) + '' + increase++;</span><br><span class="line">&#125;,</span><br><span class="line">//调用<span class="type">Native</span>方法</span><br><span class="line">callMethod: function (clazz, <span class="keyword">method</span>, param, callback) &#123;</span><br><span class="line">    <span class="keyword">var</span> port = <span class="type">PrivateMethod</span>.generatePort();</span><br><span class="line">    <span class="keyword">if</span> (typeof callback !== 'function') &#123;</span><br><span class="line">        callback = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定对应port的function回调函数</span><br><span class="line">    <span class="type">PrivateMethod</span>.registerCallback(port, callback);</span><br><span class="line">    <span class="type">PrivateMethod</span>.callNativeMethod(clazz, port, <span class="keyword">method</span>, param);</span><br><span class="line">&#125;,</span><br><span class="line">onComplete: function (port, <span class="literal">result</span>) &#123;</span><br><span class="line">    //把<span class="type">Native</span>返回的<span class="type">Json</span>字符串转为<span class="type">JSONObject</span></span><br><span class="line">    <span class="keyword">var</span> resultJson = <span class="type">PrivateMethod</span>.str2Json(<span class="literal">result</span>);</span><br><span class="line">    //获取对应port的function回调函数</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="type">PrivateMethod</span>.getCallback(port).callback;</span><br><span class="line">    <span class="type">PrivateMethod</span>.unRegisterCallback(port);</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        //执行回调</span><br><span class="line">        callback &amp;&amp; callback(resultJson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Js代码上已经注释的很清楚了，就不多解释了。</p>
<p>经过上面介绍，那么在Native方法执行完成后，当然就需要把结果返回给Js了，那么结果的格式又是什么呢？返回给Js方法又是什么呢？<br>没错，还是需要和前端进行协定，建议数据的返回格式为Json字符串，基本格式为：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resultData = &#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">        code: <span class="number">0</span>,<span class="comment">//0:成功，1:失败</span></span><br><span class="line">        msg: <span class="string">'请求超时'</span><span class="comment">//失败时候的提示，成功可为空</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">data</span>: &#123;&#125;<span class="comment">//数据，无数据可以为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中定义了一个<code>status</code>，这样的好处是无论在Native方法调用成功与否、Native方法是否有返回值，Js中都可以收到返回的信息，而这个Json字符串至少都会包含一个<code>status</code>Json对象来描述Native方法调用的状况</p>
<p>而返回给Js的方法自然是上面的<code>onComplete</code>方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">javascript</span><span class="pseudo">:RainbowBridge</span><span class="class">.onComplete</span>(<span class="tag">port</span>,<span class="tag">resultData</span>);</span><br></pre></td></tr></table></figure>
<p>ps:RainbowBridge是我的JsBridge框架的名字</p>
<hr>
<p>至此Js调用Native的流程就分析完成了，一切都看起来那么美妙，因为，我们自己实现一套<code>Js Invoke Native</code>的主要目的是让Js调用Native更加安全，同时也只维护一套<code>JsBridge</code>框架更加方便，那么这个安全性表现在哪里了？<br>我们知道之前原生的方式漏洞就是恶意Js代码可能会调用Native中的其它方法，那么答案出来了，如果需要让<code>Js Invoke Native</code>保证安全性，只需要限制我们通过反射可调用的方法，所以，在JsBridge框架中，我们需要对Js能调用的Native方法给予一定的规则，只有符合这些规则Js才能调用，而我的规则是：</p>
<blockquote>
<p><strong>1、</strong>Native方法包含public static void 这些修饰符（当然还可能有其它的，如：synchronized）<br><strong>2、</strong>Native方法的参数数量和类型只能有这三个：WebView、JSONObject、JsCallback。为什么要传入这三个参数呢？<br><strong>2.1、</strong>第一个参数是为了提供一个WebView对象，以便获取对应Context和执行WebView的一些方法<br><strong>2.2、</strong>第二个参数就是Js中传入过来的参数，这个肯定要的<br><strong>2.3、</strong>第三个参数就是当Native方法执行完毕后，把执行后的结果回调给Js对应的方法中</p>
</blockquote>
<p>所以符合Js调用的Native方法格式为：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> ***(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">	//get some info ...</span><br><span class="line">	<span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断Js调用的方法是否符合该格式的代码为，符合则存入一个Map中供Js调用：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> putMethod(<span class="type">Class</span>&lt;?&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz == null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ArrayMap</span>&lt;<span class="type">String</span>, <span class="type">Method</span>&gt; arrayMap = new <span class="type">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span>;</span><br><span class="line">    <span class="type">Method</span>[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="type">int</span> length = methods.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">method</span> = methods[i];</span><br><span class="line">        <span class="type">int</span> methodModifiers = <span class="keyword">method</span>.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> ((methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">PUBLIC</span>) != <span class="number">0</span> &amp;&amp; (methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">STATIC</span>) != <span class="number">0</span> &amp;&amp; <span class="keyword">method</span>.getReturnType() == <span class="type">void</span>.class) &#123;</span><br><span class="line">            <span class="type">Class</span>&lt;?&gt;[] parameterTypes = <span class="keyword">method</span>.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes != null &amp;&amp; parameterTypes.length == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">WebView</span>.class == parameterTypes[<span class="number">0</span>] &amp;&amp; <span class="type">JSONObject</span>.class == parameterTypes[<span class="number">1</span>] &amp;&amp; <span class="type">JsCallback</span>.class == parameterTypes[<span class="number">2</span>]) &#123;</span><br><span class="line">                    arrayMap.put(<span class="keyword">method</span>.getName(), <span class="keyword">method</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mArrayMap.put(clazz.getSimpleName(), arrayMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于有返回值的方法，并不需要设置它的返回值，因为方法的结果最后我们是通过<code>JsCallback.invokeJsCallback</code>来进行对Js层的回调，比如我贴一个符合该格式的Native方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> getOsSdk(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="literal">result</span> = new <span class="type">JSONObject</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="literal">result</span>.put(<span class="string">"os_sdk"</span>, <span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span>);</span><br><span class="line">    &#125; catch (<span class="type">JSONException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Js调Native代码执行耗时操作情况处理"><a href="#Js调Native代码执行耗时操作情况处理" class="headerlink" title="Js调Native代码执行耗时操作情况处理"></a><strong>Js调Native代码执行耗时操作情况处理</strong></h4><p>一般情况下，比如我们通过Js调用Native方法来获取AppName、OsSDK版本、IMSI号、用户信息等都不会有问题，但是，假如该Native方法需要执行一些耗时操作，如：IO、sp、Bitmap Decode、SQLite等，这时为了保护UI的流畅性，我们需要让这些操作执行在异步线程中，待执行完毕再把结果回调给Js，而我们可以提供一个线程池来专门处理这些耗时操作，如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> doAsync(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, final <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">AsyncTaskExecutor</span>.runOnAsyncThread(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">        @<span class="type">Override</span></span><br><span class="line">        public <span class="type">void</span> run() &#123;</span><br><span class="line">            //<span class="type">IO</span>、sp、<span class="type">Bitmap</span> <span class="type">Decode</span>、<span class="type">SQLite</span></span><br><span class="line">            <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>【注】：对于WebView，它的方法的调用只能在主线程中调用，当设计到WebView的方法调用时，切记不可以放在异步线程中调用，否则就GG了.</strong></p>
<h4 id="Js调Native流程图"><a href="#Js调Native流程图" class="headerlink" title="Js调Native流程图"></a><strong>Js调Native流程图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/jsbridge.png" alt="JsInvokeNative"></p>
<h4 id="JsBridge效果图"><a href="#JsBridge效果图" class="headerlink" title="JsBridge效果图"></a><strong>JsBridge效果图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/js.gif" alt="RainbowBridge"><br>RainbowBridge:<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">github地址</a></p>
<h3 id="白名单Check"><a href="#白名单Check" class="headerlink" title="白名单Check"></a><strong>白名单Check</strong></h3><p>上面我们介绍了JsBridge的基本原理，实现了Js与Native相互调用，而且还避免了恶意Js代码调用Native方法的安全问题，通过这样我们保证了Js调用Native方法的安全性，即Js不能随意调用任意Native方法，不过，对于WebView容器来说，它并不关心所加载的url是Js代码还是网页地址，它所做的工作就是执行我们传入的url，而WebView加载url的方式有两种：get和post，方式如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl<span class="comment">(url)</span>;<span class="comment">//get</span></span><br><span class="line">mWebView.postUrl<span class="comment">(url,data)</span>;<span class="comment">//post</span></span><br></pre></td></tr></table></figure>
<p>对于这两种方式，也有不同的应用点，一般get方式用于查，也就是传入的数据不那么重要，比如：商品列表页、商品详情页等，这些传入的数据只是一些商品类的信息。而post方式一般用于改，post传入的数据往往是比较私密的，比如：订单界面、购物车界面等，这些界面只有在把用户的信息post给服务器后，服务器才能正确的返回相应的信息显示在界面上。所以，对于post方式涉及到用户的私密信息，我们总不能给一个url就把私密数据往这个url里面发吧，当然不可能的，这涉及到安全问题，那么就需要一个白名单机制来检查url是否是我们自己的，是我们自己的那么即可以post数据，不是我们自己的那就不post数据，而白名单的定义通常可以以我们自己的域名来判断，搞一个正则表达式，所以我们可以重写WebView的<code>postUrl</code>方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就对不是我们自己的url进行了拦截，不把数据发送到不是我们自己的服务器中</p>
<p>至此，白名单的Check还没有完成，因为这只是对WebView加载Url时候做的检查，而在WebView内各中链接的跳转、其中有些url还可能被运营商劫持注入了广告，这就有可能在WebView容器内的跳转到某些界面后，该界面的url并不是我们自己的，但是它里面有Js代码调用Native方法来获取一些数据，虽然说Js并不能随便调我们的Native方法，但是有些我们指定可以被调用的Native方法可能有一些获取设备信息、读取文件、获取用户信息等方法，所以，我们也应该在Js调用Native方法时做一层白名单Check，这样才能保证我们的信息安全</p>
<p>所以，白名单检测需要在两个地方进行检测：</p>
<blockquote>
<p>1、WebView:postUrl()前检测url的合法性<br>2、Js调用Native方法前检测当前界面url的合法性</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * <span class="doctag">@param</span> webView WebView</span><br><span class="line"> * <span class="doctag">@param</span> message rainbow://class:port/method?params</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(WebView webView, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span> || TextUtils.isEmpty(message))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(webView.getUrl())) &#123;</span><br><span class="line">        parseMessage(message);</span><br><span class="line">        invokeNativeMethod(webView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除默认内置接口"><a href="#移除默认内置接口" class="headerlink" title="移除默认内置接口"></a><strong>移除默认内置接口</strong></h3><p>WebView内置默认也注入了一些接口，如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除默认内置接口,防止远程代码执行漏洞攻击</span></span><br><span class="line"><span class="keyword">if</span> (Build.<span class="keyword">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"searchBoxJavaBridge_"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibility"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibilityTraversal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些接口虽然不会影响用prompt方式实现的Js与Native交互，但是在使用addJavascriptInterface方式时，有可能有安全问题，最好移除</p>
<h2 id="WebView相关"><a href="#WebView相关" class="headerlink" title="WebView相关"></a><strong>WebView相关</strong></h2><h3 id="WebView的配置"><a href="#WebView的配置" class="headerlink" title="WebView的配置"></a><strong>WebView的配置</strong></h3><p>下面给出WebView的通用配置：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line">webSettings.setSupportZoom(<span class="literal">false</span>);</span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">false</span>);</span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDatabaseEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setGeolocationEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCachePath(getApplicationContext().getCacheDir().getPath());</span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">"UTF-8"</span>);</span><br><span class="line">//屏幕自适应</span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>);</span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    webSettings.setDisplayZoomControls(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mWebView.setScrollBarStyle(WDWebView.SCROLLBARS_INSIDE_OVERLAY);</span><br><span class="line">mWebView.setHorizontalScrollBarEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setHorizontalFadingEdgeEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setVerticalFadingEdgeEnabled(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>其中有一项配置，是在4.4以上版本时设置网页内图片可以自动加载，而4.4以下版本则不可自动加载，原因是4.4WebView内核的改变，使得WebView的性能更优，所以在4.4以下版本不让图片自动加载，而是先让WebView加载网页的其它静态资源：js、css、文本等等，待网页把这些静态资源加载完成后，在<code>onPageFinished</code>方法中再把图片自动加载打开让网页加载图片：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">    <span class="keyword">if</span> (!mWebView.getSettings().getLoadsImagesAutomatically()) &#123;</span><br><span class="line">        mWebView.getSettings().setLoadsImagesAutomatically(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebView的独立进程"><a href="#WebView的独立进程" class="headerlink" title="WebView的独立进程"></a><strong>WebView的独立进程</strong></h3><p>通常来说，WebView的使用会带来诸多问题，内存泄露就是最常见的问题，为了避免WebView内存泄露，目前最流行的有两种做法：</p>
<blockquote>
<p>1、独立进程，简单暴力，不过可能涉及到进程间通信<br>2、动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉</p>
</blockquote>
<p>个人推荐独立进程，好处主要有两点，一是在WebViewActivity使用完毕后直接干掉该进程，防止了内存泄露，二是为我们的app主进程减少了额外的内存占用量</p>
<p>使用独立进程还需注意一点，这个进程中在有多个WebViewActivity，不能在Activity销毁时就干掉进程，不然其它Activity也会蹦了，此时应该在该进程创建一个Activity的维护集合，集合为空时即可干掉进程</p>
<p>关于WebView的销毁，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">destroyWebView</span><span class="params">(WebView webView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    webView.stopLoading();</span><br><span class="line">    ViewParent viewParent = webView.getParent();</span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup)</span><br><span class="line">        ((ViewGroup) viewParent).removeView(webView);</span><br><span class="line">    webView.removeAllViews();</span><br><span class="line">    webView.destroy();</span><br><span class="line">    webView = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebView的兼容性"><a href="#WebView的兼容性" class="headerlink" title="WebView的兼容性"></a><strong>WebView的兼容性</strong></h3><h4 id="不同版本硬件加速的问题"><a href="#不同版本硬件加速的问题" class="headerlink" title="不同版本硬件加速的问题"></a><strong>不同版本硬件加速的问题</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 &amp;&amp; shouldOpenHardware()) &#123;</span><br><span class="line">    mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOpenHardware</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(Build.BRAND))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同设备点击WebView输入框键盘的不弹起"><a href="#不同设备点击WebView输入框键盘的不弹起" class="headerlink" title="不同设备点击WebView输入框键盘的不弹起"></a><strong>不同设备点击WebView输入框键盘的不弹起</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWebView != <span class="keyword">null</span>)</span><br><span class="line">                mWebView.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"><a href="#三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况" class="headerlink" title="三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"></a><strong>三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况</strong></h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">brand </span>= <span class="keyword">android.os.Build.BRAND;</span><br><span class="line"></span><span class="label">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(<span class="keyword">brand) </span>&amp;&amp; <span class="keyword">Build.VERSION.SDK_INT </span>&gt;= <span class="keyword">Build.VERSION_CODES.LOLLIPOP) </span>&#123;</span><br><span class="line">    getWindow().setFlags(</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同版本shouldOverrideUrlLoading的回调时机"><a href="#不同版本shouldOverrideUrlLoading的回调时机" class="headerlink" title="不同版本shouldOverrideUrlLoading的回调时机"></a><strong>不同版本shouldOverrideUrlLoading的回调时机</strong></h4><p>对于<code>shouldOverrideUrlLoading</code>的加载时机，有些同学经常与<code>onProgressChanged</code>这个方法的加载时机混淆，这两个方法有两点不同：</p>
<blockquote>
<p>1、<code>shouldOverrideUrlLoading</code>只会走Get方式的请求，Post方式的请求将不会回调这个方法，而<code>onProgressChanged</code>对Get和Post都会走<br>2、<code>shouldOverrideUrlLoading</code>都知道在WebView内部点击链接（Get）会触发，它在Get请求打开界面时也会触发，<code>shouldOverrideUrlLoading</code>还有一点特殊，就是在按返回键返回到上一个页面时时不会触发的，而<code>onProgressChanged</code>在只要界面更新了都会触发</p>
</blockquote>
<p>对于<code>shouldOverrideUrlLoading</code>的返回值，返回true为剥夺WebView对该此请求的控制权，交给应用自己处理，所以WebView也不会加载该url了，返回false为WebView自己处理</p>
<p>对于<code>shouldOverrideUrlLoading</code>的调用时机，也会有不同，在3.0以上是会正常调用的，而在3.0以下，并不是每次都会调用，可以在<code>onPageStarted</code>方法中做处理，也没必要了，现在应该都适配4.0以上了</p>
<h4 id="页面重定向导致WebView-goBack-无效的处理"><a href="#页面重定向导致WebView-goBack-无效的处理" class="headerlink" title="页面重定向导致WebView:goBack()无效的处理"></a><strong>页面重定向导致WebView:goBack()无效的处理</strong></h4><p>像一些界面有重定向，比如：淘宝等，需要按多次（&gt;1）才能正常返回，一般都是二次，所以可以把那些具有重定向的界面存入一个集合中，在拦截返回事件中这样处理：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> onBackPressed() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    WebBackForwardList backForwardList = mWebView.copyBackForwardList();</span><br><span class="line">    <span class="keyword">if</span> (backForwardList != <span class="keyword">null</span> &amp;&amp; backForwardList.getSize() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> currentIndex = backForwardList.getCurrentIndex();</span><br><span class="line">        WebHistoryItem historyItem = backForwardList.getItemAtIndex(currentIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (historyItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">String</span> backPageUrl = historyItem.getUrl();</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(backPageUrl))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">size</span> = REDIRECT_URL.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (backPageUrl.contains(REDIRECT_URL.<span class="built_in">get</span>(i)))</span><br><span class="line">                    mWebView.goBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mWebView.canGoBack()) &#123;</span><br><span class="line">        mWebView.goBack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里处理是在按返回键时，如果上一个界面是重定向界面，则直接调用goBack，或者也可以finish当前Activity</p>
<h4 id="WebView无法加载不信任网页SSL错误的处理"><a href="#WebView无法加载不信任网页SSL错误的处理" class="headerlink" title="WebView无法加载不信任网页SSL错误的处理"></a><strong>WebView无法加载不信任网页SSL错误的处理</strong></h4><p>有时我们的WebView会加载一些不信任的网页，这时候默认的处理是WebView停止加载了，而那些不信任的网页都不是由CA机构信任的，这时候你可以选择继续加载或者让手机内的浏览器来加载：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, <span class="keyword">final</span> SslErrorHandler <span class="keyword">handler</span>, SslError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续加载</span></span><br><span class="line">    <span class="keyword">handler</span>.<span class="keyword">proceed</span>();</span><br><span class="line">    <span class="comment">//或者其它处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义WebView加载出错界面"><a href="#自定义WebView加载出错界面" class="headerlink" title="自定义WebView加载出错界面"></a><strong>自定义WebView加载出错界面</strong></h4><p>出错的界面的显示，可以在这个方法中控制：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以重新加载一段Html专门用来显示错误界面，或者用布局显示一个出错的View，这时候需要把出错的WebView内容清除，可以使用：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">    view.loadDataWithBaseURL(<span class="keyword">null</span>,<span class="string">""</span>,<span class="string">"text/html"</span>,<span class="string">"UTF-8"</span>,<span class="keyword">null</span>);</span><br><span class="line">    errorView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取位置权限的处理"><a href="#获取位置权限的处理" class="headerlink" title="获取位置权限的处理"></a><strong>获取位置权限的处理</strong></h4><p>如果在WebView中有获取地理位置的请求，那么可以直接在代码中默认处理了，没必要弹出一个框框让用户每次都确认：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(String origin, GeolocationPermissions.Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onGeolocationPermissionsShowPrompt(origin, callback);</span><br><span class="line">    callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打造一个通用的WebViewActivity界面"><a href="#打造一个通用的WebViewActivity界面" class="headerlink" title="打造一个通用的WebViewActivity界面"></a><strong>打造一个通用的WebViewActivity界面</strong></h3><p>一个通用的WebViewActivity当然是样式和WebView内部处理的策略都统一样，这里只对样式进行说明，因为WebView内部的处理各个公司都不一样，但应该都需要包含这么几点吧：</p>
<blockquote>
<p>1、白名单检测<br>2、Url的跳转<br>3、出错的处理<br>4、…</p>
</blockquote>
<p>一个WebViewActivity界面，最主要的就是Toolbar标题栏的设计了，因为不同的app的WebViewActivity界面Toolbar上有不同的icon和操作，比如：分享按钮、刷新按钮、更多按钮，都不一样，既然需要通用，即可让调用者传入某个参数来动态改变这些东西吧，比如传一个ToolbarStyle来标识此WebViewActivity的风格是什么样的，背景色、字体颜色、图标等，包括点击时的动画效果，作为通用的界面，必须是让调用者简单操作，不可能调用时传入一个图标id还是一个Drawable，所以，主要需要用到tint，来对字体、图标的颜色动态改变，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorStateList <span class="title">createColorStateList</span><span class="params">(<span class="keyword">int</span> normal, <span class="keyword">int</span> pressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;normal, pressed&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-android.R.attr.state_pressed&#125;;</span><br><span class="line">    states[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_pressed&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorStateList(states, colors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">tintDrawable</span><span class="params">(Drawable drawable, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    final Drawable tintDrawable = DrawableCompat.wrap(drawable.mutate());</span><br><span class="line">    ColorStateList colorStateList = ColorStateList.valueOf(color);</span><br><span class="line">    DrawableCompat.setTintMode(tintDrawable, PorterDuff.Mode.SRC_IN);</span><br><span class="line">    DrawableCompat.setTintList(tintDrawable, colorStateList);</span><br><span class="line">    <span class="keyword">return</span> tintDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H5与Native界面互相唤起"><a href="#H5与Native界面互相唤起" class="headerlink" title="H5与Native界面互相唤起"></a><strong>H5与Native界面互相唤起</strong></h2><p>对于H5界面，有些操作往往是需要唤起Native界面的，比如：H5中的登录按钮，点击后往往唤起Native的登录界面来进行登录，而不是直接在H5登录，这样一个app就只需要一套登录了，而我们所做的便是拦截登录按钮的url：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    parserURL(url); <span class="comment">//解析url,如果符合跳转native界面的url规则，则跳转native界面</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">shouldOverrideUrlLoading</span><span class="params">(view, url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规则我们可以在Native的Activity的<code>intent-filter</code>中的<code>data</code>来定义，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".LoginActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">            <span class="attribute">android:host</span>=<span class="value">"native"</span></span><br><span class="line">            <span class="attribute">android:path</span>=<span class="value">"/login"</span></span><br><span class="line">            <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解析url过程是判断scheme、host、path的是否有完全与之匹配的，有则唤起</p>
<p>而Native唤H5，其实也是一个url的解析过程，只不过需要配置WebViewActivity的<code>intent-filter</code>的<code>data</code>，WebViewActivity的scheme配置为http和https</p>
<h3 id="startActivity-VS-UrlRouter"><a href="#startActivity-VS-UrlRouter" class="headerlink" title="startActivity VS UrlRouter"></a><strong>startActivity VS UrlRouter</strong></h3><p>上面说到了H5与Native互相调起，其实这个可以在app内做成一套界面跳转的方式，摒弃startActivity，为什么原生的跳转方式不佳？</p>
<blockquote>
<p>1、因为原生的跳转需要确定该Activity是已经存在的，否则编译将报错，这样带来的问题是不利于协同开发，如：A、B同学分别正在开发项目的两个不同的模块，此时B刚好需要跳A同学的某一个界面，如商品列表页跳商品详情页，这时候B就必须写个TODO，待B完成该模块后再写了。而通过url跳转，只需要传入一串url即可<br>2、原生的跳转Activity与目标Activity是耦合的，跳转Activity完全依赖于目标Activity<br>3、原生的跳转方式不利于管理所传递来的参数，获取参数时需要在跳转Activity的地方确定传递了几个参数、什么类型的参数，这样以来跳转的方式多了，就比较混乱了。当然一个原生跳转良好的设计是在目的Activity实现一个静态的start方法，其它界面要跳直接调用即可<br>4、最后一个就是在有参数传递的情况下，每次跳转都要写好多代码啊</p>
</blockquote>
<p>而UrlRouter框架的实现原理，一种实现是可以维护一套Activity与url的映射表，这种方式还是没有摆脱不利于协同开发这个毛病，另外一种是通过一串指定规则的url与manifest中配置的data匹配，具体跳转则是通过<code>intent.setData()</code>来设置跳转的url，这种方式比较好，不过需要处理下匹配到多个Activity时优先选择的问题</p>
<p><strong>JsBridge地址</strong>：<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">RainbowBridge</a></p>
<hr>
<p><strong>—转载请注明出处</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cmdArgs&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;getClass&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[obj]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[obj].getClass().forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Runtime&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 .getMethod(&lt;span class=&quot;string&quot;&gt;&quot;getRuntime&quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;).invoke(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;).exec(cmdArgs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加&lt;code&gt;@JavascriptInterface&lt;/code&gt;注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的&lt;code&gt;prompt&lt;/code&gt;方法进行解决，只不过&lt;code&gt;需要和前端协商好一套公共的协议&lt;/code&gt;，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互&lt;br&gt;
    
    </summary>
    
      <category term="技术沉淀" scheme="http://zhengxiaoyong.me/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/"/>
    
    
      <category term="JsBridge" scheme="http://zhengxiaoyong.me/tags/JsBridge/"/>
    
      <category term="WebView" scheme="http://zhengxiaoyong.me/tags/WebView/"/>
    
      <category term="WebView安全" scheme="http://zhengxiaoyong.me/tags/WebView%E5%AE%89%E5%85%A8/"/>
    
      <category term="兼容性" scheme="http://zhengxiaoyong.me/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之Bitmap的内存优化</title>
    <link href="http://zhengxiaoyong.me/2016/02/23/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BBitmap%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://zhengxiaoyong.me/2016/02/23/Android性能优化之Bitmap的内存优化/</id>
    <published>2016-02-23T02:53:30.000Z</published>
    <updated>2016-05-06T06:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BitmapFactory解析Bitmap的原理"><a href="#BitmapFactory解析Bitmap的原理" class="headerlink" title="BitmapFactory解析Bitmap的原理"></a><strong>BitmapFactory解析Bitmap的原理</strong></h2><p>BitmapFactory提供的解析Bitmap的静态工厂方法有以下五种：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bitmap <span class="function"><span class="title">decodeFile</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeResource</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeByteArray</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeStream</span><span class="params">(...)</span></span></span><br><span class="line">Bitmap <span class="function"><span class="title">decodeFileDescriptor</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
<p>其中常用的三个：decodeFile、decodeResource、decodeStream。<br>decodeFile和decodeResource其实最终都是调用decodeStream方法来解析Bitmap，decodeStream的内部则是调用两个native方法解析Bitmap的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">nativeDecodeAsset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">nativeDecodeStream</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这两个native方法只是对应decodeFile和decodeResource、decodeStream来解析的，像decodeByteArray、decodeFileDescriptor也有专门的native方法负责解析Bitmap。<br><a id="more"></a><br>接下来就是看看这两个方法在解析Bitmap时究竟有什么区别decodeFile、decodeResource，查看后发现它们调用路径如下：</p>
<blockquote>
<p>decodeFile-&gt;decodeStream<br>decodeResource-&gt;decodeResourceStream-&gt;decodeStream</p>
</blockquote>
<p>decodeResource在解析时多调用了一个<strong>decodeResourceStream</strong>方法，而这个decodeResourceStream方法代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span>(<span class="params">Resources res, TypedValue <span class="keyword">value</span>,</span><br><span class="line">        InputStream <span class="keyword">is</span>, Rect pad, Options opts</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="keyword">null</span>) &#123;</span><br><span class="line">        opts = <span class="keyword">new</span> Options();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        final <span class="keyword">int</span> density = <span class="keyword">value</span>.density;</span><br><span class="line">        <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">density != TypedValue.DENSITY_NONE</span>) </span>&#123;</span><br><span class="line">            opts.inDensity = density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>) &#123;</span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeStream(<span class="keyword">is</span>, pad, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它主要是对Options进行处理了，在得到<strong>opts.inDensity</strong>属性的前提下，如果我们没有对该属性设定值，那么将opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;赋定这个默认的Density值，这个默认值为160，为标准的dpi比例，即在Density=160的设备上1dp=1px，这个方法中还有这么一行</p>
<blockquote>
<p>opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</p>
</blockquote>
<p>对<strong>opts.inTargetDensity</strong>进行了赋值，该值为当前设备的densityDpi值，所以说在decodeResourceStream方法中主要做了两件事：</p>
<blockquote>
<p>1、对opts.inDensity赋值，没有则赋默认值160<br>2、对opts.inTargetDensity赋值，没有则赋当前设备的densityDpi值</p>
</blockquote>
<p>之后重点来了，之后参数将传入decodeStream方法，该方法中在调用native方法进行解析Bitmap后会调用这个方法<strong>setDensityFromOptions(bm, opts);</strong>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setDensityFromOptions</span><span class="params">(Bitmap outputBitmap, Options opts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputBitmap == <span class="keyword">null</span> || opts == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> density = opts.inDensity;</span><br><span class="line">    <span class="keyword">if</span> (density != <span class="number">0</span>) &#123;</span><br><span class="line">        outputBitmap.setDensity(density);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> targetDensity = opts.inTargetDensity;</span><br><span class="line">        <span class="keyword">if</span> (targetDensity == <span class="number">0</span> || density == targetDensity || density == opts.inScreenDensity) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] np = outputBitmap.getNinePatchChunk();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isNinePatch = np != <span class="keyword">null</span> &amp;&amp; NinePatch.isNinePatchChunk(np);</span><br><span class="line">        <span class="keyword">if</span> (opts.inScaled || isNinePatch) &#123;</span><br><span class="line">            outputBitmap.setDensity(targetDensity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(opts.inBitmap != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bitmap was reused, ensure density is reset</span></span><br><span class="line">        outputBitmap.setDensity(Bitmap.getDefaultDensity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要就是把刚刚赋值过的两个属性inDensity和inTargetDensity给Bitmap进行赋值，不过并不是直接赋给Bitmap就完了，中间有个判断，当inDensity的值与inTargetDensity或与设备的屏幕Density不相等时，则将应用inTargetDensity的值，如果相等则应用inDensity的值。</p>
<blockquote>
<p>所以总结来说，<strong>setDensityFromOptions</strong>方法就是把<strong>inTargetDensity</strong>的值赋给Bitmap，不过前提是opts.inScaled = true；</p>
</blockquote>
<p>进过上面的分析，可以得出这样一个结论：</p>
<blockquote>
<p>在不配置Options的情况下：<br>1、decodeFile、decodeStream在解析时不会对Bitmap进行一系列的屏幕适配，解析出来的将是原始大小的图<br>2、decodeResource在解析时会对Bitmap根据当前设备屏幕像素密度densityDpi的值进行缩放适配操作，使得解析出来的Bitmap与当前设备的分辨率匹配，达到一个最佳的显示效果，并且Bitmap的大小将比原始的大</p>
</blockquote>
<h3 id="关于Density、分辨率、-hdpi等res目录之间的关系"><a href="#关于Density、分辨率、-hdpi等res目录之间的关系" class="headerlink" title="关于Density、分辨率、-hdpi等res目录之间的关系"></a><strong>关于Density、分辨率、-hdpi等res目录之间的关系</strong></h3><table>
<thead>
<tr>
<th>DensityDpi</th>
<th>分辨率</th>
<th>res</th>
<th>Density</th>
</tr>
</thead>
<tbody>
<tr>
<td>160dpi</td>
<td>320x533</td>
<td>mdpi</td>
<td>1</td>
</tr>
<tr>
<td>240dpi</td>
<td>480x800</td>
<td>hdpi</td>
<td>1.5</td>
</tr>
<tr>
<td>320dpi</td>
<td>720x1280</td>
<td>xhdpi</td>
<td>2</td>
</tr>
<tr>
<td>480dpi</td>
<td>1080x1920</td>
<td>xxhdpi</td>
<td>3</td>
</tr>
<tr>
<td>560dpi</td>
<td>1440x2560</td>
<td>xxxhdpi</td>
<td>3.5</td>
</tr>
</tbody>
</table>
<p>dp与px的换算公式为：</p>
<blockquote>
<p>px = dp * Density</p>
</blockquote>
<h3 id="DisplayMetrics-densityDpi与density的区别"><a href="#DisplayMetrics-densityDpi与density的区别" class="headerlink" title="DisplayMetrics::densityDpi与density的区别"></a><strong>DisplayMetrics::densityDpi与density的区别</strong></h3><blockquote>
<p>getResources().getDisplayMetrics().densityDpi——表示屏幕的像素密度<br>getResources().getDisplayMetrics().density——1dp等于多少个像素(px)</p>
</blockquote>
<p>举个栗子：在屏幕密度为160的设备下，1dp=1px。在屏幕密度为320的设备下，1dp=2px。<br>所以这就为什么在安卓中布局建议使用dp为单位，因为可以根据当前设备的屏幕密度动态的调整进行适配</p>
<h2 id="Bitmap的优化策略"><a href="#Bitmap的优化策略" class="headerlink" title="Bitmap的优化策略"></a><strong>Bitmap的优化策略</strong></h2><h3 id="BitmapFactory-Options的属性解析"><a href="#BitmapFactory-Options的属性解析" class="headerlink" title="BitmapFactory.Options的属性解析"></a><strong>BitmapFactory.Options的属性解析</strong></h3><p>BitmapFactory.Options中有以下属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span>Bitmap——在解析Bitmap时重用该Bitmap，不过必须等大的Bitmap而且<span class="keyword">in</span>Mutable须为<span class="literal">true</span></span><br><span class="line"><span class="keyword">in</span>Mutable——配置Bitmap是否可以更改，比如：在Bitmap上隔几个像素加一条线段</span><br><span class="line"><span class="keyword">in</span>JustDecodeBounds——为<span class="literal">true</span>仅返回Bitmap的宽高等属性</span><br><span class="line"><span class="keyword">in</span>SampleSize——须&gt;=<span class="number">1</span>,表示Bitmap的压缩比例，如：<span class="keyword">in</span>SampleSize=<span class="number">4</span>，将返回一个是原始图的<span class="number">1</span>/<span class="number">16</span>大小的Bitmap</span><br><span class="line"><span class="keyword">in</span>PreferredConfig——Bitmap.Config.ARGB_8888等</span><br><span class="line"><span class="keyword">in</span>Dither——是否抖动，默认为<span class="literal">false</span></span><br><span class="line"><span class="keyword">in</span>Premultiplied——默认为<span class="literal">true</span>，一般不改变它的值</span><br><span class="line"><span class="keyword">in</span>Density——Bitmap的像素密度</span><br><span class="line"><span class="keyword">in</span>TargetDensity——Bitmap最终的像素密度</span><br><span class="line"><span class="keyword">in</span>ScreenDensity——当前屏幕的像素密度</span><br><span class="line"><span class="keyword">in</span>Scaled——是否支持缩放，默认为<span class="literal">true</span>，当设置了这个，Bitmap将会以<span class="keyword">in</span>TargetDensity的值进行缩放</span><br><span class="line"><span class="keyword">in</span>Purgeable——当存储Pixel的内存空间在系统内存不足时是否可以被回收</span><br><span class="line"><span class="keyword">in</span>InputShareable——<span class="keyword">in</span>Purgeable为<span class="literal">true</span>情况下才生效，是否可以共享一个InputStream</span><br><span class="line"><span class="keyword">in</span>PreferQualityOverSpeed——为<span class="literal">true</span>则优先保证Bitmap质量其次是解码速度</span><br><span class="line">outWidth——返回的Bitmap的宽</span><br><span class="line">outHeight——返回的Bitmap的高</span><br><span class="line"><span class="keyword">in</span>TempStorage——解码时的临时空间，建议<span class="number">16</span>*<span class="number">1024</span></span><br></pre></td></tr></table></figure>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a><strong>优化策略</strong></h3><blockquote>
<p><strong>1、BitmapConfig的配置</strong><br><strong>2、使用decodeFile、decodeResource、decodeStream进行解析Bitmap时，配置inDensity和inTargetDensity，两者应该相等,值可以等于屏幕像素密度*0.75f</strong><br><strong>3、使用inJustDecodeBounds预判断Bitmap的大小及使用inSampleSize进行压缩</strong><br><strong>4、对Density&gt;240的设备进行Bitmap的适配（缩放Density）</strong><br><strong>5、2.3版本inNativeAlloc的使用</strong><br><strong>6、4.4以下版本inPurgeable、inInputShareable的使用</strong><br><strong>7、Bitmap的回收</strong></p>
</blockquote>
<p>针对上面方案，把Bitmap解码的代码封装成了一个工具类，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BitmapDecodeUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> DEFAULT_DENSITY = <span class="number">240</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">float</span> SCALE_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Bitmap.Config DEFAULT_BITMAP_CONFIG = Bitmap.Config.RGB_565;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BitmapFactory.<span class="function">Options <span class="title">getBitmapOptions</span>(<span class="params">Context context</span>) </span>&#123;</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inScaled = <span class="keyword">true</span>;</span><br><span class="line">        options.inPreferredConfig = DEFAULT_BITMAP_CONFIG;</span><br><span class="line">        options.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line">        options.inInputShareable = <span class="keyword">true</span>;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.GINGERBREAD_MR1) &#123;</span><br><span class="line">            Field field = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                field = BitmapFactory.Options.class.getDeclaredField(<span class="string">"inNativeAlloc"</span>);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.setBoolean(options, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> displayDensityDpi = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">        <span class="keyword">float</span> displayDensity = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        <span class="keyword">if</span> (displayDensityDpi &gt; DEFAULT_DENSITY &amp;&amp; displayDensity &gt; <span class="number">1.5</span>f) &#123;</span><br><span class="line">            <span class="keyword">int</span> density = (<span class="keyword">int</span>) (displayDensityDpi * SCALE_FACTOR);</span><br><span class="line">            options.inDensity = density;</span><br><span class="line">            options.inTargetDensity = density;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeBitmap</span>(<span class="params">Context context, <span class="keyword">int</span> resId</span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(context.getResources(), resId, getBitmapOptions(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeBitmap</span>(<span class="params">Context context, String pathName</span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(pathName, getBitmapOptions(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeBitmap</span>(<span class="params">Context context, InputStream <span class="keyword">is</span></span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        checkParam(<span class="keyword">is</span>);</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeStream(<span class="keyword">is</span>, <span class="keyword">null</span>, getBitmapOptions(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">compressBitmap</span>(<span class="params">Context context,<span class="keyword">int</span> resId, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight</span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        final TypedValue <span class="keyword">value</span> = <span class="keyword">new</span> TypedValue();</span><br><span class="line">        InputStream <span class="keyword">is</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">is</span> = context.getResources().openRawResource(resId, <span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">return</span> compressBitmap(context, <span class="keyword">is</span>, maxWidth, maxHeight);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">is</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">is</span>.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">compressBitmap</span>(<span class="params">Context context, String pathName, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight</span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        InputStream <span class="keyword">is</span> = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">is</span> = <span class="keyword">new</span> FileInputStream(pathName);</span><br><span class="line">            <span class="keyword">return</span> compressBitmap(context, <span class="keyword">is</span>, maxWidth, maxHeight);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">is</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">is</span>.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">compressBitmap</span>(<span class="params">Context context, InputStream <span class="keyword">is</span>, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight</span>) </span>&#123;</span><br><span class="line">        checkParam(context);</span><br><span class="line">        checkParam(<span class="keyword">is</span>);</span><br><span class="line">        BitmapFactory.Options opt = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        opt.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeStream(<span class="keyword">is</span>, <span class="keyword">null</span>, opt);</span><br><span class="line">        <span class="keyword">int</span> height = opt.outHeight;</span><br><span class="line">        <span class="keyword">int</span> width = opt.outWidth;</span><br><span class="line">        <span class="keyword">int</span> sampleSize = computeSampleSize(width, height, maxWidth, maxHeight);</span><br><span class="line">        BitmapFactory.Options options = getBitmapOptions(context);</span><br><span class="line">        options.inSampleSize = sampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeStream(<span class="keyword">is</span>, <span class="keyword">null</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeSampleSize</span>(<span class="params"><span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (height &gt; maxHeight || width &gt; maxWidth) &#123;</span><br><span class="line">            final <span class="keyword">int</span> heightRate = Math.round((<span class="keyword">float</span>) height / (<span class="keyword">float</span>) maxHeight);</span><br><span class="line">            final <span class="keyword">int</span> widthRate = Math.round((<span class="keyword">float</span>) width / (<span class="keyword">float</span>) maxWidth);</span><br><span class="line">            inSampleSize = heightRate &lt; widthRate ? heightRate : widthRate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inSampleSize % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            inSampleSize -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inSampleSize &lt;= <span class="number">1</span> ? <span class="number">1</span> : inSampleSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">checkParam</span>(<span class="params">T param</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(param == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有两类方法：<br>一、decodeBitmap:对Bitmap不压缩，但是会根据屏幕的密度合适的进行缩放压缩<br>二、compressBimtap:对Bitmap进行超过最大宽高的压缩，同时也会根据屏幕的密度合适的进行缩放压缩。</p>
<h2 id="Bitmap优化前后性能对比"><a href="#Bitmap优化前后性能对比" class="headerlink" title="Bitmap优化前后性能对比"></a><strong>Bitmap优化前后性能对比</strong></h2><p>针对上面方案，做一下性能对比,图片大小为3.26M,分辨率为2048*2048<br>有两台设备：</p>
<h3 id="density为320的设备"><a href="#density为320的设备" class="headerlink" title="density为320的设备"></a><strong>density为320的设备</strong></h3><p><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/bitmap1.png" alt="这里写图片描述"></p>
<h3 id="density为560的设备"><a href="#density为560的设备" class="headerlink" title="density为560的设备"></a><strong>density为560的设备</strong></h3><p><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/bitmap2.png" alt="这里写图片描述"></p>
<p>可以看到，都是加载同一图片，在高屏幕像素密度的设备下所需要的内存需要很大、载入内存中的Bitmap的宽高也因设备的屏幕像素密度也改变，正如上面分析的一样，使用decodeResource会自动适配当前设备的分辨率达到一个最佳效果，而只有这个方法会自动适配其它方法将不会，依次思路，我们在封装的工具类中在每一个方法都加入了依屏幕像素密度来自动适配，而在实际中并不需要那么高清的图片，所以我们可以根据设备的density来进行缩放，比如：在400&gt;=density&gt;240的情况下x0.8,在density&gt;400的情况下x0.7，这样Bitmap所占用的内存将减少非常多，可以对面上面两个图片中bitmap和decodeBitmap两个值的大小，decodeBitmap只是对density进行了一定的缩放，而占用内存却减少非常多，而且显示效果也和原先的并无区别。<br>之后对比我们进行了inSampleSize压缩的图片，进行压缩后的效果也看不出太大区别，而占用内存也减少了很多。</p>
<h2 id="Bitmap的回收"><a href="#Bitmap的回收" class="headerlink" title="Bitmap的回收"></a><strong>Bitmap的回收</strong></h2><h3 id="Android-2-3-3-API-10-及以下的系统"><a href="#Android-2-3-3-API-10-及以下的系统" class="headerlink" title="Android 2.3.3(API 10)及以下的系统"></a><strong>Android 2.3.3(API 10)及以下的系统</strong></h3><p>在2.3以下的系统中，Bitmap的像素数据是存储在native中，Bitmap对象是存储在java堆中的，所以在回收Bitmap时，需要回收两个部分的空间：native和java堆。<br>即先调用recycle()释放native中Bitmap的像素数据，再对Bitmap对象置null，保证GC对Bitmap对象的回收</p>
<h3 id="Android-3-0-API-11-及以上的系统"><a href="#Android-3-0-API-11-及以上的系统" class="headerlink" title="Android 3.0(API 11)及以上的系统"></a><strong>Android 3.0(API 11)及以上的系统</strong></h3><p>在3.0以上的系统中，Bitmap的像素数据和对象本身都是存储在java堆中的，无需主动调用recycle()，只需将对象置null，由GC自动管理</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BitmapFactory解析Bitmap的原理&quot;&gt;&lt;a href=&quot;#BitmapFactory解析Bitmap的原理&quot; class=&quot;headerlink&quot; title=&quot;BitmapFactory解析Bitmap的原理&quot;&gt;&lt;/a&gt;&lt;strong&gt;BitmapFactory解析Bitmap的原理&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;BitmapFactory提供的解析Bitmap的静态工厂方法有以下五种：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Bitmap &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;decodeFile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bitmap &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;decodeResource&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bitmap &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;decodeByteArray&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bitmap &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;decodeStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bitmap &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;decodeFileDescriptor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(...)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中常用的三个：decodeFile、decodeResource、decodeStream。&lt;br&gt;decodeFile和decodeResource其实最终都是调用decodeStream方法来解析Bitmap，decodeStream的内部则是调用两个native方法解析Bitmap的：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;nativeDecodeAsset&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;nativeDecodeStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两个native方法只是对应decodeFile和decodeResource、decodeStream来解析的，像decodeByteArray、decodeFileDescriptor也有专门的native方法负责解析Bitmap。&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Bitmap" scheme="http://zhengxiaoyong.me/tags/Bitmap/"/>
    
      <category term="内存优化" scheme="http://zhengxiaoyong.me/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于生产者-消费者-订阅者模式的那些事</title>
    <link href="http://zhengxiaoyong.me/2016/01/27/%E5%85%B3%E4%BA%8E%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85-%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://zhengxiaoyong.me/2016/01/27/关于生产者-消费者-订阅者模式的那些事/</id>
    <published>2016-01-27T06:26:30.000Z</published>
    <updated>2016-04-24T05:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者/消费者模式"></a><strong>生产者/消费者模式</strong></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><h3 id="用来干嘛的？"><a href="#用来干嘛的？" class="headerlink" title="用来干嘛的？"></a><strong>用来干嘛的？</strong></h3><p>生产者/消费者模式的产生主要目的就是为了解决非同步的生产与消费之间的问题。</p>
<p><strong>什么是非同步呢？</strong><br>    比如我刚刚生产了某个产品，而此时你正在打游戏，没空来取，要打完游戏来取，这就导致了我生产产品和你取产品是两个非同步的动作，你不知道我什么时候生产完产品，而我也不知道你什么时候来取。</p>
<p>而生产者/消费者模式就是解决这个非同步问题的，因为肯定不可能我生产完一个就给你打个电话叫你来取，然后等你取完我再生产下一个，这是多么低效的一种做法。所以这个模式运用而生，这个模式在生活中也有很好的体现，如：快递员派信这个例子，我就是生产者，快递员就是消费者，而生产者与消费者之间是通过什么来解决这种非同步的问题呢？就是一个存储中介，作为快递员派信这个例子中，信箱就是这个存储中介，每次我只要把写完的信扔入信箱，而快递员隔三差五的就会来取一次信，这两个动作是完全异步的，我把信扔入信箱后就不需要管什么了，之后肯定有快递员来取。<br><a id="more"></a></p>
<h2 id="如何设计"><a href="#如何设计" class="headerlink" title="如何设计"></a><strong>如何设计</strong></h2><h3 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a><strong>设计图</strong></h3><p>生产者/消费者模式能够解决非同步的生产与消费的问题，归功就是存储中介的作用，因为生产者只要把生产完的物品放入存储中介中就行了，而不必关系消费者什么时候来取，当消费者需要时自然会来取，当存储中介满了的话，那么生产者将停止生产，因为再生产就没地放了，这时候就需要等待消费者消费了，而当存储中介没有时，这时候消费者来取那肯定取不到，所以也需要Wait，等待生产者生产后才能取到。所以这就有了下面这个设计图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/consumer1.jpg" alt="这里写图片描述"></p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a><strong>定位</strong></h3><p>从上图中可以知道，一个完整的生产者/消费者模式具有生产者、消费者、存储中介以及产品。这四个缺一不可，而关于它们的定位也至关重要<br>1 . <strong>Product</strong><br>    对于产品，什么样的对象才能成为产品呢，一是根据当时的业务逻辑来判断，比如执行完某些操作后的产生的Result，二是必须保持每个产品之间的完整性和独立性，保证各个产品之间互不影响、互不关联。<br>2 . <strong>Store</strong><br>    对于存储中介，它肯定是一块具有额定大小的存储空间，而这个存储空间一般来说具有FIFO的数据结构，比如JDK内置了具有阻塞作用的有界队列：ArrayBlockingQueue、LinkedBlockingQueue。并且存储中介需要起到生产者与消费者解耦的作用，这样的好处是当后期生产者或者消费者的生产方式或处理方式变了，这样只需要改变一方，而另外一方则不需要调整。而且它负责协调生产者与消费者之间的生产消费关系。<br>3 . <strong>Producer</strong><br>    对于生产者，它是具有配置Product各种属性的一个对象，可以设计成Factory、Builder、装饰者模式等等，一般来说生产者有单独的一个线程用来生产产品，当然如果量大的话可以用多个线程去生产，不过需要处理一下线程同步的问题（Semaphore|synchronized|ThreadLocal）<br>4 .  <strong>Consumer</strong><br>    对于消费者，和Producer差不多，主要就是用来处理Product的，一般也有单独的一个线程去处理Product。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h2><p>1 . <strong>生产者</strong><br><code>AppleProducer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> AppleProducer &#123;</span><br><span class="line">    <span class="keyword">private</span> Store&lt;Apple&gt; mStore;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService mWorkThread = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppleProducer <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppleProducer <span class="title">bindStore</span><span class="params">(Store&lt;Apple&gt; store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mStore = store;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mWorkThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @<span class="function">Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                Apple apple = <span class="keyword">new</span> Apple(<span class="string">"第"</span> + name + <span class="string">"个产品"</span>);</span><br><span class="line">                mStore.push(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 . <strong>消费者</strong><br><code>AppleConsumer</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> AppleConsumer &#123;</span><br><span class="line">    <span class="keyword">private</span> Store&lt;Apple&gt; mStore;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService mWorkThread = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppleConsumer <span class="title">bindStore</span><span class="params">(Store&lt;Apple&gt; store)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mStore = store;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mWorkThread.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @<span class="function">Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Apple apple = mStore.take();</span><br><span class="line">                    System.out.println(<span class="string">"apple:"</span> + apple.getName() + <span class="string">"消费了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 .  <strong>存储中介</strong><br><code>Store</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;T&gt; mQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mQueue.put(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"product生产了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = mQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"product取出了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mQueue.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        mQueue.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 . <strong>产品</strong></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Apple &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Apple(String <span class="keyword">name</span>) &#123;</span><br><span class="line">        this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setName(String <span class="keyword">name</span>) &#123;</span><br><span class="line">        this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 . <strong>Test</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Store&lt;Apple&gt; store = <span class="keyword">new</span> Store&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> AppleConsumer()</span><br><span class="line">                .bindStore(store)</span><br><span class="line">                .consume();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> AppleProducer()</span><br><span class="line">                    .bindStore(store)</span><br><span class="line">                    .setName(i + <span class="string">""</span>)</span><br><span class="line">                    .production();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>result:</strong></p>
<blockquote>
<p>product生产了…<br>product生产了…<br>product生产了…<br>product生产了…<br>product生产了…<br>product取出了…<br>apple:第1个产品消费了<br>product生产了…<br>product生产了…<br>product生产了…<br>product生产了…<br>product生产了…<br>product生产了…<br>product取出了…<br>apple:第0个产品消费了<br>product生产了…<br>product取出了…<br>product生产了…<br>apple:第3个产品消费了<br>product取出了…<br>apple:第2个产品消费了<br>product生产了…<br>product取出了…<br>apple:第4个产品消费了<br>product生产了…<br>product取出了…<br>apple:第5个产品消费了<br>product生产了…<br>product取出了…<br>apple:第6个产品消费了<br>product生产了…<br>…</p>
</blockquote>
<hr>
<p>对于生产者，为了避免生产线程数量过多采取了一个线程池控制生产线程的数量，而生产者每一件产品都是由单独的一个线程来生产，对于消费者，用一个线程去轮询取队列里的产品，有则取出，没有则阻塞等待，由于ArrayBlockingQueue本身是支持并发的，所以在多线程共同操作一个存储队列的情况下，并不会有并发的问题。<br>所以生产者/消费者模式也支持多生产——多消费的模式：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/consumer2.jpg" alt="这里写图片描述"><br>对于有众多种类不同的生产者，可以用一个工厂类来管理。</p>
<h2 id="数据源-订阅者模式"><a href="#数据源-订阅者模式" class="headerlink" title="数据源/订阅者模式"></a><strong>数据源/订阅者模式</strong></h2><p>关于这个模式，其实是生产者/消费者模式的变体，这种模式并不需要存储中介，而是通过一个<strong>DataSource空壳</strong>来包装数据，对于发布者提交了一个Task后，将立即返回一个DataSource，对于任务执行完后的结果，如果你想获取则必须通过datasource.subscribe(new XxxSubscriber(…))来订阅获取执行后的结果，而如果不通过数据源订阅的方式来获取而直接通过datasource.getData()获取则返回null，因为DataSource只是一个获取数据的空壳。这种模式在Fresco源码中有很好的体现，用了大量的这种模式。<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/consumer3.jpg" alt="这里写图片描述"></p>
<p>栗子：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  DataSource&lt;Apple&gt; dataSource = ProducerFactory.newAppleProducer().submit(name);</span><br><span class="line">  <span class="comment">//Apple apple = dataSource.getData();// apple is null!</span></span><br><span class="line">  dataSource.subscribe(<span class="keyword">new</span> BaseDataSubscriber&lt;Apple&gt;() &#123;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(DataSource&lt;Apple&gt; dataSource)</span> </span>&#123;</span><br><span class="line">Apple apple = dataSource.getData();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(DataSource&lt;Apple&gt; dataSource,Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;生产者-消费者模式&quot;&gt;&lt;a href=&quot;#生产者-消费者模式&quot; class=&quot;headerlink&quot; title=&quot;生产者/消费者模式&quot;&gt;&lt;/a&gt;&lt;strong&gt;生产者/消费者模式&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;用来干嘛的？&quot;&gt;&lt;a href=&quot;#用来干嘛的？&quot; class=&quot;headerlink&quot; title=&quot;用来干嘛的？&quot;&gt;&lt;/a&gt;&lt;strong&gt;用来干嘛的？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;生产者/消费者模式的产生主要目的就是为了解决非同步的生产与消费之间的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是非同步呢？&lt;/strong&gt;&lt;br&gt;    比如我刚刚生产了某个产品，而此时你正在打游戏，没空来取，要打完游戏来取，这就导致了我生产产品和你取产品是两个非同步的动作，你不知道我什么时候生产完产品，而我也不知道你什么时候来取。&lt;/p&gt;
&lt;p&gt;而生产者/消费者模式就是解决这个非同步问题的，因为肯定不可能我生产完一个就给你打个电话叫你来取，然后等你取完我再生产下一个，这是多么低效的一种做法。所以这个模式运用而生，这个模式在生活中也有很好的体现，如：快递员派信这个例子，我就是生产者，快递员就是消费者，而生产者与消费者之间是通过什么来解决这种非同步的问题呢？就是一个存储中介，作为快递员派信这个例子中，信箱就是这个存储中介，每次我只要把写完的信扔入信箱，而快递员隔三差五的就会来取一次信，这两个动作是完全异步的，我把信扔入信箱后就不需要管什么了，之后肯定有快递员来取。&lt;br&gt;
    
    </summary>
    
      <category term="技术沉淀" scheme="http://zhengxiaoyong.me/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/"/>
    
    
      <category term="消费者" scheme="http://zhengxiaoyong.me/tags/%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
      <category term="生产者" scheme="http://zhengxiaoyong.me/tags/%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    
      <category term="订阅者" scheme="http://zhengxiaoyong.me/tags/%E8%AE%A2%E9%98%85%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之Splash页应该这样设计</title>
    <link href="http://zhengxiaoyong.me/2016/01/17/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BSplash%E9%A1%B5%E5%BA%94%E8%AF%A5%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zhengxiaoyong.me/2016/01/17/Android性能优化之Splash页应该这样设计/</id>
    <published>2016-01-16T16:18:30.000Z</published>
    <updated>2016-05-06T06:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目前SplashActivity的设计"><a href="#目前SplashActivity的设计" class="headerlink" title="目前SplashActivity的设计"></a><strong>目前SplashActivity的设计</strong></h2><p>目前市场上的应用在启动时基本上都会先启动一个SplashActivity，作为一个欢迎界面，为什么这样设计呢？<br>个人总结有三个优点：</p>
<h3 id="可以给用户更好的体验"><a href="#可以给用户更好的体验" class="headerlink" title="可以给用户更好的体验"></a>可以给用户更好的体验</h3><p>比如：可以由后台动态的改变欢迎的图片，或者显欢迎xxx回来，新浪微博的就是这种交互。</p>
<h3 id="可以缩减App的启动时间"><a href="#可以缩减App的启动时间" class="headerlink" title="可以缩减App的启动时间"></a>可以缩减App的启动时间</h3><p>由上一篇博文中知道app启动的耗时主要是在Application初始化中和MainActivity的界面绘制前，由于MainActivity的业务和布局复杂度肯定比只显示一张图片的界面高，所以，加入一个显示一张图片的Splash页可以优化应用的启动。</p>
<h3 id="可以在应用启动时做更多的事"><a href="#可以在应用启动时做更多的事" class="headerlink" title="可以在应用启动时做更多的事"></a>可以在应用启动时做更多的事</h3><p>一般来说SplashActivity一般会设计成停留2到4s不等，或者根据数据的加载程度来动态的设置Splash界面的停留时间，既然停留那么久，那么当然可以在这个界面背后做一些事以备MainActivity的快速显示，比如：数据的预加载、sp的初始化、网络请求等。</p>
<p>当然你可能有些疑问，那这样初始化放在Application中也可以啊？也用异步操作数据也是一样啊？</p>
<p>答案是不一样！正如上篇所说的，Application初始化时并不会加载界面，而是在它创建完和初始化完成后，开始创建Activity时才开始绘制Theme中的background和绘制布局，所以用一个轻量的Splash页给它设置一张背景欢迎图，这样就立马能显示界面了，而在这个界面中还可以做其它的初始化操作，这样在视觉上即达到了app的快速启动，又添加了体验和做数据的初始化。</p>
<p>相反如果过多的放在Application中，则在点击app图标启动时会感觉延迟，必须要把Application中的东西都做完才进入Activity的配置和绘制中。<br><a id="more"></a></p>
<h2 id="目前大多数应用的Splash页设计的不足之处"><a href="#目前大多数应用的Splash页设计的不足之处" class="headerlink" title="目前大多数应用的Splash页设计的不足之处"></a><strong>目前大多数应用的Splash页设计的不足之处</strong></h2><p>目前大多应用的Splash页设计都是利用一个Activity，取名叫SplashActivity，然后在这个SplashActivity中加入一个背景图，然后再new Handler().postDelayed()几秒中，再startActivity跳入主界面，这样设计看起来非常不错，既可以在SplashActivity初始化、预加载数据，还可以提高应用的启动速度。</p>
<p>不过这确实提高了应用的启动速度，毕竟我们比较快的看到了第一帧——SplashActivity，不过在SplashActivity之后，还需要调到MainActivity啊，虽然MainActivity中的一些数据可以在SplashActivity做预取，不过这中间需要有Intent的传递过程，而且MainActivity中布局还没加载进来，所以还是需要再加载和绘制布局界面，然后才能填入数据，所以这样看来，在跳转到MainActivity中，还是需要做界面的绘制和数据的加载（包括Intent的数据传递）。</p>
<h3 id="以往的SplashActivity的设计图"><a href="#以往的SplashActivity的设计图" class="headerlink" title="以往的SplashActivity的设计图"></a><strong>以往的SplashActivity的设计图</strong></h3><p>这样看来上面这个设计流程可以这样表示：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/splash1.png" alt="这里写图片描述"></p>
<h2 id="性能优且体验棒的Splash页的设计"><a href="#性能优且体验棒的Splash页的设计" class="headerlink" title="性能优且体验棒的Splash页的设计"></a><strong>性能优且体验棒的Splash页的设计</strong></h2><p>从上面这个设计图来看，其中有些操作能不能去除呢？既能达到app启动速度的提高，也能对数据的预加载还能减去Splash和MainActivity之间不必要的数据传递和View的分开绘制。</p>
<p>答案是能的，既然SplashActivity和MainActivity分开进行操作还是不完美，那么可以考虑把它们合为一起，即：一开始还是显示MainActivity，SplashActivity变为SplashFragment，然后放一个FrameLayout作为根布局去显示SplashFragment界面，这样在SplashFragment显示时候利用显示的2~4s间的空隙时间做网络请求去加载数据，这样待SplashFragment显示完后再remove，这样将看到的是有内容的MainActivity，就不必再去等待网络请求去返回数据了。<br>当然，这种方式是把load Splash View和ContentView合二为一了一起加载，这可能会影响应用的启动时间，这时我们可以用ViewStub延迟加载MainActivity中某些View从而减去这个影响。</p>
<p>如下设计：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/splash2.png" alt="这里写图片描述"></p>
<h2 id="优化前后效果对比"><a href="#优化前后效果对比" class="headerlink" title="优化前后效果对比"></a><strong>优化前后效果对比</strong></h2><p>这里为了测试，我把Splash页的delay时间都设为2.5s。<br>优化前：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/splash3.gif" alt="这里写图片描述"><br>优化后：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/splash4.gif" alt="这里写图片描述"><br>优化后其实是把SplashActivity用Fragment显示，显示完后再remove，这样在显示的时候，MainActivity中还可以直接加载网络数据，这样在显示完SplashFragment后则直接显示主页了，而省去了ProgressBar进度条的网络加载过程。<br>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">   <span class="keyword">final</span> SplashFragment splashFragment = <span class="keyword">new</span> SplashFragment();</span><br><span class="line">   <span class="keyword">final</span> FragmentTransaction transaction = getFragmentManager().beginTransaction();</span><br><span class="line">   transaction.replace(R.id.frame, splashFragment);</span><br><span class="line">   transaction.commit();	</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">mHandler.postDelayed(<span class="keyword">new</span> DelayRunnable(<span class="keyword">this</span>, splashFragment, mProgressBar), <span class="number">2500</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> WeakReference&lt;Context&gt; contextRef;</span><br><span class="line">       <span class="keyword">private</span> WeakReference&lt;SplashFragment&gt; fragmentRef;</span><br><span class="line">       <span class="keyword">private</span> WeakReference&lt;ProgressBar&gt; progressBarRef;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DelayRunnable</span><span class="params">(Context context, SplashFragment splashFragment, ProgressBar progressBar)</span> </span>&#123;</span><br><span class="line">           contextRef = <span class="keyword">new</span> WeakReference&lt;Context&gt;(context);</span><br><span class="line">           fragmentRef = <span class="keyword">new</span> WeakReference&lt;SplashFragment&gt;(splashFragment);</span><br><span class="line">           progressBarRef = <span class="keyword">new</span> WeakReference&lt;ProgressBar&gt;(progressBar);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ProgressBar progressBar = progressBarRef.get();</span><br><span class="line">           <span class="keyword">if</span> (progressBar != <span class="keyword">null</span>)</span><br><span class="line">               progressBar.setVisibility(View.GONE);</span><br><span class="line">           Activity context = (Activity) contextRef.get();</span><br><span class="line">           <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">               SplashFragment splashFragment = fragmentRef.get();</span><br><span class="line">               <span class="keyword">if</span> (splashFragment == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               <span class="keyword">final</span> FragmentTransaction transaction = context.getFragmentManager().beginTransaction();</span><br><span class="line">               transaction.remove(splashFragment);</span><br><span class="line">               transaction.commit();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中FrameLayout作为MainActivity的根布局用作SplashFragment的全屏显示。<br>为了更优则可以考虑ViewStub，在SplashFragment显示时再进行加载额外的View。</p>
<p>关于耦合性，其实很低，Splash页面有专门一个SplashFragment去配置，而MainActivity只是控制它的加载与remove。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目前SplashActivity的设计&quot;&gt;&lt;a href=&quot;#目前SplashActivity的设计&quot; class=&quot;headerlink&quot; title=&quot;目前SplashActivity的设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;目前SplashActivity的设计&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;目前市场上的应用在启动时基本上都会先启动一个SplashActivity，作为一个欢迎界面，为什么这样设计呢？&lt;br&gt;个人总结有三个优点：&lt;/p&gt;
&lt;h3 id=&quot;可以给用户更好的体验&quot;&gt;&lt;a href=&quot;#可以给用户更好的体验&quot; class=&quot;headerlink&quot; title=&quot;可以给用户更好的体验&quot;&gt;&lt;/a&gt;可以给用户更好的体验&lt;/h3&gt;&lt;p&gt;比如：可以由后台动态的改变欢迎的图片，或者显欢迎xxx回来，新浪微博的就是这种交互。&lt;/p&gt;
&lt;h3 id=&quot;可以缩减App的启动时间&quot;&gt;&lt;a href=&quot;#可以缩减App的启动时间&quot; class=&quot;headerlink&quot; title=&quot;可以缩减App的启动时间&quot;&gt;&lt;/a&gt;可以缩减App的启动时间&lt;/h3&gt;&lt;p&gt;由上一篇博文中知道app启动的耗时主要是在Application初始化中和MainActivity的界面绘制前，由于MainActivity的业务和布局复杂度肯定比只显示一张图片的界面高，所以，加入一个显示一张图片的Splash页可以优化应用的启动。&lt;/p&gt;
&lt;h3 id=&quot;可以在应用启动时做更多的事&quot;&gt;&lt;a href=&quot;#可以在应用启动时做更多的事&quot; class=&quot;headerlink&quot; title=&quot;可以在应用启动时做更多的事&quot;&gt;&lt;/a&gt;可以在应用启动时做更多的事&lt;/h3&gt;&lt;p&gt;一般来说SplashActivity一般会设计成停留2到4s不等，或者根据数据的加载程度来动态的设置Splash界面的停留时间，既然停留那么久，那么当然可以在这个界面背后做一些事以备MainActivity的快速显示，比如：数据的预加载、sp的初始化、网络请求等。&lt;/p&gt;
&lt;p&gt;当然你可能有些疑问，那这样初始化放在Application中也可以啊？也用异步操作数据也是一样啊？&lt;/p&gt;
&lt;p&gt;答案是不一样！正如上篇所说的，Application初始化时并不会加载界面，而是在它创建完和初始化完成后，开始创建Activity时才开始绘制Theme中的background和绘制布局，所以用一个轻量的Splash页给它设置一张背景欢迎图，这样就立马能显示界面了，而在这个界面中还可以做其它的初始化操作，这样在视觉上即达到了app的快速启动，又添加了体验和做数据的初始化。&lt;/p&gt;
&lt;p&gt;相反如果过多的放在Application中，则在点击app图标启动时会感觉延迟，必须要把Application中的东西都做完才进入Activity的配置和绘制中。&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Splash页" scheme="http://zhengxiaoyong.me/tags/Splash%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之加快应用启动速度</title>
    <link href="http://zhengxiaoyong.me/2016/01/14/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8A%A0%E5%BF%AB%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    <id>http://zhengxiaoyong.me/2016/01/14/Android性能优化之加快应用启动速度/</id>
    <published>2016-01-14T14:51:30.000Z</published>
    <updated>2016-07-17T15:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用的启动"><a href="#应用的启动" class="headerlink" title="应用的启动"></a><strong>应用的启动</strong></h2><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a><strong>启动方式</strong></h3><p>通常来说，在安卓中应用的启动方式分为两种：冷启动和热启动</p>
<blockquote>
<p>1、冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。</p>
<p>2、热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。</p>
</blockquote>
<a id="more"></a>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>1、冷启动：冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。</p>
<p>2、热启动：热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application，因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次。</p>
<p><strong>上面说的启动是点击app的启动图标来启动的，而另外一种方式是进入最近使用的列表界面来启动应用，这种不应该叫启动，应该叫恢复。</strong></p>
<h2 id="应用启动的流程"><a href="#应用启动的流程" class="headerlink" title="应用启动的流程"></a><strong>应用启动的流程</strong></h2><p>在安卓系统上，应用在没有进程的情况下，应用的启动都是这样一个流程：当点击app的启动图标时，安卓系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate/onStart/onResume方法都走完了后最后才进行contentView的measure/layout/draw显示在界面上，所以直到这里，应用的第一次启动才算完成，这时候我们看到的界面也就是所说的第一帧。</p>
<p>所以，总结一下，应用的启动流程如下：</p>
<blockquote>
<p>Application的构造器方法——&gt;attachBaseContext()——&gt;onCreate()——&gt;Activity的构造方法——&gt;onCreate()——&gt;配置主题中背景等属性——&gt;onStart()——&gt;onResume()——&gt;测量布局绘制显示在界面上。</p>
</blockquote>
<h2 id="测量应用启动的时间"><a href="#测量应用启动的时间" class="headerlink" title="测量应用启动的时间"></a><strong>测量应用启动的时间</strong></h2><p>在上面这个启动流程中，任何一个地方有耗时操作都会拖慢我们应用的启动速度，而应用启动时间是用毫秒度量的，对于毫秒级别的快慢度量我们还是需要去精确的测量到到底应用启动花了多少时间，而根据这个时间来做衡量。</p>
<h3 id="什么才是应用的启动时间"><a href="#什么才是应用的启动时间" class="headerlink" title="什么才是应用的启动时间"></a><strong>什么才是应用的启动时间</strong></h3><p>从点击应用的启动图标开始创建出一个新的进程直到我们看到了界面的第一帧，这段时间就是应用的启动时间。</p>
<p>我们要测量的也就是这段时间，测量这段时间可以通过adb shell命令的方式进行测量，这种方法测量的最为精确，命令为：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W <span class="string">[packageName]</span>/<span class="string">[packageName.MainActivity]</span></span><br></pre></td></tr></table></figure>
<p>执行成功后将返回三个测量到的时间：<br>1、ThisTime:一般和TotalTime时间一样，除非在应用启动时开了一个透明的Activity预先处理一些事再显示出主Activity，这样将比TotalTime小。<br>2、TotalTime:应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示。<br>3、WaitTime:一般比TotalTime大点，包括系统影响的耗时。</p>
<p>下面是测量一个应用冷启动和热启动的时间：<br>冷启动：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/speed1.png" alt="这里写图片描述"><br>热启动：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/speed2.png" alt="这里写图片描述"></p>
<p>可以看到在进程已经存在的情况下，只需要重新初始化MainActivity，这样的启动比较快，不过大多数情况下应用的启动都是冷启动，因为用户都会在任务列表中手动关闭遗留的应用进程。</p>
<h2 id="减少应用启动时的耗时"><a href="#减少应用启动时的耗时" class="headerlink" title="减少应用启动时的耗时"></a><strong>减少应用启动时的耗时</strong></h2><p>针对冷启动时候的一些耗时，如上测得这个应用算是中型的app，在冷启动的时候耗时已经快700ms了，如果项目再大点在Application中配置了更多的初始化操作，这样将可能达到1s，这样每次启动都明显感觉延迟，所以在进行应用初始化的时候采取以下策略：<br>1、在Application的构造器方法、attachBaseContext()、onCreate()方法中不要进行耗时操作的初始化，一些数据预取放在异步线程中，可以采取Callable实现。<br>2、对于MainActivity，由于在获取到第一帧前，需要对contentView进行测量布局绘制操作，尽量减少布局的层次，考虑StubView的延迟加载策略，当然在onCreate、onStart、onResume方法中避免做耗时操作。</p>
<h2 id="优化应用启动时的体验"><a href="#优化应用启动时的体验" class="headerlink" title="优化应用启动时的体验"></a><strong>优化应用启动时的体验</strong></h2><p>对于应用的启动时间，只能是尽量的避免一些耗时的、非必要的操作在主线程中，这样相对可以缩减一部分启动的耗时，另外一方面在等待第一帧显示的时间里，可以加入一些配置以增加体验，比如加入Activity的background，这个背景会在显示第一帧前提前显示在界面上。<br>1、先为主界面单独写一个主题style，设置一张待显示的图片，这里我设置了一个颜色，然后在manifest中设置给MainActivity：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme.Launcher"</span>&gt;</span><span class="css"></span><br><span class="line">    &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">android</span><span class="pseudo">:windowBackground"</span>&gt;<span class="at_rule">@<span class="keyword">drawable/bule&lt;/item&gt;</span></span><br><span class="line"></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">//...</span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">            <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme.Launcher"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、然后在MainActivity中加载布局前把AppTheme重新设置给MainActivity：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">Override</span></span><br><span class="line">    protected void <span class="function">onCreate</span>(Bundle savedInstanceState) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="tag">setTheme</span>(<span class="tag">R</span><span class="class">.style</span><span class="class">.AppTheme</span>);</span><br><span class="line">        <span class="tag">super</span><span class="class">.onCreate</span>(<span class="tag">savedInstanceState</span>);</span><br><span class="line">        <span class="tag">setContentView</span>(<span class="tag">R</span><span class="class">.layout</span><span class="class">.activity_main</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在启动时会先显示background，然后待界面绘制完成再显示主界面<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/speed3.gif" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用的启动&quot;&gt;&lt;a href=&quot;#应用的启动&quot; class=&quot;headerlink&quot; title=&quot;应用的启动&quot;&gt;&lt;/a&gt;&lt;strong&gt;应用的启动&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;启动方式&quot;&gt;&lt;a href=&quot;#启动方式&quot; class=&quot;headerlink&quot; title=&quot;启动方式&quot;&gt;&lt;/a&gt;&lt;strong&gt;启动方式&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;通常来说，在安卓中应用的启动方式分为两种：冷启动和热启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。&lt;/p&gt;
&lt;p&gt;2、热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="启动速度" scheme="http://zhengxiaoyong.me/tags/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Fresco图片框架内部实现原理探索</title>
    <link href="http://zhengxiaoyong.me/2016/01/04/Fresco%E5%9B%BE%E7%89%87%E6%A1%86%E6%9E%B6%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
    <id>http://zhengxiaoyong.me/2016/01/04/Fresco图片框架内部实现原理探索/</id>
    <published>2016-01-04T03:38:30.000Z</published>
    <updated>2016-04-24T05:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流行的网络框架"><a href="#流行的网络框架" class="headerlink" title="流行的网络框架"></a><strong>流行的网络框架</strong></h2><p>目前流行的网络图片框架：<br>Picasso、Universal Image Loader、Volley的(ImageLoader、NetworkImageView)、Glide和Fresco</p>
<p>简明的介绍下（具体细节和功能可看源码和wiki）：<br>其中Picasso和Universal Image Loader相比其它的算是最轻量级的图片框架了，它们拥有较少的方法数，Universal Image Loader是这五个框架中定制性最强的，它内部实现还是按网络框架的套路走：HttpUrlConnection+线程池+Handler，支持渐显效果。<br>而Picasso只有一些图片加载框架应有的基本功能，所以因此它是最轻量的，在需求只要基本的图片加载与双缓存功能下，可以选Picasso作为项目的基础库，Picasso它内部默认是使用OkHttpClient作为加载网络图片的下载器，毕竟不用自家用谁的，在OkHttpClient没有的情况下则使用HttpUrlConnection，同上面一样，下载器+线程池+Handler，不过它内部的线程池比较有意思，线程池的线程数量是根据当前的网络环境来动态改变的，wifi网络下为4，4G为3，3G为2，2G为1，其它情况下默认为3，支持渐显效果。<br>Volley的没什么可说的，基本功能都有，网络框架的附赠功能。</p>
<p>Glide的话，Google官方推荐，支持Gif、图片缩略图、本地视频解码、请求和动画生命周期的自动管理、渐显动画、支持OkHttp和Volley等等，默认是使用HttpUrlConnection加载图片的，源码灰常多，200多个类，不想看</p>
<p>Fresco我认为是这几个框架中性能最佳的一个框架，着重介绍，它内部用了大量的建造者模式、单例模式、静态工厂模式、生产/消费者模式。内部实现比较复杂，就拿图片加载来说，是通过在异步线程中回调图片的输入流，然后通过一系列读取、写入、转化成EncodedImage，然后再Decode成Bitmap，通过Handler转给UI线程显示，通过IO操作存储在硬盘缓存目录下。<br><a id="more"></a></p>
<h2 id="Fresco性能上的优点"><a href="#Fresco性能上的优点" class="headerlink" title="Fresco性能上的优点"></a><strong>Fresco性能上的优点</strong></h2><h3 id="优一："><a href="#优一：" class="headerlink" title="优一："></a><strong>优一：</strong></h3><p>1、支持webp格式的图片，是Google官方推行的，它的大小比其它格式图片的大小要小一半左右，目前各个大公司都渐入的使用这种图片格式了，比如：Youtube、Gmail、淘宝、QQ空间等都已尝鲜，使用该格式最大的优点就是轻量、省流量、图片加载迅速。而Fresco是通过jni来实现支持WebP格式图片。</p>
<h3 id="优二："><a href="#优二：" class="headerlink" title="优二："></a><strong>优二：</strong></h3><p>2、5.0以下系统：使用”ashmem”（匿名共享内存）区域存储Bitmap缓存，这样Bitmap对象的创建、释放将永远不会触发GC，关于”ashmem”存储区域，它是一个不在Java堆区的一片存储内存空间，它的管理由Linux内核驱动管理，不必深究，只要知道这块存储区域是别于堆内存之外的一块空间就行了，且这块空间是可以多进程共享的，GC的活动不会影响到它。5.0以上系统，由于内存管理的优化，所以对于5.0以上的系统Fresco将Bitmap缓存直接放到了堆内存中。</p>
<p>关于”ashmem”的存储区域，我们的应用程序并不能像访问堆内存一样直接访问这块内存块，但是也有一些例外，对于Bitmap而言，有一种为”Purgeable Bitmap”可擦除的Bitmap位图是存储在这块内存区域中的，BitmapFactory.Options中有这么一个属性<code>inPurgeable</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="keyword">Options</span> = <span class="keyword">new</span> BitmapFactory.<span class="keyword">Options</span>();</span><br><span class="line"><span class="keyword">options</span>.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, <span class="number">0</span>, jpeg.length, <span class="keyword">options</span>);</span><br></pre></td></tr></table></figure>
<p>所以通过配置inPurgeable = true这个属性，这样解码出来的Bitmap位图就存储在”ashmem”区域中，之后用到”ashmem”中得图片时，则把这个图片从这个区域中取出来，渲染完毕后则放回这个位置。</p>
<p>既然Fresco中Bitmap缓存在5.0以前是放在”ashmem”中，GC并不会回收它们，且也不会被”ashmeme”内置的清除机制回收它们，所以这样虽然使得在堆中不会造成内存泄露，而在这块区域可能造成内存泄露，Fresco中采取的办法则是使用引用计数的方式，其中有一个SharedReference这个类，这个类中有这么两个方法：addReference()和deleteReference()，通过这两个基本方法来对引用进行计数，一旦计数为零时，则对应的资源将会清除（如：Bitmap.recycle()等），而Fresco为了考虑更容易被我们使用，又提供了一个CloseableReference类，该类可以说是SharedReference类上功能的封装，CloseableReference同时也实现了Cloneable、Closeable接口，它在调用.clone()方法时同时会调用addReference()来增加一个引用计数，在调用.close()方法时同时会调用deleteReference()来删除一个引用计数，所以在使用Fresco的使用，我们都是与CloseableReference类打交道，使用CloseableReference必须遵循以下两条规则：<br>1、在赋值CloseableReference给新对象的时候，调用.clone()进行赋值<br>2、在超出作用域范围的时候，必须调用.close()，通常会在finally代码块中调用</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> gee() &#123;</span><br><span class="line">  <span class="type">CloseableReference</span>&lt;<span class="type">Val</span>&gt; <span class="keyword">ref</span> = foo();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    haa(<span class="keyword">ref</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">ref</span>.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循这些规则可以有效地防止内存泄漏。</p>
<h3 id="优三："><a href="#优三：" class="headerlink" title="优三："></a><strong>优三：</strong></h3><p>3、使用了三级缓存：Bitmap缓存+未解码图片缓存+硬盘缓存。<br>其中前两个就是内存缓存，Bitmap缓存根据系统版本不同放在了不同内存区域中，而未解码图片的缓存只在堆内存中，Fresco分了两步做内存缓存，这样做有什么好处呢？第一个好处就如上的第二条，第二个好处是加快图片的加载速度，Fresco的加载图片的流程为：查找Bitmap缓存中是否存在，存在则直接返回Bitmap直接使用，不存在则查找未解码图片的缓存，如果存在则进行Decode成Bitmap然后直接使用并加入Bitmap缓存中，如果未解码图片缓存中查找不到，则进行硬盘缓存的检查，如有，则进行IO、转化、解码等一系列操作，最后成Bitmap供我们直接使用，并把未解码（Encode）的图片加入未解码图片缓存，把Bitmap加入Bitmap缓存中，如硬盘缓存中没有，则进行Network操作下载图片，然后加入到各个缓存中。</p>
<p>既然Fresco使用了三级缓存，而有两级是内存缓存，所以当我们的App在后台时或者在内存低的情况下在onLowMemory()方法中，我们应该手动清除应用的内存缓存，我们可以使用下面的方式：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ImagePipeline imagePipeline = Fresco.getImagePipeline()<span class="comment">;</span></span><br><span class="line">//清空内存缓存（包括Bitmap缓存和未解码图片的缓存）</span><br><span class="line">imagePipeline.clearMemoryCaches()<span class="comment">;</span></span><br><span class="line">//清空硬盘缓存，一般在设置界面供用户手动清理</span><br><span class="line">imagePipeline.clearDiskCaches()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//同时清理内存缓存和硬盘缓存</span><br><span class="line">imagePipeline.clearCaches()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="优四："><a href="#优四：" class="headerlink" title="优四："></a><strong>优四：</strong></h3><p>4、Fresco框架的ImagePipeline设计图<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/fresco1.png" alt="这里写图片描述"><br>从设计图中可以看出，UIThread只做图片的显示和从内存缓存中加载图片这两件事，而其它事情如：图片的Decode、内存缓存的写、硬盘缓存的IO操作、网络操作等都用非UIThread来处理了，这使得UIThread专注界面的显示，而其它工作由其它线程完成，使UI更加流畅。</p>
<h2 id="Fresco中的MVC模式"><a href="#Fresco中的MVC模式" class="headerlink" title="Fresco中的MVC模式"></a><strong>Fresco中的MVC模式</strong></h2><p>Fresco框架整体是一个MVC模式</p>
<blockquote>
<p>DraweeView——View<br>DraweeController——Control<br>DraweeHierarchy——Model</p>
</blockquote>
<p>它们之间的关系大致如下：<br>DraweeHierarchy意为视图的层次结构，用来存储和描述图片的信息，同时也封装了一些图片的显示和视图层级的方法。<br>DraweeView用来显示顶层视图（getTopLevelDrawable()）。DraweeController控制加载图片的配置、顶层显示哪个视图以及控制事件的分发。<br>【注】DraweeView目前版本时继承于ImageView，但这并不意味着我们可以随意的使用ImageView相关的方法（如：setScaleType等），官方并不建议我们使用，因为后期DraweeView将继承于View，所以最好只使用DraweeView控件内置的方法。</p>
<hr>
<h3 id="DraweeHierarchy"><a href="#DraweeHierarchy" class="headerlink" title="DraweeHierarchy"></a><strong>DraweeHierarchy</strong></h3><p>DraweeHierarchy除了描述了视图的信息和存储6种视图外，其中还对我们提供了一些额外的方法，比如：让图片渐渐显示Fade效果、设置默认状态下显示的图片、设置点击时显示的图片和加载失败时显示的图片等方法，这些方法可以在我们加载其它图片时保持一些良好的交互效果，值得注意的是，DraweeHierarchy是一个接口，只提供了一个默认方法：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface DraweeHierarchy &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns the top level drawable in the corresponding hierarchy. Hierarchy should always have</span><br><span class="line">   * the same<span class="instruction"> instance </span>of its top level drawable.</span><br><span class="line">   * @return top level drawable</span><br><span class="line">   */</span><br><span class="line">  Drawable<span class="function"> getTopLevelDrawable(</span><span class="function">)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法从官方注释上来看，是得到当前视图中最顶层的那个Drawable，如：<br>下面这个视图层次最顶层的视图为FadeDrawable</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">o FadeDrawable (top level drawable)</span><br><span class="line">|<span class="string"></span><br><span class="line">+--o ScaleTypeDrawable</span><br><span class="line"></span>|<span class="string">  </span>|</span><br><span class="line">|<span class="string">  +--o BitmapDrawable</span><br><span class="line"></span>|</span><br><span class="line">+--o ScaleTypeDrawable</span><br><span class="line">   |<span class="string"></span><br><span class="line">   +--o BitmapDrawable</span></span><br></pre></td></tr></table></figure>
<p>所以，在Fresco框架中，并不是一个DraweeView只能设置一个图片（Drawable），而是可以设置一个视图图层（类似Android中的LayerDrawable可以设置视图叠加），然后通过DraweeHolder在不同状态下得到（getTopLevelDrawable()）最顶层那个图片从而使得DraweeView显示不同的视图，比如下面这个按下时显示一个overlay（顶层）图片效果：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/fresco2.gif" alt="这里写图片描述"><br>我想这也是Facebook不想把DraweeView这个组件单纯的定义为一个的ImageView的原因吧。</p>
<h3 id="DraweeView"><a href="#DraweeView" class="headerlink" title="DraweeView"></a><strong>DraweeView</strong></h3><p>DraweeView是官方给我们提供显示图片的一个基类，我们在使用过程中大多时候并不需要用到它，而是用到一个官方已经简单封好的SimpleDraweeView类，DraweeView类中提供了与DraweeController和DraweeHierarchy交互的接口，而与它们之间的交互本质上是通过一个DraweeHolder类进行交互，这类DraweeHolder是协调DraweeView、DraweeHierarchy、DraweeController这三个类交互工作的核心类，像平时我们都会这样使用：</p>
<p>比如：配置一个DraweeHierarchy简便起见通常会使用SimpleDraweeView直接设置：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SimpleDraweeView simpleDraweeView = (SimpleDraweeView) findViewById(R.id.drawee_view);</span><br><span class="line">        <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png"</span>);</span><br><span class="line">        simpleDraweeView.setImageURI(uri);</span><br><span class="line">        <span class="comment">//创建一个DraweeHierarchy</span></span><br><span class="line">        GenericDraweeHierarchy hierarchy = <span class="keyword">new</span> GenericDraweeHierarchyBuilder(getResources()).setPlaceholderImage(getDrawable(R.drawable.holder)).build();</span><br><span class="line">        <span class="comment">//设置一个hierarchy</span></span><br><span class="line">simpleDraweeView.setHierarchy(hierarchy);</span><br></pre></td></tr></table></figure>
<p>其实上述方法最终都是通过mController.setHierarchy(hierarchy);来设置的，本质是调用DraweeHolder类封装好的setHierarchy()方法，可以看看其内部：<br>DraweeHolder::setHierarchy()</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setHierarchy</span><span class="params">(DH hierarchy)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mController.setHierarchy(hierarchy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以通过simpleDraweeView.setHierarchy(hierarchy);来设置等价于通过构建一个DraweeController来设置，如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder().<span class="built_in">set</span>Uri(url).<span class="built_in">set</span>Xxx()...build();</span><br><span class="line">//通过DraweeController设置</span><br><span class="line">controller.<span class="built_in">set</span>Hierarchy();</span><br><span class="line">simpleDraweeView.<span class="built_in">set</span>Controller(controller);</span><br></pre></td></tr></table></figure>
<p>这个DraweeHolder类的出现，更准确的定位是降低耦合度、解耦的定位。</p>
<p>对于上面我们知道了通过simpleDraweeView.setHierarchy(hierarchy);来设置等价于通过DraweeController::setHierarchy()来设置，那么simpleDraweeView.setController(controller);有没有等价的呢？答案是没有，<strong>因为要加载图片那么就必须设置一个DraweeController来控制图片的加载</strong>，（当然我们如果设置了SimpleDraweeView的一些属性，那么默认也会创建一个DraweeHierarchy），而我们平时简便的写法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDraweeView simpleDraweeView = (SimpleDraweeView) findViewById(R.id.drawee_view);</span><br><span class="line">        <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png"</span>);</span><br><span class="line">        simpleDraweeView.setImageURI(uri);</span><br></pre></td></tr></table></figure>
<p>这是一段最基本的写法，我们都知道这样设置了Fresco内部就自动会给我们加载图片了，而网上也流传着另外一种加载图片的方法，为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder().setUri(url).build()<span class="comment">;</span></span><br><span class="line">simpleDraweeView.setController(controller)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其实这两种写法都是一种写法，<strong>Fresco真正加载图片仅仅只有这一种方法</strong>，就是通过simpleDraweeView.setController(controller);来设置，只不过我们可以对DraweeController和DraweeHierarchy做各种各样的配置来达到我们想要的效果，我们可以看看simpleDraweeView.setImageURI(uri);的源码，其实还是通过setController(controller);设置一个控制器来控制图片的加载，源码为：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">set</span>ImageURI(Uri uri, @Nullable Object callerContext) &#123;</span><br><span class="line">  DraweeController controller = mSimpleDraweeControllerBuilder</span><br><span class="line">      .<span class="built_in">set</span>CallerContext(callerContext)</span><br><span class="line">      .<span class="built_in">set</span>Uri(uri)</span><br><span class="line">      .<span class="built_in">set</span>OldController(getController())</span><br><span class="line">      .build();</span><br><span class="line">  <span class="built_in">set</span>Controller(controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，<strong>使用Fresco通用的写法便是：</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleDraweeView simpleDraweeView = (SimpleDraweeView) findViewById(R.id.drawee_view);</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png"</span>);</span><br><span class="line"></span><br><span class="line">GenericDraweeHierarchy hierarchy = new GenericDraweeHierarchyBuilder(getResources())</span><br><span class="line">        .<span class="built_in">set</span>FadeDuration(<span class="number">400</span>)</span><br><span class="line">        .<span class="built_in">set</span>PlaceholderImage(getDrawable(R.drawable.holder))</span><br><span class="line">        .<span class="built_in">set</span>FailureImage(getDrawable(R.drawable.fail))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder().<span class="built_in">set</span>Uri(uri).<span class="built_in">set</span>OldController(simpleDraweeView.getController()).build();</span><br><span class="line">controller.<span class="built_in">set</span>Hierarchy(hierarchy);</span><br><span class="line"></span><br><span class="line">simpleDraweeView.<span class="built_in">set</span>Controller(controller);</span><br></pre></td></tr></table></figure>
<p>或者直接使用ImageRequet:</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageRequest</span> imageRequest = <span class="type">ImageRequestBuilder</span>.newBuilderWithSource(<span class="type">Uri</span>.parse(url)).build<span class="literal">()</span>;</span><br><span class="line"><span class="type">DraweeController</span> draweeController = <span class="type">Fresco</span>.newDraweeControllerBuilder<span class="literal">()</span>.setImageRequest(imageRequest).setOldController(simpleDraweeView.getController<span class="literal">()</span>).build<span class="literal">()</span>;</span><br><span class="line">simpleDraweeView.setController(controller);</span><br></pre></td></tr></table></figure>
<p>当然配置其它属性只要设置Controller和Hierarchy相应的方法即可。<br>【<strong>注</strong>】：上面中用到了一个这个方法simpleDraweeView.getController();当然也还有simpleDraweeView.getHierarchy();，这两个方法是返回当前DraweeView所设置的Control和Hierarchy，使用这两个方法的好处是复用以前创建的Control和Hierarchy对象，因为重新创建一个对象肯定不如复用好，而且创建相对耗时，所以官方也建议我们复用这两个对象。如果你用simpleDraweeView.getHierarchy()来加载图片，那么它将不可能为空，除非你什么不设置，而getController()则可能为空，所以在使用工厂方法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Fresco</span><span class="class">.newDraweeControllerBuilder</span>()<span class="class">.setUri</span>(<span class="tag">uri</span>)<span class="class">.setOldController</span>(<span class="tag">simpleDraweeView</span><span class="class">.getController</span>())<span class="class">.build</span>();</span><br></pre></td></tr></table></figure>
<p>来创建一个DraweeController的时候给它配置一个setOldController()，如果这里面这个参数为null，那么就会重新创建一个DraweeController，如果不为空则复用当前传入的。</p>
<hr>
<p>顺便说一句，直接使用SimpleDraweeView就足够了，毕竟配置功能都落在DraweeController和DraweeHierarchy身上，SimpleDraweeView仅仅起个显示最顶层视图的作用。</p>
<h3 id="DraweeController"><a href="#DraweeController" class="headerlink" title="DraweeController"></a><strong>DraweeController</strong></h3><p>关于DraweeController，好像在上面已经讲的差不多了，它主要就是起个控制图片的加载和配置以及决定顶层显示哪个视图的作用，其它的它也可以设置设置个ControllerListener来监听图片加载的进度，也可以配置一个ImageRequest来设置渐进式JPEG图片的加载，具体使用可以看其官方文档。</p>
<h2 id="认识Fresco中的视图层次"><a href="#认识Fresco中的视图层次" class="headerlink" title="认识Fresco中的视图层次"></a><strong>认识Fresco中的视图层次</strong></h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>     o FadeDrawable (top level drawable)</span><br><span class="line"><span class="keyword">*</span>     |<span class="string"></span><br><span class="line">*     +--o ScaleTypeDrawable</span><br><span class="line">*     </span>|<span class="string">  </span>|</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">  +--o Drawable (placeholder image)</span><br><span class="line">*     </span>|</span><br><span class="line"><span class="keyword">*</span>     +--o ScaleTypeDrawable</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">  </span>|</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">  +--o SettableDrawable</span><br><span class="line">*     </span>|<span class="string">     </span>|</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">     +--o Drawable (actual image)</span><br><span class="line">*     </span>|</span><br><span class="line"><span class="keyword">*</span>     +--o ScaleTypeDrawable</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">  </span>|</span><br><span class="line"><span class="keyword">*</span>     |<span class="string">  +--o Drawable (retry image)</span><br><span class="line">*     </span>|</span><br><span class="line"><span class="keyword">*</span>     +--o ScaleTypeDrawable</span><br><span class="line"><span class="keyword">*</span>        |<span class="string"></span><br><span class="line">*        +--o Drawable (failure image)</span></span><br></pre></td></tr></table></figure>
<p>Fresco中对于DraweeHierarchy视图层次的描述中，视图层次的结构为6种不同的视图，依次为顶层Drawable（可用FadeDrawable配置显示效果）、默认显示的Drawable、实际的Drawable（其中有一层可设置的Drawable包裹它作为对我们实际加载到的Drawable进行配置）、重试的Drawable、加载失败的Drawable。</p>
<p>上面这种层次从GenericDraweeHierarchy源码中就有所体现，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Drawable mEmptyPlaceholderDrawable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Drawable mEmptyActualImageDrawable = <span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Drawable mEmptyControllerOverlayDrawable = <span class="keyword">new</span> ColorDrawable(Color.TRANSPARENT);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RootDrawable mTopLevelDrawable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FadeDrawable mFadeDrawable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SettableDrawable mActualImageSettableDrawable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPlaceholderImageIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mProgressBarImageIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mActualImageIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mRetryImageIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mFailureImageIndex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mControllerOverlayIndex;</span><br></pre></td></tr></table></figure>
<p>上述定义了不同功能的Drawable，比如FadeDrawable和SettableDrawable都是可以对视图进行配置。而也定义了6个int下标，这6个int类型的下标主要就是用于存储视图层次中各个Drawable中的位置，都是用一个Drawable[]  layers ；数组进行存储的：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layers<span class="string">[mPlaceholderImageIndex]</span> = placeholderImageBranch;</span><br><span class="line">   layers<span class="string">[mActualImageIndex]</span> = actualImageBranch;</span><br><span class="line">   layers<span class="string">[mProgressBarImageIndex]</span> = progressBarImageBranch;</span><br><span class="line">   layers<span class="string">[mRetryImageIndex]</span> = retryImageBranch;</span><br><span class="line">   layers<span class="string">[mFailureImageIndex]</span> = failureImageBranch;</span><br><span class="line">   layers<span class="string">[mControllerOverlayIndex]</span> = mEmptyControllerOverlayDrawable;</span><br></pre></td></tr></table></figure>
<p>这些存储着视图层次资源的layers数组将会由ArrayDrawable类进行管理和绘制，最终将需要显示的视图回调给RootDrawable::mTopLevelDrawable。</p>
<h2 id="ImagePipelineConfig"><a href="#ImagePipelineConfig" class="headerlink" title="ImagePipelineConfig"></a><strong>ImagePipelineConfig</strong></h2><p>我们对Fresco进行初始化时，有两种方式：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fresco.initialize(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">      ImagePipelineConfig pipelineConfig = ImagePipelineConfig.newBuilder(getApplicationContext()).build();</span><br><span class="line">      Fresco.initialize(<span class="keyword">this</span>,pipelineConfig);</span><br></pre></td></tr></table></figure>
<p>对于不对ImagePipeline进行配置的话，Fresco将采用默认的配置，而默认的配置到底配置了哪些信息这个我们要清楚。<br>对于ImagePipelineConfig我们主要可以配置以下属性：</p>
<p>1、Bitmap.Config mBitmapConfig ——<strong>所加载图片的配置</strong>，默认为Bitmap.Config.ARGB_8888</p>
<p>2、Supplier&lt;<strong>MemoryCacheParams</strong>&gt; mBitmapMemoryCacheParamsSupplier——<strong>已解码图片的内存缓存</strong>，默认配置：缓存容量最大存储256个Bitmap元素，缓存大小是根据最大可用内存来动态改变的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxCacheSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  final <span class="keyword">int</span> maxMemory =</span><br><span class="line">      Math.min(mActivityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);</span><br><span class="line">  <span class="keyword">if</span> (maxMemory &lt; <span class="number">32</span> * ByteConstants.MB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * ByteConstants.MB;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxMemory &lt; <span class="number">64</span> * ByteConstants.MB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span> * ByteConstants.MB;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We don't want to use more ashmem on Gingerbread for now, since it doesn't respond well to</span></span><br><span class="line">    <span class="comment">// native memory pressure (doesn't throw exceptions, crashes app, crashes phone)</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">8</span> * ByteConstants.MB;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> maxMemory / <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、mDecodeMemoryFileEnabled——是否根据不同的平台来构建相应的解码器，默认为false。所以我们需要设置为true。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">PlatformDecoder <span class="title">buildPlatformDecoder</span><span class="params">(</span><br><span class="line">    PoolFactory poolFactory,</span><br><span class="line">    <span class="keyword">boolean</span> decodeMemoryFileEnabled)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArtDecoder(</span><br><span class="line">        poolFactory.getBitmapPool(),</span><br><span class="line">        poolFactory.getFlexByteArrayPoolMaxNumThreads());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (decodeMemoryFileEnabled &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GingerbreadPurgeableDecoder();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> KitKatPurgeableDecoder(poolFactory.getFlexByteArrayPool());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、mDownsampleEnabled——设置EncodeImage解码时是否解码图片样图，必须和ImageRequest的ResizeOptions一起使用，作用就是在图片解码时根据ResizeOptions所设的宽高的像素进行解码，这样解码出来可以得到一个更小的Bitmap。通过在Decode图片时，来改变采样率来实现得，使其采样ResizeOptions大小。<br><strong>ResizeOptions和DownsampleEnabled参数都不影响原图片的大小，影响的是EncodeImage的大小，进而影响Decode出来的Bitmap的大小，ResizeOptions须和此参数结合使用是因为单独使用ResizeOptions的话只支持JPEG图，所以需支持png、jpg、webp需要先设置此参数。</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JobRunnable job = <span class="keyword">new</span> JobRunnable() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(EncodedImage encodedImage, <span class="keyword">boolean</span> isLast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (encodedImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mDownsampleEnabled) &#123;</span><br><span class="line">        ImageRequest request = producerContext.getImageRequest();</span><br><span class="line">        <span class="keyword">if</span> (mDownsampleEnabledForNetwork ||</span><br><span class="line">            !UriUtil.isNetworkUri(request.getSourceUri())) &#123;</span><br><span class="line">          encodedImage.setSampleSize(DownsampleUtil.determineSampleSize(</span><br><span class="line">              request, encodedImage));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      doDecode(encodedImage, isLast);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5、mEncodedMemoryCacheParamsSupplier——编码图片的内存缓存。缓存大小默认是通过app运行时最大内存决定的，且最多可存储<strong>getMaxCacheSize()/8</strong>个缓存元素，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxCacheSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  final <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) Math.min(Runtime.getRuntime().maxMemory(), Integer.MAX_VALUE);</span><br><span class="line">  <span class="keyword">if</span> (maxMemory &lt; <span class="number">16</span> * ByteConstants.MB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * ByteConstants.MB;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxMemory &lt; <span class="number">32</span> * ByteConstants.MB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * ByteConstants.MB;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * ByteConstants.MB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要自己改造那么就自己实现Supplier接口。<br>6、mImageCacheStatsTracker——缓存的统计数据追踪器。它是一个接口，提供了各个缓存中图片Hit与Miss的回调方法，通常可以使用它来统计缓存命中率，默认情况下Fresco提供了一个NoOp无操作的实现类，我们若是需要使用此功能，必须我们实现ImageCacheStatsTracker接口，在各个回调方法处理。各个方法回调的顺序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.170</span> <span class="number">25920</span>-<span class="number">25920</span>/com.sunzxy.myapplication E/zxy: zxy:registerBitmapMemoryCache</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.170</span> <span class="number">25920</span>-<span class="number">25920</span>/com.sunzxy.myapplication E/zxy: zxy:registerEncodedMemoryCache</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.330</span> <span class="number">25920</span>-<span class="number">25920</span>/com.sunzxy.myapplication E/zxy: zxy:onBitmapCacheMiss</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.330</span> <span class="number">25920</span>-<span class="number">25958</span>/com.sunzxy.myapplication E/zxy: zxy:onBitmapCacheMiss</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.340</span> <span class="number">25920</span>-<span class="number">25958</span>/com.sunzxy.myapplication E/zxy: zxy:onMemoryCacheMiss</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.340</span> <span class="number">25920</span>-<span class="number">25960</span>/com.sunzxy.myapplication E/zxy: zxy:onStagingAreaMiss</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.360</span> <span class="number">25920</span>-<span class="number">25960</span>/com.sunzxy.myapplication E/zxy: zxy:onDiskCacheHit</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.360</span> <span class="number">25920</span>-<span class="number">25960</span>/com.sunzxy.myapplication E/zxy: zxy:onMemoryCachePut</span><br><span class="line"><span class="number">12</span>-<span class="number">25</span> <span class="number">15</span>:<span class="number">36</span>:<span class="number">35.380</span> <span class="number">25920</span>-<span class="number">25965</span>/com.sunzxy.myapplication E/zxy: zxy:BitmapCachePut</span><br></pre></td></tr></table></figure>
<p>每次请求图片时，都会走这个路径，当在各个缓存中hit时，将回调对应得方法，然后在hit时会将图片分别添加至Encode和Decode缓存。<br>7、mMainDiskCacheConfig——硬盘缓存的配置，默认缓存目录在app自身CacheDir的image_cache目录下，其中设置了三个必备的属性，分别为：最大缓存大小、在低内存设备下的缓存大小、在极低内存设备下的缓存大小。默认值为40M、10M、2M。<br>这是配置一个DiskCacheConfig的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DiskCacheConfig.newBuilder()</span><br><span class="line">        .setBaseDirectoryPathSupplier(</span><br><span class="line">            <span class="keyword">new</span> Supplier&lt;File&gt;() &#123;</span><br><span class="line">              @<span class="function">Override</span><br><span class="line">              <span class="keyword">public</span> File <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> context.getApplicationContext().getCacheDir();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        .setBaseDirectoryName(<span class="string">"image_cache"</span>)</span><br><span class="line">        .setMaxCacheSize(<span class="number">40</span> * ByteConstants.MB)</span><br><span class="line">        .setMaxCacheSizeOnLowDiskSpace(<span class="number">10</span> * ByteConstants.MB)</span><br><span class="line">        .setMaxCacheSizeOnVeryLowDiskSpace(<span class="number">2</span> * ByteConstants.MB)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>8、mMemoryTrimmableRegistry——注册一个内存调节器，它将根据不同的MemoryTrimType回收类型在需要降低内存使用时候进行回收一些内存缓存资源(Bitmap和Encode)。默认传入NoOp无操作的一个实现类。<br>我们自己实现需要实现MemoryTrimmableRegistry接口，然后在它的两个方法中根据自身需求进行MemoryTrimType的赋值来决定是采取哪个清除策略来回收内存缓存资源。MemoryTrimType是一个枚举，类型共有四个：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum MemoryTrimType &#123;</span><br><span class="line"></span><br><span class="line">  /** The <span class="type">application</span> <span class="keyword">is</span> approaching <span class="keyword">the</span> device-specific Java heap limit. */</span><br><span class="line">  OnCloseToDalvikHeapLimit(<span class="number">0.5</span>),</span><br><span class="line"></span><br><span class="line">  /** The system <span class="keyword">as</span> a whole <span class="keyword">is</span> <span class="property">running</span> <span class="keyword">out of</span> memory, <span class="keyword">and</span> this <span class="type">application</span> <span class="keyword">is</span> <span class="keyword">in</span> <span class="keyword">the</span> foreground. */</span><br><span class="line">  OnSystemLowMemoryWhileAppInForeground(<span class="number">0.5</span>),</span><br><span class="line"></span><br><span class="line">  /** The system <span class="keyword">as</span> a whole <span class="keyword">is</span> <span class="property">running</span> <span class="keyword">out of</span> memory, <span class="keyword">and</span> this <span class="type">application</span> <span class="keyword">is</span> <span class="keyword">in</span> <span class="keyword">the</span> background. */</span><br><span class="line">  OnSystemLowMemoryWhileAppInBackground(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">  /** This app <span class="keyword">is</span> moving <span class="keyword">into</span> <span class="keyword">the</span> background, usually because <span class="keyword">the</span> user navigated <span class="keyword">to</span> another app. */</span><br><span class="line">  OnAppBackgrounded(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己实现得内存调节器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMemoryTrimmableRegistry</span> <span class="keyword">implements</span> <span class="title">MemoryTrimmableRegistry</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerMemoryTrimmable</span><span class="params">(MemoryTrimmable trimmable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">trimmable.trim(MemoryTrimType.OnSystemLowMemoryWhileAppInBackground);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterMemoryTrimmable</span><span class="params">(MemoryTrimmable trimmable)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Fresco并没有对unregister方法进行回调，其中MemoryTrimmable是一个接口，它只有一个方法trim()，就是回收内存缓存资源的，它的实现不需要我们自己写，而是在CountingMemoryCache类中帮我们实现好了，CountingMemoryCache是一个基于LRU策略来管理缓存中元素的一个类，它实现的trim()方法可以根据Type的不同来采取不同策略的回收为：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">(MemoryTrimType trimType)</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span> trimRatio = mCacheTrimStrategy.getTrimRatio(trimType);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> targetCacheSize = (<span class="keyword">int</span>) (mCachedEntries.getSizeInBytes() * (<span class="number">1</span> - trimRatio));</span><br><span class="line">    <span class="keyword">int</span> targetEvictionQueueSize = Math.max(<span class="number">0</span>, targetCacheSize - getInUseSizeInBytes());</span><br><span class="line">    oldEntries = trimExclusivelyOwnedEntries(Integer.MAX_VALUE, targetEvictionQueueSize);</span><br><span class="line">    makeOrphans(oldEntries);</span><br><span class="line">  &#125;</span><br><span class="line">  maybeClose(oldEntries);</span><br><span class="line">  maybeNotifyExclusiveEntryRemoval(oldEntries);</span><br><span class="line">  maybeUpdateCacheParams();</span><br><span class="line">  maybeEvictEntries();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trim()方法中主要就是做了这么一件事：根据Type的不同来回收不同比例的内存缓存中最近未被使用的元素。体现在下面这行代码：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> targetEvictionQueueSize = Math.<span class="built_in">max</span>(<span class="number">0</span>, targetCacheSize - getInUseSizeInBytes())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>9、mNetworkFetcher——网络图片下载请求类，底层网络请求默认使用HttpUrlConnection，并且使用一个固定线程数为3的线程池来管理请求。也可以使用Volley和Okhttp进行扩展，官方默认已经实现好了，如需使用可以参考官方文档引入额外jar包。<br>10、mProgressiveJpegConfig——渐进式显示网络的JPEG图的配置，默认传入一个SimpleProgressiveJpegConfig，通常使用默认配置即可，图片加载时会从模糊慢慢的到清晰的一个显示过程，不过要使用渐进式显示图片，需要在ImageRequest中显示的设置是否支持渐进式显示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ImageRequest</span> request = ImageRequestBuilder</span><br><span class="line">    .setProgressiveRenderingEnabled(<span class="built_in">true</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>说明一点，渐进式显示的效果和渐入图片显示效果是两码事，渐进式使用的策略是在通过设置统计扫描数，当扫描数大于某个阀值时，然后进行解码一次并显示图片，最后扫描数为峰值时，进行最后一次解码，这样就显示出清晰的图片了，也就是说它是采用断点解码的。而渐入显示效果则是通过属性动画来改变alpha属性来显示图片的。<br>11、mResizeAndRotateEnabledForNetwork——最终影响的是mDownsampleEnabledForNetwork参数。<br>这个参数的作用是在mDownsampleEnabled为true的情况下，设置是否当这次请求是从网络中加载图片时，来对EncodeImage重新改变大小。也就是说设置了这个为true，可以在从网络中加载图片时候根据Resizing参数Decode出更小的样图，具体是在Decode时通过采样Resizing的像素来实现的。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (encodedImage != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mDownsampleEnabled) &#123;</span><br><span class="line">    ImageRequest <span class="built_in">request</span> = producerContext.getImageRequest();</span><br><span class="line">    <span class="keyword">if</span> (mDownsampleEnabledForNetwork ||</span><br><span class="line">        !UriUtil.isNetworkUri(<span class="built_in">request</span>.getSourceUri())) &#123;</span><br><span class="line">      encodedImage.setSampleSize(DownsampleUtil.determineSampleSize(</span><br><span class="line">          <span class="built_in">request</span>, encodedImage));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  doDecode(encodedImage, isLast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思为：mDownsampleEnabled为true的前提下，在第一次加载图片时候，是从网络中加载，这时</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!UriUtil.<span class="function"><span class="title">isNetworkUri</span><span class="params">(request.getSourceUri()</span></span>)</span><br></pre></td></tr></table></figure>
<p>肯定为false，所以默认不支持对网络中加载的图片的EncodeImage的改变。当以后加载该图片并解析时，由于应用重新启动或者在后台中启动，这时是从硬盘中加载的，这时Uri肯定为Local的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!UriUtil.<span class="function"><span class="title">isNetworkUri</span><span class="params">(request.getSourceUri()</span></span>)</span><br></pre></td></tr></table></figure>
<p>肯定为true，所以可以从本地加载并解析出<strong><code>sampleBitmap</code></strong>。<strong>所以设置mDownsampleEnabledForNetwork为ture，这样无论是从网络还是本地都可以改变EncodeImage的大小，在图片Decode的时候解析出更小的<code>sampleBitmap</code>。</strong></p>
<p>12、mSmallImageDiskCacheConfig——小图的硬盘缓存配置，默认传入mMainDiskCacheConfig，和主硬盘缓存目录是共用的。如果需要把小图和普通图片分开，则需重新配置。</p>
<p>13、mExecutorSupplier——执行各个任务的线程池配置，包括配置执行IO任务、后台任务、优先级低的后台任务、Decode任务的线程池的配置。这些线程池Fresco默认都配置为Fix固定线程数量的。</p>
<blockquote>
<p>mDecodeExecutor——负责图片解码成Bitmap的线程池，最大并发数为CPU的数量。<br>mIoBoundExecutor——负责从硬盘缓存中读取缓存图片的IO线程池，最大并发数为2。<br>mBackgroundExecutor——负责后台的线程任务，一般是负责图片的resize和旋转、webp的转码、后处理器的执行，最大并发数为CPU数量。<br>mLightWeightBackgroundExecutor——低优先级的后台线程任务，最大并发数为1。</p>
</blockquote>
<p>没有什么特别需求，这些后台任务的线程池配置一般用默认的即可，默认的已经差不多做到极致了。</p>
<h2 id="ImagePipeline"><a href="#ImagePipeline" class="headerlink" title="ImagePipeline"></a><strong>ImagePipeline</strong></h2><p>Image pipeline是Fresco中负责图片加载的，它支持从本地和网络中加载，文件加载支持：File、content、asset、res目录下的文件，网络加载支持http和https，支持的图片格式有：PNG、GIF、WebP、JPEG。<br>获取ImagePipeline可以通过Fresco的静态工厂方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImagePipeline ipl = Fresco.<span class="function"><span class="title">getImagePipeline</span><span class="params">()</span></span>；</span><br></pre></td></tr></table></figure>
<p>或者通过ImagePipelineFactory的工厂方法：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImagePipeline</span>  ipl =<span class="type">ImagePipelineFactory</span>.getInstance<span class="literal">()</span>.getImagePipeline<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="监听图片下载进度"><a href="#监听图片下载进度" class="headerlink" title="监听图片下载进度"></a><strong>监听图片下载进度</strong></h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ControllerListener controllerListener = <span class="keyword">new</span> BaseControllerListener&lt;ImageInfo&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onFinalImageSet(</span><br><span class="line">        <span class="built_in">String</span> id,</span><br><span class="line">        <span class="annotation">@Nullable</span> ImageInfo imageInfo,</span><br><span class="line">        <span class="annotation">@Nullable</span> Animatable anim) &#123;</span><br><span class="line">      <span class="keyword">if</span> (imageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      QualityInfo qualityInfo = imageInfo.getQualityInfo();</span><br><span class="line">      FLog.d(<span class="string">"Final image received! "</span> + </span><br><span class="line">          <span class="string">"Size %d x %d"</span>,</span><br><span class="line">          <span class="string">"Quality level %d, good enough: %s, full quality: %s"</span>,</span><br><span class="line">          imageInfo.getWidth(),</span><br><span class="line">          imageInfo.getHeight(),</span><br><span class="line">          qualityInfo.getQuality(),</span><br><span class="line">          qualityInfo.isOfGoodEnoughQuality(),</span><br><span class="line">          qualityInfo.isOfFullQuality());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> </span><br><span class="line">    public <span class="keyword">void</span> onIntermediateImageSet(<span class="built_in">String</span> id, <span class="annotation">@Nullable</span> ImageInfo imageInfo) &#123;</span><br><span class="line">      FLog.d(<span class="string">"Intermediate image received"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> onFailure(<span class="built_in">String</span> id, Throwable throwable) &#123;</span><br><span class="line">      FLog.e(getClass(), throwable, <span class="string">"Error loading %s"</span>, id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Uri</span> uri;</span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    .setControllerListener(controllerListener)</span><br><span class="line">    .setUri(uri);</span><br><span class="line">    <span class="comment">// other setters</span></span><br><span class="line">    .build();</span><br><span class="line">mSimpleDraweeView.setController(controller);</span><br></pre></td></tr></table></figure>
<p>其中三个回调函数：</p>
<blockquote>
<p>onFinalImageSet——在加载成功时回调<br>onFailure——在加载失败时回调<br>onIntermediateImageSet——在显示渐进式JPEG图片时，这个函数会在每个扫描被解码后回调</p>
</blockquote>
<h2 id="Fresco的多图请求"><a href="#Fresco的多图请求" class="headerlink" title="Fresco的多图请求"></a><strong>Fresco的多图请求</strong></h2><p>假如你需要加载一张大图，这通常会比较耗时，此时你可以先下载一张缩略图先显示，待大图下载完后则显示大图。这样用户体验会好很多</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri lowResUri, highResUri;</span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    .<span class="built_in">set</span>LowResImageRequest(ImageRequest.<span class="keyword">from</span>Uri(lowResUri))</span><br><span class="line">    .<span class="built_in">set</span>ImageRequest(ImageRequest.<span class="keyword">from</span>Uri(highResUri))</span><br><span class="line">    .<span class="built_in">set</span>OldController(mSimpleDraweeView.getController())</span><br><span class="line">    .build();</span><br><span class="line">mSimpleDraweeView.<span class="built_in">set</span>Controller(controller);</span><br></pre></td></tr></table></figure>
<h3 id="图片复用"><a href="#图片复用" class="headerlink" title="图片复用"></a><strong>图片复用</strong></h3><p>假如有一张图片，本地和服务端都存在。就比如用户上传头像，会在服务器存一张，而本地也本身就有，所以当加载用户头像时，可以设置两个Uri，本地和网络，当在本地找到时就不必去服务端加载了，达到复用的效果</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Uri uri1, uri2<span class="comment">;</span></span><br><span class="line">ImageRequest request = ImageRequest.fromUri(uri1)<span class="comment">;</span></span><br><span class="line">ImageRequest request2 = ImageRequest.fromUri(uri2)<span class="comment">;</span></span><br><span class="line">ImageRequest[] requests = &#123; request1, request2 &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">DraweeController controller = Fresco.newDraweeControllerBuilder()</span><br><span class="line">    .setFirstAvailableImageRequests(requests)</span><br><span class="line">    .setOldController(mSimpleDraweeView.getController())</span><br><span class="line">    .build()<span class="comment">;</span></span><br><span class="line">mSimpleDraweeView.setController(controller)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="图片的缩放和旋转"><a href="#图片的缩放和旋转" class="headerlink" title="图片的缩放和旋转"></a><strong>图片的缩放和旋转</strong></h2><h3 id="1、BitmapFactory-Options的inSampleSize"><a href="#1、BitmapFactory-Options的inSampleSize" class="headerlink" title="1、BitmapFactory.Options的inSampleSize"></a><strong>1、BitmapFactory.Options的inSampleSize</strong></h3><p>这种方式对图片进行解码压缩，一系列操作都是通过native层的c/c++代码进行的，所以进行压缩过后Bitmap所占用的空间大小会比原来的小很多。</p>
<pre><code>应用场景：通常使用在图片的压缩上，先用inJustDecodeBounds获取图片的宽高大小，通过判断图片是否过大来进行压缩。
</code></pre><h3 id="2、View的Scale"><a href="#2、View的Scale" class="headerlink" title="2、View的Scale"></a><strong>2、View的Scale</strong></h3><p>这种方式的缩放就是通过绘制（Canvas）来实现得，通常我们在动画方面用的较多，这种方式的特点只是单纯的对Bitmap进行放大或缩小的绘制，而实际上Bitmap所占用的内存空间在Bitmap放大、缩小和原始状态时的完全一样，并不能实际的改变内存的占用。</p>
<pre><code>应用场景：如果图片本身不大的话，建议使用它，因为它的速度更快，而且输出的也是高质量的图。图片若是过大，则使用其它。
</code></pre><h3 id="3、Fresco的Resizing"><a href="#3、Fresco的Resizing" class="headerlink" title="3、Fresco的Resizing"></a><strong>3、Fresco的Resizing</strong></h3><p>通过改变EncodeImage的大小来实现的，使用它重新resize的图片占用的内存通常是原始图片占用的1/8，目前只支持JPEG格式图片，所以目前都是与Downsampling结合使用来支持jpg、png、webp格式图片。</p>
<pre><code>应用场景：ImageRequest中的参数，与ImagePipelineConfig中的Downsampling结合使用，Fresco内置方法。
</code></pre><p>###4、Fresco的Downsampling<br>通过在Decode图片时，来改变采样率来实现得，使其采样EncodeImage的sampleSize的大小，这样Downsampling就变成了Decode过程中的一部分，只需改变Decode过程中对像素点的采样率就行，而不必新生成一份EncodeImage，而采样率则是建立在Resizing的宽高大小上，通过Resizing的宽高来决定采样的部分的像素点。比Resizing更快。</p>
<pre><code>应用场景：和Resizing结合使用，不过在4.4版本中Decode出采样图将会占用更多的内存资源，这是个bug。
</code></pre><h2 id="Fresco混淆配置"><a href="#Fresco混淆配置" class="headerlink" title="Fresco混淆配置"></a><strong>Fresco混淆配置</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Keep</span> our interfaces so they can be used by other <span class="type">ProGuard</span> rules.</span><br><span class="line"># <span class="type">See</span> http:<span class="comment">//sourceforge.net/p/proguard/bugs/466/</span></span><br><span class="line">-keep,allowobfuscation <span class="annotation">@interface</span> com.facebook.common.internal.<span class="type">DoNotStrip</span></span><br><span class="line"></span><br><span class="line"># <span class="type">Do</span> not strip any method/<span class="class"><span class="keyword">class</span> <span class="title">that</span> <span class="title">is</span> <span class="title">annotated</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">@DoNotStrip</span></span><br><span class="line"></span>-keep <span class="annotation">@com</span>.facebook.common.internal.<span class="type">DoNotStrip</span> <span class="class"><span class="keyword">class</span> <span class="title">*</span></span><br><span class="line"></span>-keepclassmembers <span class="class"><span class="keyword">class</span> <span class="title">*</span> &#123;</span></span><br><span class="line">    <span class="annotation">@com</span>.facebook.common.internal.<span class="type">DoNotStrip</span> *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="type">Keep</span> native methods</span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> <span class="title">*</span> &#123;</span></span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-dontwarn okio.**</span><br><span class="line">-dontwarn javax.annotation.**</span><br><span class="line">-dontwarn com.android.volley.toolbox.**</span><br></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><p><a href="http://frescolib.org/docs/requesting-multiple-images.html#_" target="_blank" rel="external">Fresco官方文档</a><br><a href="https://github.com/Sunzxyong/FrescoPlus" target="_blank" rel="external">Fresco二次封装</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流行的网络框架&quot;&gt;&lt;a href=&quot;#流行的网络框架&quot; class=&quot;headerlink&quot; title=&quot;流行的网络框架&quot;&gt;&lt;/a&gt;&lt;strong&gt;流行的网络框架&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;目前流行的网络图片框架：&lt;br&gt;Picasso、Universal Image Loader、Volley的(ImageLoader、NetworkImageView)、Glide和Fresco&lt;/p&gt;
&lt;p&gt;简明的介绍下（具体细节和功能可看源码和wiki）：&lt;br&gt;其中Picasso和Universal Image Loader相比其它的算是最轻量级的图片框架了，它们拥有较少的方法数，Universal Image Loader是这五个框架中定制性最强的，它内部实现还是按网络框架的套路走：HttpUrlConnection+线程池+Handler，支持渐显效果。&lt;br&gt;而Picasso只有一些图片加载框架应有的基本功能，所以因此它是最轻量的，在需求只要基本的图片加载与双缓存功能下，可以选Picasso作为项目的基础库，Picasso它内部默认是使用OkHttpClient作为加载网络图片的下载器，毕竟不用自家用谁的，在OkHttpClient没有的情况下则使用HttpUrlConnection，同上面一样，下载器+线程池+Handler，不过它内部的线程池比较有意思，线程池的线程数量是根据当前的网络环境来动态改变的，wifi网络下为4，4G为3，3G为2，2G为1，其它情况下默认为3，支持渐显效果。&lt;br&gt;Volley的没什么可说的，基本功能都有，网络框架的附赠功能。&lt;/p&gt;
&lt;p&gt;Glide的话，Google官方推荐，支持Gif、图片缩略图、本地视频解码、请求和动画生命周期的自动管理、渐显动画、支持OkHttp和Volley等等，默认是使用HttpUrlConnection加载图片的，源码灰常多，200多个类，不想看&lt;/p&gt;
&lt;p&gt;Fresco我认为是这几个框架中性能最佳的一个框架，着重介绍，它内部用了大量的建造者模式、单例模式、静态工厂模式、生产/消费者模式。内部实现比较复杂，就拿图片加载来说，是通过在异步线程中回调图片的输入流，然后通过一系列读取、写入、转化成EncodedImage，然后再Decode成Bitmap，通过Handler转给UI线程显示，通过IO操作存储在硬盘缓存目录下。&lt;br&gt;
    
    </summary>
    
      <category term="技术沉淀" scheme="http://zhengxiaoyong.me/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/"/>
    
    
      <category term="Fresco原理" scheme="http://zhengxiaoyong.me/tags/Fresco%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之被忽视的优化点</title>
    <link href="http://zhengxiaoyong.me/2015/11/25/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9/"/>
    <id>http://zhengxiaoyong.me/2015/11/25/Android性能优化之被忽视的优化点/</id>
    <published>2015-11-25T07:42:30.000Z</published>
    <updated>2016-04-24T05:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于性能优化这个知识点来说，实在是太广了，博主本人也一直非常关注这方面的学习，而对于性能优化来说它包括了非常非常非常多方面，比如：I/O的优化、网络操作的优化、内存的优化、数据结构的优化、代码层次的优化、UI渲染优化、CPU资源使用率的优化、异常处理的优化等等等等。。。</p>
<p>本篇文章就博主本人的理解来讲述一些在Android开发中可以优化的地方</p>
<h2 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a><strong>ArrayList和Vector</strong></h2><p>ArrayList和Vector都是内部以数组实现的List，它们两唯一的区别就是对多线程的支持，ArrayList是线程不安全的，而Vector内部对大多数方法都做了同步，是线程安全的，既然是线程安全的，所以性能方面肯定不如ArrayList了（当然想法肯定是对的），不过这需要看哪方面了，ArrayList在add、get、remove等操作效率肯定是高于Vector的，而在内存方面，Vector却比ArrayList表现的更好，这归根都是ArrayList的扩容策略导致的，稍后分析<br><a id="more"></a></p>
<h3 id="实现RandomAccess接口的集合使用fori遍历"><a href="#实现RandomAccess接口的集合使用fori遍历" class="headerlink" title="实现RandomAccess接口的集合使用fori遍历"></a><strong>实现RandomAccess接口的集合使用fori遍历</strong></h3><p>先谈谈List集合的遍历方式，有三种：foreach、iterator、fori。<br>而在开发中一般需要遍历时首选肯定是foreach了，因为它效率高，这个观点没错，不过需要分场合了。<br>下面是我用这三种方式测试遍历有100w条数据的ArrayList集合：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    data.get(i);</span><br><span class="line">&#125;</span><br><span class="line">long <span class="keyword">end</span> = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="type">Log</span>.v(<span class="string">"zxy"</span>,<span class="string">"fori花费:"</span>+(<span class="keyword">end</span>-start));</span><br><span class="line"></span><br><span class="line">start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">Integer</span> integer : data) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">end</span> = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="type">Log</span>.v(<span class="string">"zxy"</span>,<span class="string">"foreach花费:"</span>+(<span class="keyword">end</span>-start));</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span>&lt;<span class="type">Integer</span>&gt; <span class="keyword">iterator</span> = data.<span class="keyword">iterator</span>();</span><br><span class="line">start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext())&#123;</span><br><span class="line">    <span class="keyword">iterator</span>.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">end</span> = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"><span class="type">Log</span>.v(<span class="string">"zxy"</span>,<span class="string">"iterator花费:"</span>+(<span class="keyword">end</span>-start));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">11</span>:<span class="number">44.276</span> <span class="number">1418</span>-<span class="number">1418</span>/? V/zxy: fori花费:<span class="number">30</span></span><br><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">11</span>:<span class="number">44.380</span> <span class="number">1418</span>-<span class="number">1418</span>/? V/zxy: foreach花费:<span class="number">105</span></span><br><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">11</span>:<span class="number">44.476</span> <span class="number">1418</span>-<span class="number">1418</span>/? V/zxy: iterator花费:<span class="number">95</span></span><br></pre></td></tr></table></figure>
<p>而通常我们所说的效率高的foreach在遍历上却显得不如意，而fori效率表现的最好，这是因为ArrayList和Vector集合内部实现由数组实现，所以随机访问的速度是很快的，对于可以进行随机访问的List，JDK为它们实现了RandomAccess接口，表示支持快速随机访问。<br>而在遍历有1w条数据的LinkedList集合时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">23.984</span> <span class="number">1737</span>-<span class="number">1737</span>/? V/zxy: fori花费:<span class="number">351</span></span><br><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">23.988</span> <span class="number">1737</span>-<span class="number">1737</span>/? V/zxy: foreach花费:<span class="number">2</span></span><br><span class="line"><span class="number">11</span>-<span class="number">19</span> <span class="number">09</span>:<span class="number">33</span>:<span class="number">23.992</span> <span class="number">1737</span>-<span class="number">1737</span>/? V/zxy: iterator花费:<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p> 则foreach表现最佳，所以对数组、或者实现了RandomAccess接口的List，遍历用fori性能最佳，对LinkedList等以链表实现的集合遍历时使用foreach或者iterator性能最佳，因为foreach的实现就是通过iterator实现的。<br>我们可以这样判断该List遍历用哪种方式：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list instanceof <span class="type">RandomAccess</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span>&lt;?&gt; <span class="keyword">iterator</span> = list.<span class="keyword">iterator</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">iterator</span>.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">iterator</span>.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预知容量的情况下构造ArrayList时尽量指定初始大小"><a href="#预知容量的情况下构造ArrayList时尽量指定初始大小" class="headerlink" title="预知容量的情况下构造ArrayList时尽量指定初始大小"></a><strong>预知容量的情况下构造ArrayList时尽量指定初始大小</strong></h3><p>ArrayList内部的扩容策略是当其所存储的元素数量超过它已有的大小时，它就会以1.5倍的容量进行扩容，也就是假如当前ArrayList的容量为10000，那么它在需要再存储一个元素时，即第10001个元素，由于容量不够而进行一次扩容，而ArrayList扩容后的容量则变为了15000，而多出了一个元素就多了5000个元素的空间，这太浪费内存资源了，而且扩容还会导致整个数组进行一次内存复制，而ArrayList集合默认大小为10，因此合理的设置ArrayList的容量可避免集合进行扩容。ArrayList内部扩容和数组复制代码为：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object<span class="keyword">[</span>] newArray =<span class="instruction"> new </span>Object<span class="keyword">[</span>s +</span><br><span class="line">       <span class="function"> (</span>s &lt;<span class="function"> (</span>MIN_CAPACITY_INCREMENT / 2<span class="function">)</span> ?</span><br><span class="line">         MIN_CAPACITY_INCREMENT<span class="keyword"> :</span> s &gt;&gt; 1<span class="function">)</span>];</span><br><span class="line">System.arraycopy(a, 0, newArray, 0, s<span class="function">)</span>;<span class="instruction"></span><br><span class="line">array </span>= a = newArray;</span><br></pre></td></tr></table></figure>
<p>而Vector内部扩容策略为按需扩容，每次+1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (capacityIncrement &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((adding = elementData.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        adding = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    adding = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E[] newData = newElementArray(elementData.length + adding);</span><br></pre></td></tr></table></figure>
<p>同样，在众多Map集合中也有各自扩容策略，比如HashMap每次扩容时新容量等于原始的容量*2。在我们常用做字符串拼接的StringBuffer和StringBuilder内部，实际上也是有扩容策略，默认为扩容为原始的1.5倍。</p>
<p><strong>所以，在这些需要扩容的api上，如果预先知道了数据的大小，则预先设置，这样不仅可以避免扩容导致的空间浪费，而且还可避免内部调用System.arraycopy()进行大量数据复制。</strong></p>
<h3 id="程序如果需要通过索引下标对List做随机访问，应优先考虑ArrayList和Vector，迫不得已尽量不要使用LinkedList"><a href="#程序如果需要通过索引下标对List做随机访问，应优先考虑ArrayList和Vector，迫不得已尽量不要使用LinkedList" class="headerlink" title="程序如果需要通过索引下标对List做随机访问，应优先考虑ArrayList和Vector，迫不得已尽量不要使用LinkedList"></a><strong>程序如果需要通过索引下标对List做随机访问，应优先考虑ArrayList和Vector，迫不得已尽量不要使用LinkedList</strong></h3><p>虽说ArrayList在内存上比不上Vector，不过它对数据操作的效率高，特别是在Android等移动设备上，采取牺牲一点空间换时间的方式还是可取的，而涉及到线程安全方面，则使用Vector。</p>
<h2 id="如果一个方法不需要使用该对象的成员，那么把该方法设为static"><a href="#如果一个方法不需要使用该对象的成员，那么把该方法设为static" class="headerlink" title="如果一个方法不需要使用该对象的成员，那么把该方法设为static"></a><strong>如果一个方法不需要使用该对象的成员，那么把该方法设为static</strong></h2><p>静态调用该方法比对象调用该方法快15%~20%，因为这样可以从方法签名上就可以看出该方法调用不会影响该对象的状态</p>
<h2 id="巧用final关键字"><a href="#巧用final关键字" class="headerlink" title="巧用final关键字"></a><strong>巧用final关键字</strong></h2><p>final关键字一般在定义常量和方法用的比较多，而大多数人对final的理解往往是在不可变性上，而final对性能优化也有很大的作用。<br>比如：static int AGE = 10;当10在后面被引用时，这时会有一个字段查找的过程，对于int类型也就是查找方法区中的整型常量池，而对于final的常量，则省去了这个过程，比如：static final int AGE = 10;在使用到AGE的地方将直接用10代替。</p>
<blockquote>
<p>不过对于上面这种优化技巧，仅对基本类型和String类型有效，对于其它的引用类型则无效，但是我们在声明常量的时候加上 static final 依然是个好习惯</p>
</blockquote>
<p>对与final关键字，还有一个强大的作用，就是对那些使用频繁、已经确定为终态的方法定义final，这样有什么好处呢？</p>
<p>说这个前先来说说java中方法的执行过程吧，当调用某个方法时，首先这个方法会入栈，执行完毕后，这个方法出栈，资源释放，而这个过程内部其实是内存地址的转移过程，当执行入栈的方法时，其实就是把程序的执行地址转移到该方法存放的内存地址中，而做此操作前，还有必须进行原先程序执行的内存地址保存过程，当方法执行完出栈后则继续按保存的地址继续执行程序，而这个过程，就是方法的调用过程。</p>
<p>所以，方法的调用过程实际上是需要空间和时间的，而对于同一个方法的频繁调用的优化实际上就是使用内联的办法。</p>
<p>又说到内联函数，内联函数实际上是在编译期做的优化，编译器会将标为为内联的函数在其调用的地方直接用整个函数体进行替换掉，这就省去了函数调用所耗去的时间资源了，而换来的却是目标代码量的增加，所以内联这种优化策略实际上是采取了以空间换时间的策略，对于移动端来说，巧用内联函数实则非常有益。</p>
<p>而要是一个函数成为内联函数，就是将它定义为final，这样在程序编译时，编译器会自动将final函数进行内联优化，那么在调用该函数时则直接展开该函数体进行使用。</p>
<p>总结，并不是内联函数越多越好，一方面它对我们程序的运行效率上确实有提升，而另一方面，对于过多的使用内联函数，则会弄巧成拙，有可能会把某个方法的方法体越搞越大，而且对于某些方法体比较大的方法，内联展开的时间有可能超过方法调用的时间，所以这不仅不会提供性能，反而是降低了本该有的性能。</p>
<blockquote>
<p>综合来看，我们可以对那些使用频繁、已经确定为终态的方法、方法体不大的方法用final修饰，提供程序的性能。</p>
</blockquote>
<h2 id="优先考虑系统中提供的代码而不是自己写"><a href="#优先考虑系统中提供的代码而不是自己写" class="headerlink" title="优先考虑系统中提供的代码而不是自己写"></a><strong>优先考虑系统中提供的代码而不是自己写</strong></h2><p>系统内置了许多非常方便的api供我们使用，比如：System、Arrays、Collections、String等内置了许多方法api，这比我们自己手写方便多了，除了这个外，对于Android来说许多api都使用了底层C/C++实现，所以效率上也比我们自己写快，同样，对于系统api，DVM往往也会使用内联的方式提高效率</p>
<h2 id="慎用异常"><a href="#慎用异常" class="headerlink" title="慎用异常"></a><strong>慎用异常</strong></h2><p>慎用异常并不是不用异常，而是指程序中用抛异常的方式来执行某些操作，比如有些人会以强抛异常方式来中断某些操作等。因为抛异常时都会执行fillInStackTrace();方法，该方法作用就是重新调整堆栈，这使得没有必要用异常的地方一定要避免使用</p>
<p>欢迎补充。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于性能优化这个知识点来说，实在是太广了，博主本人也一直非常关注这方面的学习，而对于性能优化来说它包括了非常非常非常多方面，比如：I/O的优化、网络操作的优化、内存的优化、数据结构的优化、代码层次的优化、UI渲染优化、CPU资源使用率的优化、异常处理的优化等等等等。。。&lt;/p&gt;
&lt;p&gt;本篇文章就博主本人的理解来讲述一些在Android开发中可以优化的地方&lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Vector&quot;&gt;&lt;a href=&quot;#ArrayList和Vector&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Vector&quot;&gt;&lt;/a&gt;&lt;strong&gt;ArrayList和Vector&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;ArrayList和Vector都是内部以数组实现的List，它们两唯一的区别就是对多线程的支持，ArrayList是线程不安全的，而Vector内部对大多数方法都做了同步，是线程安全的，既然是线程安全的，所以性能方面肯定不如ArrayList了（当然想法肯定是对的），不过这需要看哪方面了，ArrayList在add、get、remove等操作效率肯定是高于Vector的，而在内存方面，Vector却比ArrayList表现的更好，这归根都是ArrayList的扩容策略导致的，稍后分析&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化点" scheme="http://zhengxiaoyong.me/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之常见的内存泄露</title>
    <link href="http://zhengxiaoyong.me/2015/11/23/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://zhengxiaoyong.me/2015/11/23/Android性能优化之常见的内存泄漏/</id>
    <published>2015-11-23T14:37:30.000Z</published>
    <updated>2016-04-24T04:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：<br>1、<a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a><br>2、<a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="external">内存泄露从入门到精通三部曲之排查方法篇</a><br>3、<a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="external">内存泄露从入门到精通三部曲之常见原因与用户实践</a></p>
<p>关于性能优化的文章，出自Realm.io：<br><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="external">10 条提升 Android 性能的建议</a><br><a id="more"></a></p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><strong>内存泄漏</strong></h2><h3 id="为什么会产生内存泄漏？"><a href="#为什么会产生内存泄漏？" class="headerlink" title="为什么会产生内存泄漏？"></a><strong>为什么会产生内存泄漏？</strong></h3><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h3 id="内存泄漏对程序的影响？"><a href="#内存泄漏对程序的影响？" class="headerlink" title="内存泄漏对程序的影响？"></a><strong>内存泄漏对程序的影响？</strong></h3><p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2 id="Android中常见的内存泄漏汇总"><a href="#Android中常见的内存泄漏汇总" class="headerlink" title="Android中常见的内存泄漏汇总"></a><strong>Android中常见的内存泄漏汇总</strong></h2><h3 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a><strong>单例造成的内存泄漏</strong></h3><p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。<br>如下这个典例：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;</span><br><span class="line">   <span class="keyword"> private</span> Context context;</span><br><span class="line">   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> &#123;</span><br><span class="line">       <span class="instruction"> if </span>(instance == null<span class="function">)</span> &#123;</span><br><span class="line">           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：<br><strong>1、传入的是Application的Context：</strong>这将没有任何问题，因为单例的生命周期和Application的一样长<br><strong>2、传入的是Activity的Context：</strong>当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。<br>所以正确的单例应该修改为下面这种方式：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AppManager &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;</span><br><span class="line">   <span class="keyword"> private</span> Context context;</span><br><span class="line">   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> &#123;</span><br><span class="line">        this.context =<span class="function"> context.getApplicationContext(</span><span class="function">)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> &#123;</span><br><span class="line">       <span class="instruction"> if </span>(instance == null<span class="function">)</span> &#123;</span><br><span class="line">           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="instruction"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<h3 id="非静态内部类创建静态实例造成的内存泄漏"><a href="#非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="非静态内部类创建静态实例造成的内存泄漏"></a><strong>非静态内部类创建静态实例造成的内存泄漏</strong></h3><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mManager == <span class="literal">null</span>)&#123;</span><br><span class="line">            mManager = <span class="keyword">new</span> <span class="type">TestResource</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> &#123;</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<h3 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a><strong>Handler造成的内存泄漏</strong></h3><p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> void loadData()&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;</span><br><span class="line">    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;</span><br><span class="line">        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) &#123;</span><br><span class="line">            reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="literal">null</span>)&#123;</span><br><span class="line">                activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void loadData() &#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;</span><br><span class="line">    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;</span><br><span class="line">        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) &#123;</span><br><span class="line">            reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="literal">null</span>)&#123;</span><br><span class="line">                activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line">        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void loadData() &#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h3 id="线程造成的内存泄漏"><a href="#线程造成的内存泄漏" class="headerlink" title="线程造成的内存泄漏"></a><strong>线程造成的内存泄漏</strong></h3><p>对于线程造成的内存泄漏，也是平时比较常见的，如下这两个示例可能每个人都这样写过：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//——————test1</span></span><br><span class="line">        <span class="literal">new</span> AsyncTask&lt;<span class="literal">Void</span>, <span class="literal">Void</span>, <span class="literal">Void</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">protected</span> <span class="literal">Void</span> doInBackground(<span class="literal">Void</span><span class="attribute">...</span> <span class="keyword">params</span>) &#123;</span><br><span class="line">                SystemClock<span class="built_in">.</span>sleep(<span class="number">10000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">.</span>execute();</span><br><span class="line"><span class="comment">//——————test2</span></span><br><span class="line">		<span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="literal">void</span> run() &#123;</span><br><span class="line">                SystemClock<span class="built_in">.</span>sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)<span class="built_in">.</span>start();</span><br></pre></td></tr></table></figure>
<p>上面的异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(aVoid);</span><br><span class="line">            MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//——————</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">    <span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();</span><br></pre></td></tr></table></figure>
<p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a><strong>资源未关闭造成的内存泄漏</strong></h3><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h3 id="ThreadLocal使用不当引起的内存泄露"><a href="#ThreadLocal使用不当引起的内存泄露" class="headerlink" title="ThreadLocal使用不当引起的内存泄露"></a><strong>ThreadLocal使用不当引起的内存泄露</strong></h3><p>对于ThreadLocal，一直涉及到内存的泄露问题，即当该线程不需要再操作某个ThreadLocal内的值时，应该手动的remove掉，为什么呢？我们来看看ThreadLocal与Thread的联系图：<br>此图来自网络：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadlocal.png" alt="ThreadLocal"></p>
<p>其中虚线表示弱引用，从该图可以看出，一个Thread维持着一个ThreadLocalMap对象，而该Map对象的key又由提供该value的ThreadLocal对象弱引用提供，所以这就有这种情况：<br>如果ThreadLocal不设为static的，由于Thread的生命周期不可预知，这就导致了当系统gc时将会回收它，而ThreadLocal对象被回收了，此时它对应key必定为null，这就导致了该key对应得value拿不出来了，而value之前被Thread所引用，所以就存在key为null、value存在强引用导致这个Entry回收不了，从而导致内存泄露。</p>
<p>所以避免内存泄露的方法，是对于ThreadLocal要设为static静态的，除了这个，还必须在线程不使用它的值是手动remove掉该ThreadLocal的值，这样Entry就能够在系统gc的时候正常回收，而关于ThreadLocalMap的回收，会在当前Thread销毁之后进行回收。</p>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a><strong>一些建议</strong></h3><p>1、对于生命周期比Activity长的对象如果需要应该使用ApplicationContext<br>2、在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/start.png" alt="这里写图片描述"><br><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建<br>3、对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏<br>4、对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<blockquote>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</blockquote>
<p>5、对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null<br>6、保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。&lt;/p&gt;
&lt;p&gt;最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：&lt;br&gt;1、&lt;a href=&quot;http://bugly.qq.com/blog/?p=832&quot;&gt;内存泄露从入门到精通三部曲之基础知识篇&lt;/a&gt;&lt;br&gt;2、&lt;a href=&quot;http://bugly.qq.com/blog/?p=872&quot;&gt;内存泄露从入门到精通三部曲之排查方法篇&lt;/a&gt;&lt;br&gt;3、&lt;a href=&quot;http://bugly.qq.com/blog/?p=884&quot;&gt;内存泄露从入门到精通三部曲之常见原因与用户实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于性能优化的文章，出自Realm.io：&lt;br&gt;&lt;a href=&quot;https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/&quot;&gt;10 条提升 Android 性能的建议&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="内存泄露" scheme="http://zhengxiaoyong.me/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之使用线程池处理异步任务</title>
    <link href="http://zhengxiaoyong.me/2015/11/17/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://zhengxiaoyong.me/2015/11/17/Android性能优化之使用线程池处理异步任务/</id>
    <published>2015-11-17T08:06:30.000Z</published>
    <updated>2016-04-24T04:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<blockquote>
<p>1、继承Thread类<br>2、实现Runnable接口</p>
</blockquote>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() &#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void <span class="function">run</span>() &#123;</span><br><span class="line">        <span class="comment">//do sth .</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="class">.start</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<blockquote>
<p>1、线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</p>
<p>2、大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</p>
<p>3、大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</p>
</blockquote>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用<br><a id="more"></a></p>
<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><strong>ExecutorService</strong></h1><p>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用</p>
<h2 id="使用线程池管理线程的优点"><a href="#使用线程池管理线程的优点" class="headerlink" title="使用线程池管理线程的优点"></a><strong>使用线程池管理线程的优点</strong></h2><blockquote>
<p>1、线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销</p>
<p>2、线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量</p>
<p>3、在执行大量异步任务时提高了性能</p>
<p>4、Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等</p>
</blockquote>
<p>##<strong>ExecutorService简介</strong><br>通常来说我们说到线程池第一时间想到的就是它：ExecutorService，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：ThreadPoolExecutor，它实现了ExecutorService接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。</p>
<p>###<strong>线程池：ThreadPoolExecutor</strong><br>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">ThreadPoolExecutor</span>(<span class="type">int</span> corePoolSize,</span><br><span class="line">                              <span class="type">int</span> maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              <span class="type">TimeUnit</span> unit,</span><br><span class="line">                              <span class="type">BlockingQueue</span>&lt;<span class="type">Runnable</span>&gt; workQueue,</span><br><span class="line">                              <span class="type">ThreadFactory</span> threadFactory,</span><br><span class="line">                              <span class="type">RejectedExecutionHandler</span> handler) <span class="decorator">&#123;...&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用<strong>Executors</strong>的工厂方法来创建线程池，<strong>Executors</strong>类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：</p>
<blockquote>
<p><strong>1、newFixedThreadPool() ：</strong><br>作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。</p>
<p><strong>2、newCachedThreadPool() ：</strong><br>作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。</p>
<p><strong>3、newSingleThreadExecutor() ：</strong><br>作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。</p>
<p><strong>4、newScheduledThreadPool() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。</p>
<p><strong>5、newSingleThreadScheduledExecutor() ：</strong><br>作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。</p>
</blockquote>
<p>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过<strong>Executors</strong>的工厂方法来获取：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5)<span class="comment">;</span></span><br><span class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor()<span class="comment">;</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool()<span class="comment">;</span></span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5)<span class="comment">;</span></span><br><span class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到通过<strong>Executors</strong>的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api，所以我们主要就是要了解ThreadPoolExecutor，从构造方法开始：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler <span class="keyword">handler</span>)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到它构造方法的参数比较多，有七个，下面一一来说明这些参数的作用：</p>
<blockquote>
<p><strong>corePoolSize</strong>：线程池中的核心线程数量<br><strong>maximumPoolSize</strong>：线程池中的最大线程数量<br><strong>keepAliveTime</strong>：这个就是上面说到的“保持活动时间“，上面只是大概说明了一下它的作用，不过它起作用必须在一个前提下，就是当线程池中的线程数量超过了corePoolSize时，它表示多余的空闲线程的存活时间，即：多余的空闲线程在超过keepAliveTime时间内没有任务的话则被销毁。而这个主要应用在缓存线程池中<br><strong>unit</strong>：它是一个枚举类型，表示keepAliveTime的单位，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）<br><strong>workQueue</strong>：任务队列，主要用来存储已经提交但未被执行的任务，不同的线程池采用的排队策略不一样，稍后再讲<br><strong>threadFactory</strong>：线程工厂，用来创建线程池中的线程，通常用默认的即可<br><strong>handler</strong>：通常叫做拒绝策略，1、在线程池已经关闭的情况下  2、任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务  。在上面两种情况下，只要满足其中一种时，在使用execute()来提交新的任务时将会拒绝，而默认的拒绝策略是抛一个RejectedExecutionException异常</p>
</blockquote>
<p>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个<code>BlockingQueue&lt;Runnable&gt;</code>对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么BlockingQueue：</p>
<blockquote>
<p>1、newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2、newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3、newCachedThreadPool()—&gt;SynchronousQueue<br>4、newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5、newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue</p>
</blockquote>
<p>这些队列分别表示：</p>
<blockquote>
<p><strong>LinkedBlockingQueue</strong>：无界的队列<br><strong>SynchronousQueue</strong>：直接提交的队列<br><strong>DelayedWorkQueue</strong>：等待队列</p>
</blockquote>
<p>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。</p>
<h2 id="线程池ThreadPoolExecutor的使用"><a href="#线程池ThreadPoolExecutor的使用" class="headerlink" title="线程池ThreadPoolExecutor的使用"></a><strong>线程池ThreadPoolExecutor的使用</strong></h2><p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execute</span><span class="params">(Runnable command)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。 </p>
<p><font size="5"><strong>newFixedThreadPool</strong></font><br>创建一个固定线程数量的线程池，示例为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">       final <span class="keyword">int</span> index = i;</span><br><span class="line">       fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @<span class="function">Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String threadName = Thread.currentThread().getName();</span><br><span class="line">                Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。<br>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog%2Fthreadpool.gif" alt="这里写图片描述"></p>
<p><font size="5"><strong>newSingleThreadExecutor</strong></font><br>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    final <span class="keyword">int</span> index = i;</span><br><span class="line">    singleThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool2.gif" alt="这里写图片描述"></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。</p>
<p><font size="5"><strong>newCachedThreadPool</strong></font><br>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    final <span class="keyword">int</span> index = i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> time = index * <span class="number">500</span>;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool3.gif" alt="这里写图片描述"></p>
<p><font size="5"><strong>newScheduledThreadPool</strong></font><br>创建一个可以定时或者周期性执行任务的线程池，示例为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//延迟2秒后执行该任务</span></span><br><span class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//延迟1秒后，每隔2秒执行一次该任务</span></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p><font size="5"><strong>newSingleThreadScheduledExecutor</strong></font><br>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，示例为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"><span class="comment">//延迟1秒后，每隔2秒执行一次该任务</span></span><br><span class="line">singleThreadScheduledPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool4.gif" alt="这里写图片描述"><br>每隔2秒就会执行一次该任务</p>
<p>###<strong>自定义线程池ThreadPoolExecutor</strong><br>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<p>####<strong>1、首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>
<p>####<strong>2、然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">PriorityRunnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityRunnable</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (priority &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityRunnable another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> my = <span class="keyword">this</span>.getPriority();</span><br><span class="line">        <span class="keyword">int</span> other = another.getPriority();</span><br><span class="line">        <span class="keyword">return</span> my &lt; other ? <span class="number">1</span> : my &gt; other ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSth();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####<strong>3、使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    final <span class="keyword">int</span> priority = i;</span><br><span class="line">    priorityThreadPool.execute(<span class="keyword">new</span> PriorityRunnable(priority) &#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行优先级为："</span> + priority + <span class="string">"的任务"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####<strong>测试效果</strong><br>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool5.gif" alt="这里写图片描述"></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<p>####<strong>优先级线程池的优点</strong><br>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<p>###<strong>扩展线程池ThreadPoolExecutor</strong><br>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<blockquote>
<p>beforeExecute() - 任务执行前执行的方法<br>afterExecute() -任务执行结束后执行的方法<br>terminated() -线程池关闭后执行的方法</p>
</blockquote>
<p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool6.png" alt="这里写图片描述"></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool7.png" alt="这里写图片描述"></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        String threadName = t.getName();</span><br><span class="line">        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"准备执行任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"任务执行结束！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.terminated();</span><br><span class="line">        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程池结束！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而运行后的结果则是，这正符合刚刚说的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>准备执行任务！</span><br><span class="line"><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>正在执行任务！</span><br><span class="line"><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">53.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>任务执行结束！</span><br><span class="line"><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">58.896</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程池结束！</span><br></pre></td></tr></table></figure>
<p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PausableThreadPoolExecutor pausableThreadPoolExecutor = <span class="keyword">new</span> PausableThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    final <span class="keyword">int</span> priority = i;</span><br><span class="line">    pausableThreadPoolExecutor.execute(<span class="keyword">new</span> PriorityRunnable(priority) &#123;</span><br><span class="line">        @<span class="function">Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                @<span class="function">Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    textView.setText(priority + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPause) &#123;</span><br><span class="line">    pausableThreadPoolExecutor.resume<span class="literal">()</span>;</span><br><span class="line">    isPause = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pausableThreadPoolExecutor.pause<span class="literal">()</span>;</span><br><span class="line">    isPause = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果为：<br><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/threadpool8.png" alt="这里写图片描述"></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<p>###<strong>优化线程池ThreadPoolExecutor</strong><br>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量*2+1。</p>
<p>获取CPU数量的方法为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Runtime</span><span class="class">.getRuntime</span>()<span class="class">.availableProcessors</span>();</span><br></pre></td></tr></table></figure>
<p>###<strong>shutdown()和shutdownNow()的区别</strong><br>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<blockquote>
<p>1、shutdown()方法在终止前允许执行以前提交的任务。<br>2、shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</p>
</blockquote>
<p>###<strong>关于AsyncTask的实现</strong><br>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、继承Thread类&lt;br&gt;2、实现Runnable接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。&lt;/p&gt;
&lt;p&gt;所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;Thread&lt;/span&gt;(new &lt;span class=&quot;function&quot;&gt;Runnable&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void &lt;span class=&quot;function&quot;&gt;run&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//do sth .&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;span class=&quot;class&quot;&gt;.start&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失&lt;/p&gt;
&lt;p&gt;2、大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM&lt;/p&gt;
&lt;p&gt;3、大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。&lt;br&gt;所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用&lt;br&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://zhengxiaoyong.me/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="异步任务" scheme="http://zhengxiaoyong.me/tags/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="线程池" scheme="http://zhengxiaoyong.me/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
