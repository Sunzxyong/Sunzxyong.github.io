<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>zhengxiaoyong</title>
    <link>http://zhengxiaoyong.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 19 Dec 2018 10:13:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Flutter混合开发组件化与工程化架构</title>
      <link>http://zhengxiaoyong.com/2018/12/16/Flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9E%B6%E6%9E%84/</link>
      <guid>http://zhengxiaoyong.com/2018/12/16/Flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9E%B6%E6%9E%84/</guid>
      <pubDate>Sun, 16 Dec 2018 09:30:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、简述&quot;&gt;&lt;a href=&quot;#一、简述&quot; class=&quot;headerlink&quot; title=&quot;一、简述&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、简述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于构建Flutter类型应用，因其开发语言Dart、虚拟机、构建工具与平时我们开发Native应用不同且平台虚拟机也不支持，所以需要Flutter SDK来支持，如构建Android应用需要Android SDK一样，下载Flutter SDK通常有两种方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在官网下载构建好的zip包，里面包含完整的Flutter基础Api，Dart VM，Dart SDK等&lt;/li&gt;
&lt;li&gt;手动构建，Clone Flutter源码后，运行&lt;code&gt;flutter --packages get&lt;/code&gt;或其它具有检测类型的命令如&lt;code&gt;build&lt;/code&gt;、&lt;code&gt;doctor&lt;/code&gt;，这时会自动构建和下载Dart SDK以及Flutter引擎产物&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;在团队多人协作开发下，这种依赖每个开发本地下载Flutter SDK的方式，不能保证Flutter SDK的版本一致性与自动化管理，在开发时如果Flutter SDK版本不一致，往往会出现Dart层Api兼容性或Flutter虚拟机不一致等问题，因为每个版本的Flutter都有各自对应的Flutter虚拟机，构建产物中会包含对应构建版本的虚拟机。Flutter工程的构建需要Flutter标准的工程结构目录和依赖于本地的Flutter环境，每个对应Flutter工程都有对应的Flutter SDK路径，Android在&lt;code&gt;local.properties&lt;/code&gt;中，IOS在&lt;code&gt;Generated.xcconfig&lt;/code&gt;中，这个路径会在Native工程本地依赖Flutter工程构建时读取，并从中获取引擎、资源和编译构建Flutter工程，而调用&lt;code&gt;flutter&lt;/code&gt;命令时构建Flutter工程则会获取当前&lt;code&gt;flutter&lt;/code&gt;命令所在的Flutter SDK路径，并从中获取引擎、资源和编译构建Flutter工程，所以&lt;code&gt;flutter&lt;/code&gt;命令构建环境与Flutter工程中平台子工程的环境变量一定得保持一致，且这个环境变量是随&lt;code&gt;flutter&lt;/code&gt;执行动态改变的，团队多人协作下这个得保证，在打包Flutter工程的正式版每个版本也应该有一个对应的Flutter构建版本，不管是本地打包还是在打包平台打包&lt;/p&gt;
&lt;p&gt;我们知道Flutter应用的工程结构都与Native应用工程结构不一样，不一致地方主要是Native工程是作为Flutter工程子工程，外层通过&lt;code&gt;Pub&lt;/code&gt;进行依赖管理，这样通过依赖下来的&lt;code&gt;Flutter Plugin/Package&lt;/code&gt;代码即可与多平台共享，在打包时Native子工程只打包工程代码与&lt;code&gt;Pub&lt;/code&gt;所依赖库的平台代码，Flutter工程则通过&lt;code&gt;flutter_tools&lt;/code&gt;打包&lt;code&gt;lib&lt;/code&gt;目录下以及&lt;code&gt;Pub&lt;/code&gt;所依赖库的Dart代码。回到正题，因工程结构的差异，如果基于现有的Native工程想使用Flutter来开发其中一个功能模块，一般来说混合开发至少得保证如下特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对Native工程无侵入&lt;/li&gt;
&lt;li&gt;对Native工程零耦合&lt;/li&gt;
&lt;li&gt;不影响Native工程的开发流程与打包流程&lt;/li&gt;
&lt;li&gt;易本地调试&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然改变工程结构的方案可以直接忽略，官方也提供了一种Flutter本地依赖到现有Native的方案，不过这种方案不加改变优化而直接依赖的话，则会直接影响了其它无Flutter环境的开发同学的开发，影响开发流程，且打包平台也不支持这种依赖方式的打包&lt;/p&gt;
&lt;p&gt;再讲讲Flutter SDK，平时进行Flutter开发过程中，难免避免不了因Flutter SDK的Bug亦或是需要改Flutter SDK中平台链接的脚本代码导致直接改动或者定制Flutter SDK，这种方式虽然可以解决问题或定制化，不过极其不推荐，这种方式对后续Flutter SDK的平滑升级极不友好，且带来更多的后期维护成本&lt;/p&gt;
&lt;p&gt;接下来，本文主要是介绍如何对上述问题解决与实现：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Flutter SDK版本一致性与自动化管理&lt;/li&gt;
&lt;li&gt;无侵入Flutter SDK源码进行BugFix或定制化&lt;/li&gt;
&lt;li&gt;Flutter混合开发组件化架构&lt;/li&gt;
&lt;li&gt;Flutter混合开发工程化架构&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a><strong>一、简述</strong></h2><p>对于构建Flutter类型应用，因其开发语言Dart、虚拟机、构建工具与平时我们开发Native应用不同且平台虚拟机也不支持，所以需要Flutter SDK来支持，如构建Android应用需要Android SDK一样，下载Flutter SDK通常有两种方式：</p>
<blockquote>
<ol>
<li>在官网下载构建好的zip包，里面包含完整的Flutter基础Api，Dart VM，Dart SDK等</li>
<li>手动构建，Clone Flutter源码后，运行<code>flutter --packages get</code>或其它具有检测类型的命令如<code>build</code>、<code>doctor</code>，这时会自动构建和下载Dart SDK以及Flutter引擎产物</li>
</ol>
</blockquote>
<p>在团队多人协作开发下，这种依赖每个开发本地下载Flutter SDK的方式，不能保证Flutter SDK的版本一致性与自动化管理，在开发时如果Flutter SDK版本不一致，往往会出现Dart层Api兼容性或Flutter虚拟机不一致等问题，因为每个版本的Flutter都有各自对应的Flutter虚拟机，构建产物中会包含对应构建版本的虚拟机。Flutter工程的构建需要Flutter标准的工程结构目录和依赖于本地的Flutter环境，每个对应Flutter工程都有对应的Flutter SDK路径，Android在<code>local.properties</code>中，IOS在<code>Generated.xcconfig</code>中，这个路径会在Native工程本地依赖Flutter工程构建时读取，并从中获取引擎、资源和编译构建Flutter工程，而调用<code>flutter</code>命令时构建Flutter工程则会获取当前<code>flutter</code>命令所在的Flutter SDK路径，并从中获取引擎、资源和编译构建Flutter工程，所以<code>flutter</code>命令构建环境与Flutter工程中平台子工程的环境变量一定得保持一致，且这个环境变量是随<code>flutter</code>执行动态改变的，团队多人协作下这个得保证，在打包Flutter工程的正式版每个版本也应该有一个对应的Flutter构建版本，不管是本地打包还是在打包平台打包</p>
<p>我们知道Flutter应用的工程结构都与Native应用工程结构不一样，不一致地方主要是Native工程是作为Flutter工程子工程，外层通过<code>Pub</code>进行依赖管理，这样通过依赖下来的<code>Flutter Plugin/Package</code>代码即可与多平台共享，在打包时Native子工程只打包工程代码与<code>Pub</code>所依赖库的平台代码，Flutter工程则通过<code>flutter_tools</code>打包<code>lib</code>目录下以及<code>Pub</code>所依赖库的Dart代码。回到正题，因工程结构的差异，如果基于现有的Native工程想使用Flutter来开发其中一个功能模块，一般来说混合开发至少得保证如下特点：</p>
<blockquote>
<ol>
<li>对Native工程无侵入</li>
<li>对Native工程零耦合</li>
<li>不影响Native工程的开发流程与打包流程</li>
<li>易本地调试</li>
</ol>
</blockquote>
<p>显然改变工程结构的方案可以直接忽略，官方也提供了一种Flutter本地依赖到现有Native的方案，不过这种方案不加改变优化而直接依赖的话，则会直接影响了其它无Flutter环境的开发同学的开发，影响开发流程，且打包平台也不支持这种依赖方式的打包</p>
<p>再讲讲Flutter SDK，平时进行Flutter开发过程中，难免避免不了因Flutter SDK的Bug亦或是需要改Flutter SDK中平台链接的脚本代码导致直接改动或者定制Flutter SDK，这种方式虽然可以解决问题或定制化，不过极其不推荐，这种方式对后续Flutter SDK的平滑升级极不友好，且带来更多的后期维护成本</p>
<p>接下来，本文主要是介绍如何对上述问题解决与实现：</p>
<blockquote>
<ol>
<li>Flutter SDK版本一致性与自动化管理</li>
<li>无侵入Flutter SDK源码进行BugFix或定制化</li>
<li>Flutter混合开发组件化架构</li>
<li>Flutter混合开发工程化架构</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="二、Flutter四种工程类型"><a href="#二、Flutter四种工程类型" class="headerlink" title="二、Flutter四种工程类型"></a><strong>二、Flutter四种工程类型</strong></h2><p>Flutter工程中，通常有以下几种工程类型，下面分别简单概述下：<br><strong>1. Flutter Application</strong><br>标准的Flutter App工程，包含标准的Dart层与Native平台层<br><strong>2. Flutter Module</strong><br>Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程<br><strong>3. Flutter Plugin</strong><br>Flutter平台插件工程，包含Dart层与Native平台层的实现<br><strong>4. Flutter Package</strong><br>Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p>
<h2 id="三、Flutter工程Pub依赖管理"><a href="#三、Flutter工程Pub依赖管理" class="headerlink" title="三、Flutter工程Pub依赖管理"></a><strong>三、Flutter工程Pub依赖管理</strong></h2><p>Flutter工程之间的依赖管理是通过<code>Pub</code>来管理的，依赖的产物是直接源码依赖，这种依赖方式和IOS中的Pod有点像，都可以进行依赖库版本号的区间限定与Git远程依赖等，其中具体声明依赖是在<code>pubspec.yaml</code>文件中，其中的依赖编写是基于<code>YAML</code>语法，<code>YAML</code>是一个专门用来编写文件配置的语言，下面是一个通过Git地址远程依赖示例：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  uuid:</span><br><span class="line">    git:</span><br><span class="line">      url: git://github.com/<span class="type">Daegalus</span>/dart-uuid.git</span><br><span class="line">      <span class="keyword">ref</span>: master</span><br></pre></td></tr></table></figure>
<p>声明依赖后，通过运行<code>flutter packages get</code>命名，会从远程或本地拉取对应的依赖，同时会生成<code>pubspec.lock</code>文件，这个文件和IOS中的<code>Podfile.lock</code>极其相似，会在本地锁定当前依赖的库以及对应版本号，只有当执行<code>flutter packages upgrade</code>时，这时才会更新，同样<code>pubspec.lock</code>文件也需要作为版本管理文件提交到Git中，而不应gitignore</p>
<h3 id="1-Pub依赖冲突处理"><a href="#1-Pub依赖冲突处理" class="headerlink" title="1. Pub依赖冲突处理"></a><strong>1. Pub依赖冲突处理</strong></h3><p>对于<code>Pub</code>和<code>Pod</code>这种依赖管理工具对于发生冲突时处理冲突的能力与Android的<code>Gradle</code>依赖管理相比差了一大截，所以当同一个库发生版本冲突时，只能我们自己手动进行处理，而且随着开发规模的扩大，肯定会出现传递依赖的库之间的冲突</p>
<p>Pub依赖冲突主要有两种：</p>
<blockquote>
<ol>
<li>当前依赖库的版本与当前的Dart SDK环境版本冲突</li>
<li>传递依赖时出现一个库版本不一致冲突</li>
</ol>
</blockquote>
<p>第一种会在<code>flutter packages get</code>时报错并提示为何出现冲突且最低需要的版本是多少，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The current Dart SDK version is <span class="number">2.1</span><span class="number">.0</span>-dev<span class="number">.5</span><span class="number">.0</span>.flutter-a2eb050044.</span><br><span class="line"></span><br><span class="line">Because flutter_app depends on xml &gt;=<span class="number">0.1</span><span class="number">.0</span> &lt;<span class="number">3.0</span><span class="number">.1</span> which requires SDK version &lt;<span class="number">2.0</span><span class="number">.0</span>, version solving failed.                        </span><br><span class="line"><span class="function">pub get <span class="title">failed</span> <span class="params">(<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这个可以直接根据提示进行依赖库的版本升级解决</p>
<p>而第二种则比较复杂点，假如有A、B、C三个库，A和B都依赖C库，如果A的某个版本依赖的C和B版本依赖的C版本不一致，则会发生冲突，而如何解决这种冲突呢？有两种方式</p>
<p>1、首先把A和B库的版本都设为<code>any</code>任意版本，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span>:</span><br><span class="line">	A: <span class="keyword">any</span></span><br><span class="line">	B: <span class="keyword">any</span></span><br></pre></td></tr></table></figure>
<p>此时再通过<code>flutter packages get</code>时，则不会提示有版本冲突报错，因为<code>Pub</code>已经自动选取了让C库版本一致的A、B库的版本号，此时打开同级目录下的<code>pubspec.lock</code>文件，搜索A、B两个库，则会有对应无冲突的版本号，最后再把这两个版本号分别替换掉<code>any</code>版本，这个版本冲突就解决了</p>
<p>2、通过版本覆盖进行解决  </p>
<h3 id="2-Pub依赖版本覆盖"><a href="#2-Pub依赖版本覆盖" class="headerlink" title="2. Pub依赖版本覆盖"></a><strong>2. Pub依赖版本覆盖</strong></h3><p>在<code>Pub</code>依赖管理中，既然支持传递依赖，同样也提供了一种版本覆盖的方式，意为强制指定一个版本，这和Android中<code>Gradle</code>的<code>force</code>有点相似，同样版本覆盖方式也可以用于解决冲突，如果知道某一个版本肯定不会冲突，则可直接通过版本覆盖方式解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependency_overrides:</span><br><span class="line">  A: <span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="四、Flutter链接到Native工程原理"><a href="#四、Flutter链接到Native工程原理" class="headerlink" title="四、Flutter链接到Native工程原理"></a><strong>四、Flutter链接到Native工程原理</strong></h2><p>官方提供了一种本地依赖到现有的Native工程方式，具体可看官方wiki：<a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="external">Flutter本地依赖</a>，这种方式太依赖于本地环境和侵入Native工程会影响其它开发同学，且打包平台不支持这种方式的打包，所以肯定得基于这种方式进行优化改造，这个后面再说，先说说Native两端本地依赖的原理</p>
<h3 id="1-Android"><a href="#1-Android" class="headerlink" title="1. Android"></a><strong>1. Android</strong></h3><p>在Android中本地依赖方式为：</p>
<blockquote>
<ol>
<li>在<code>settings.gradle</code>中注入<code>include_flutter.groovy</code>脚本</li>
<li>在需要依赖的module中<code>build.gradle</code>添加<code>project(&#39;:flutter&#39;)</code>依赖</li>
</ol>
</blockquote>
<p>对于Android的本地依赖，主要是由<code>include_flutter.groovy</code>和<code>flutter.gradle</code>这两个脚本负责Flutter的本地依赖和产物构建</p>
<h4 id="1-include-flutter-groovy"><a href="#1-include-flutter-groovy" class="headerlink" title="1. include_flutter.groovy"></a><strong>1. include_flutter.groovy</strong></h4><p>在<code>settings.gradle</code>中注入时，分别绑定了当前执行Gradle的上下文环境与执行<code>include_flutter.groovy</code>脚本，该脚本只做了下面三件事：</p>
<blockquote>
<ol>
<li>include FlutterModule中的<code>.android/Flutter</code>工程</li>
<li>include FlutterModule中的<code>.flutter-plugins</code>文件中包含的Flutter工程路径下的android module</li>
<li>配置所有工程的<code>build.gradle</code>配置执行阶段都依赖于<code>:flutter</code>工程，也即它最先执行配置阶段</li>
</ol>
</blockquote>
<p>其中<code>.flutter-plugins</code>文件，是根据当前依赖自动生成的，里面包含了当前Flutter工程所依赖（直接依赖和传递依赖）的Flutter子工程与绝对路径的K-V关系，子工程可能是一个Flutter Plugin或者是一个Flutter Package，下面是<code>.flutter-plugins</code>中的一段内容示例：<br><strong>.flutter-plugins：</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_launcher=<span class="regexp">/Users/</span>Sunzxyong<span class="regexp">/.pub-cache/</span>hosted<span class="regexp">/pub.flutter-io.cn/u</span>rl_launcher-<span class="number">4.0</span>.<span class="number">2</span><span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<h4 id="2-flutter-gradle"><a href="#2-flutter-gradle" class="headerlink" title="2. flutter.gradle"></a><strong>2. flutter.gradle</strong></h4><p>该脚本位于Flutter SDK中，内容看起来很长，其实主要做了下面三件事：</p>
<blockquote>
<ol>
<li>选择符合对应架构的Flutter引擎（flutter.so）</li>
<li>解析上述<code>.flutter-plugins</code>文件，把对应的android module添加到Native工程的依赖中（上述的include其实为这步做准备）</li>
<li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用<code>flutter</code>命令编译Dart层代码构建出<code>flutter_assets</code>产物，并拷贝到<code>assets</code>目录下</li>
</ol>
</blockquote>
<p>有了上述三步，则直接在Native工程中运行构建即可自动构建Flutter工程中的代码并自动拷贝产物到Native中</p>
<h3 id="2-IOS"><a href="#2-IOS" class="headerlink" title="2. IOS"></a><strong>2. IOS</strong></h3><p>在IOS中本地依赖方式为：</p>
<blockquote>
<ol>
<li>在Podfile中通过<code>eval binding</code>特性注入<code>podhelper.rb</code>脚本，在pod install/update时会执行它</li>
<li>在IOS构建阶段<code>Build Phases</code>中注入构建时需要执行的<code>xcode_backend.sh</code>脚本</li>
</ol>
</blockquote>
<p>对于IOS的本地依赖，主要是由<code>podhelper.rb</code>和<code>xcode_backend.sh</code>这两个脚本负责Flutter的Pod本地依赖和产物构建</p>
<h4 id="1-podhelper-rb"><a href="#1-podhelper-rb" class="headerlink" title="1. podhelper.rb"></a><strong>1. podhelper.rb</strong></h4><p>因Podfile是通过ruby语言写的，所以该脚本也是ruby脚本，该脚本在pod install/update时主要做了三件事：</p>
<blockquote>
<ol>
<li>Pod本地依赖Flutter引擎（Flutter.framework）与Flutter插件注册表（FlutterPluginRegistrant）</li>
<li>Pod本地源码依赖<code>.flutter-plugins</code>文件中包含的Flutter工程路径下的ios工程</li>
<li>在pod install执行完后<code>post_install</code>中，获取当前target工程对象，导入<code>Generated.xcconfig</code>配置，这些配置都为环境变量配置，主要为构建阶段<code>xcode_backend.sh</code>脚本执行做准备</li>
</ol>
</blockquote>
<p>上述事情即可保证Flutter工程以及传递依赖的都通过pod本地依赖进Native工程了，接下来就是构建了</p>
<h4 id="2-xcode-backend-sh"><a href="#2-xcode-backend-sh" class="headerlink" title="2. xcode_backend.sh"></a><strong>2. xcode_backend.sh</strong></h4><p>该Shell脚本位于Flutter SDK中，该脚本主要就做了两件事：</p>
<blockquote>
<ol>
<li>调用flutter命令编译构建出产物（App.framework、flutter_assets）</li>
<li>把产物（*.framework、flutter_assets）拷贝到对应XCode构建产物中，对应产物目录为：<code>$HOME/Library/Developer/Xcode/DerivedData/${AppName}</code></li>
</ol>
</blockquote>
<p>上述两个静态库<code>*.framework</code>是拷贝到<code>${BUILT_PRODUCTS_DIR}&quot;/&quot;${PRODUCT_NAME}&quot;.app/Frameworks&quot;</code>目录下</p>
<p>flutter_assets拷贝到<code>${BUILT_PRODUCTS_DIR}&quot;/&quot;${PRODUCT_NAME}&quot;.app&quot;</code>目录下</p>
<p>在XCode工程中，对应的是在<code>${AppName}/Products/${AppName}.app</code></p>
<h2 id="五、Flutter与Native通信"><a href="#五、Flutter与Native通信" class="headerlink" title="五、Flutter与Native通信"></a><strong>五、Flutter与Native通信</strong></h2><p>Flutter与Native通信有三种方式，这里只简单介绍下：</p>
<blockquote>
<ol>
<li>MethodChannel：方法调用</li>
<li>EventChannel：事件监听</li>
<li>BasicMessageChannel：消息传递</li>
</ol>
</blockquote>
<p>Flutter与Native通信都是双向通道，可以互相调用和消息传递</p>
<p>接下来是本文的重点内容，上述主要是普及下Flutter工程上比较重要的内容以及为下面要讲做准备，当然还有打包模式、构建流程等就不放这里了，后面可以单独开一篇讲</p>
<h2 id="六、Flutter版本一致性与自动化管理"><a href="#六、Flutter版本一致性与自动化管理" class="headerlink" title="六、Flutter版本一致性与自动化管理"></a><strong>六、Flutter版本一致性与自动化管理</strong></h2><p>在团队多人协作开发模式下，Flutter SDK的版本一致性与自动化管理，这是个必须解决的问题，通过这个问题，我们回看Android中Gradle的版本管理模式：</p>
<blockquote>
<p>Gradle的版本管理是通过包装器模式，每个Gradle项目都会对应一个Gradle构建版本，对应的Gradle版本在<code>gradle-wrapper.properties</code>配置文件中进行配置，如果执行构建时本地没有当前工程中对应的Gradle版本，则会自动下载所需的Gradle版本，而执行构建则是通过<code>./gradlew</code>包装器模式进行执行，这样本地配置的全局Gradle环境与工程环境即可隔离开，对应的项目始终保持同一个Gradle版本的构建</p>
</blockquote>
<p>这种包装器模式的版本管理方式，可与每台机器中全局配置的环境保持隔离，在团队多人协作下，也可保持同一个项目工程保持同一个构建版本</p>
<p>所以，我们沿用Gradle版本管理思想，在每个Flutter工程（包含上述说的四种工程）的根目录加入三个文件：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wrapper/flutter-wrapper<span class="class">.properties</span></span><br><span class="line">flutterw</span><br><span class="line">flutterw.bat</span><br></pre></td></tr></table></figure>
<p>加入后的项目结构则多了三个文件，如下：<br><img src="https://raw.githubusercontent.com/Sunzxyong/ImageRepository/master/flutterw.jpg" width="360"></p>
<p>上述<code>flutter-wrapper.properties</code>为当前工程Flutter SDK版本配置文件，内容为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https:<span class="comment">//github.com/flutter/flutter</span></span><br><span class="line">flutterVersion=<span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>当然有需要可以再增加一些配置，目前这两个配置已经足够了，指定了Flutter的远程地址以及版本号，如果Clone Github上项目比较慢，也可以改为私有维护的镜像地址</p>
<p>而<code>flutterw</code>为一个Shell脚本，内部对版本管理主要做的事情为：</p>
<blockquote>
<ol>
<li>读取配置的版本号，校验Flutter SDK版本，不存在则触发下载</li>
<li>更新Android中<code>local.properties</code>和IOS中<code>Generated.xcconfig</code>文件中Flutter SDK地址</li>
<li>最后把命令行传来的参数链接到Flutter SDK中的flutter进行执行</li>
</ol>
</blockquote>
<p>之后构建Flutter工程则用<code>flutterw</code>命令：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./flutterw <span class="keyword">build </span><span class="keyword">bundle</span></span><br></pre></td></tr></table></figure>
<p>而不用本地全局配置的<code>flutter</code>命令，避免每个开发同学版本不一致问题，且这种方式对于新加入Flutter开发的同学来说，完全不需要自己手动下载Flutter SDK，只需执行一下<code>flutterw</code>任何命令，如<code>./flutterw --version</code>，即可自动触发对应Flutter SDK的下载与安装，实现优雅的自动化管理，这种方式对打包平台来说也为支持Flutter工程的打包提供基础</p>
<h2 id="七、Flutter混合开发组件化架构"><a href="#七、Flutter混合开发组件化架构" class="headerlink" title="七、Flutter混合开发组件化架构"></a><strong>七、Flutter混合开发组件化架构</strong></h2><p>上述说的如果我们要利用Flutter来开发我们现有Native工程中的一个模块或功能，肯定得不能改变Native的工程结构以及不影响现有的开发流程，那么，以何种方式进行混合开发呢？<br>前面说到Flutter的四种工程模型，Flutter App我们可以直接忽略，因为这是一个开发全新的Flutter App工程，对于Flutter Module，官方提供的本地依赖便是使用Flutter Module依赖到Native App的，而对于Flutter工程来说，<code>构建Flutter工程</code>必须得有个<code>main.dart</code>主入口，恰好Flutter Module中也有主入口</p>
<p>于是，我们进行组件划分，通过Flutter Module作为所有通过Flutter实现的模块或功能的聚合入口，通过它进行Flutter层到Native层的双向关联。而Flutter开发代码写在哪里呢？当然可以直接写在Flutter Module中，这没问题，而如果后续开发了多个模块、组件，我们的Dart代码总不可能全部写在Flutter Module中<code>lib/</code>吧，如果在<code>lib/</code>目录下再建立子目录进行模块区分，这不失为一种最简单的方式，不过这会带来一些问题，所有模块共用一个远程Git地址，首先在组件开发隔离上完全耦合了，其次各个模块组件没有单独的版本号或Tag，且后续模块组件的增多，带来更多的测试回归成本</p>
<p>正确的组件化方式为一个组件有一个独立的远程Git地址管理，这样各个组件在发正式版时都有一个版本号和Tag，且在各个组件开发上完全隔离，后续组件的增多不影响其它组件，某个组件新增需求而不需回归其它组件，带来更低的测试成本</p>
<p>前面提到<code>Flutter Plugin</code>可以有对应Dart层代码与平台层的实现，所以可以这样设计，一个组件对应一个<code>Flutter Plugin</code>，一个<code>Flutter Plugin</code>为一个完整的Flutter工程，有独立的Git地址，而这些组件之间不能互相依赖，保持零耦合，所以这些组件都在<code>业务层</code>，可以叫做<code>业务组件</code>，这些业务组件之间的通信和公共服务可以再划分一层<code>基础层</code>，可以叫做<code>基础组件</code>，所有业务组件依赖基础层，而<code>Flutter Module</code>作为聚合层依赖于所有<code>Flutter组件</code>，这些Flutter工程之间的依赖正是通过<code>Pub</code>依赖进行管理的</p>
<p>所以，综合上述，整体的组件化架构可以设计为：<br><img src="https://raw.githubusercontent.com/Sunzxyong/ImageRepository/master/flutter_hybrid_arch.jpg" alt=""></p>
<h3 id="业务组件与基础组件的定位"><a href="#业务组件与基础组件的定位" class="headerlink" title="业务组件与基础组件的定位"></a><strong>业务组件与基础组件的定位</strong></h3><p>对于上面的基础组件比如还可以进行更细粒度的划分，不过不建议划分太多，对于与Native平台层的通信，每个业务组件对应一个<code>Channel</code>，当然内部还可以进行更细粒度的<code>Channel</code>进行划分，这个<code>Channel</code>主要是负责Native层服务的提供，让Flutter层消费。而对于Native层调用Flutter层的Api，应该尽可能少，需要调也只有出现一些值回调时</p>
<p>因为Flutter的出现最本质的就是一次开发两端运行，而如果有太多这种依赖于平台层的实现，反而出现违背了，最后只是UI写了一份而已。对于平台层的实现也要尽量保持一个原则，即：</p>
<blockquote>
<p>尽量让Native平台层成为服务层，让Flutter层成为消费层调用Native层的服务，即Dart调用Native的Api，这样当两端开发人员编写好一致基础的服务接口后，Flutter的开发人员即可平滑使用和开发</p>
</blockquote>
<p>而对于基础组件中的公共服务组件Dart Api层的设计，因为公共服务主要调用Native层的服务，在Flutter中提供公共的Dart Api，作为Native到Flutter的一个桥梁，对于Native的服务，会有很有多种，而对应Api的设计为一个dart文件对应一个种类的服务，整个公共服务组件提供一个统一个对外暴露的Dart，内部的细粒度的Dart实现通过<code>export</code>导入，这种设计思想正是Flutter官方Api的设计，即统一对外暴露的Dart为<code>common_service.dart</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">library</span> common_service;</span><br><span class="line"></span><br><span class="line"><span class="literal">export</span> <span class="string">'network_plugin.dart'</span>;</span><br><span class="line"><span class="literal">export</span> <span class="string">'messager_plugin.dart'</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>而上层业务组件调用Api只需要import一个dart即可，这样对上层业务组件开发人员是透明的，上层不需要了解有哪些Api可用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:common_service/common_service.dart'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="八、Flutter混合开发工程化架构"><a href="#八、Flutter混合开发工程化架构" class="headerlink" title="八、Flutter混合开发工程化架构"></a><strong>八、Flutter混合开发工程化架构</strong></h2><p>基本组件化的架构我们搭建好了，接下来是如何让Flutter混合开发进行完整的工程化管理，我们都知道，对于官方的本地依赖这种方式，我们不能直接用，因为这会直接影响Native工程、开发流程与打包流程，所以我们得基于官方这种依赖方式进行优化改造，于是我们衍生出两种Flutter链接到Native工程的方式：</p>
<blockquote>
<ol>
<li>本地依赖（源码依赖）</li>
<li>远程依赖（产物依赖）</li>
</ol>
</blockquote>
<p>为什么要有这两种方式，首先本地依赖对于打包平台不支持，现有打包平台的环境，只能支持标准的Gradle工程结构进行打包，且本地依赖对于无需开发Flutter相关业务的同学来说是灾难性的，所以便有了远程依赖，远程依赖直接依赖于打包好的Flutter产物，Android通过Gradle依赖，IOS通过Pod远程依赖，这样对其它业务开发同学来说是透明的，他们无需关心Flutter也不需要知道Flutter是否存在</p>
<p>对于这两种依赖模式的使用环境也各不一样</p>
<p><strong>1. 本地依赖</strong><br>本地依赖主要用于需要进行Flutter开发的同学，通过在对应Native工程中配置文件配置是否打开本地Flutter Module依赖，以及配置链接的本地Flutter Module地址，这样Native工程即可自动依赖到本地的Flutter工程，整个过程是无缝的，同时本地依赖是通过源码进行依赖的，也可以很方便的进行Debug调试<br>对于Android中配置文件为本地的<code>local.properties</code>，IOS中为本地新建的<code>local.xcconfig</code>，两个平台的配置属性保持一致：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUTTER_MODULE_LINK_ENABLE=<span class="keyword">true</span></span><br><span class="line">FLUTTER_MODULE_LOCAL_LINK=<span class="regexp">/Users/</span>Sunzxyong<span class="regexp">/FlutterProject/</span>flutter_module</span><br></pre></td></tr></table></figure>
<p><strong>2. 远程依赖</strong><br>远程依赖是把Flutter Module的构成产物发布到远程，然后在Native工程中远程依赖，这种依赖方式是默认的依赖方式，这样对其它开发同学来说是透明的，不影响开发流程和打包平台</p>
<p>上述说到的两种依赖方式，接下来主要说怎么进行这两种依赖方式的工程化管理和定制化</p>
<h3 id="1-无侵入Flutter-SDK源码进行BugFix和定制化"><a href="#1-无侵入Flutter-SDK源码进行BugFix和定制化" class="headerlink" title="1. 无侵入Flutter SDK源码进行BugFix和定制化"></a><strong>1. 无侵入Flutter SDK源码进行BugFix和定制化</strong></h3><p>Flutter SDK在使用时，不免会遇到一些Flutter SDK的问题或Bug，但这些问题通常是在各平台层的链接脚本中出现坑，而如果我们要兼容现有工程和扩展定制化功能，往往会直接修改Flutter SDK源码，这种侵入性的方式极不推荐，这对后续SDK的平滑升级会带来更多的成本</p>
<p>通常出现Bug或需要定制化的脚本往往是和平台链接时相关的，当然排除需要修改<code>dart</code>层Api代码的情况下，这种只能更改源码了，不过这种出bug的几率还是比较小的，比较涉及到SDK的Api层面了。而大概率出现问题需要兼容或进行定制化的几个地方通常为下面几处：</p>
<blockquote>
<ol>
<li><code>$FLUTTER_SDK</code>/packages/flutter_tools/gradle/flutter.gradle</li>
<li><code>$FLUTTER_SDK</code>/bin/cache/artifacts/engine/android-arch/flutter.jar</li>
<li><code>$FLUTTER_MODULE</code>/.android/build.gradle、.android/settings.gradle</li>
<li><code>$FLUTTER_MODULE</code>/.android/Flutter/build.gradle</li>
<li><code>$FLUTTER_MODULE</code>/.ios/Flutter/Generated.xcconfig</li>
<li><code>$FLUTTER_MODULE</code>/.ios/Flutter/podhelper.rb</li>
<li><code>$FLUTTER_MODULE</code>/.ios/Podfile</li>
<li><code>$FLUTTER_SDK</code>/packages/flutter_tools/bin/xcode_backend.sh</li>
</ol>
</blockquote>
<p>而我们需要兼容的Flutter SDK的问题和定制化的点有下面几项：</p>
<blockquote>
<ol>
<li><strong>Android</strong>：Flutter SDK中的Flutter引擎不支持<code>armeabi</code>架构</li>
<li><strong>Android</strong>：Flutter SDK中的<code>flutter.gradle</code>链接脚本不支持非<code>app</code>名称的Application工程</li>
<li><strong>Android</strong>：Flutter SDK中的<code>flutter.gradle</code>链接脚本本地依赖存在<code>flutter_shared</code>资源文件不拷贝Bug</li>
<li><strong>Android</strong>：解决上述几项需要代理<code>build.gradle</code>构建脚本，以及在<code>build.gradle</code>构建脚本中定制化我们的构建产物收集Task</li>
<li><strong>IOS</strong>：Flutter Module中自动生成的.ios中的<code>podhelper.rb</code>ruby脚本使用了Pod中的<code>post_install</code>方法，导致Native工程不能使用或使用了的发生冲突，间接侵入了Native工程与耦合，限制性太强</li>
<li><strong>IOS</strong>：Flutter Module中自动生成的<code>Podfile</code>文件，需要添加我们自己私有的<code>Specs</code>仓库进行定制化</li>
<li><strong>IOS</strong>：解决<code>post_install</code>问题后，Flutter SDK中的<code>xcode_backend.sh</code>链接脚本环境变量的读取问题</li>
</ol>
</blockquote>
<p>为了实现无侵入Flutter SDK，对于上述的这些问题的解决，我们使用代理方式进行Bug的修改和定制化，下面是针对两个平台分别的实现策略</p>
<h4 id="1-Android-1"><a href="#1-Android-1" class="headerlink" title="1. Android"></a><strong>1. Android</strong></h4><p>在Android平台上述问题和定制化的解决策略，对于<code>armeabi</code>架构的支持，我们可以通过脚本进行自动化，上面讲到<code>flutterw</code>的版本自动化管理，同样，我们在里面加段<code>armeabi</code>架构的支持脚本，这样做得好处是后续不需要支持了可以直接移除，通过调用<code>./flutterw armeabi</code>即可自动添加<code>armeabi</code>架构的引擎</p>
<p>对于Flutter SDK中的<code>flutter.gradle</code>链接脚本的问题兼容，不会直接在源码中进行更改，而是把它拷贝出来，命名为<code>flutter_proxy.gradle</code>，然后在代理脚本中进行问题的修复，主要修复点为<code>flutter_shared</code>的支持与<code>app</code>硬编码名称的兼容，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Task</span> copySharedFlutterAssetsTask = <span class="keyword">project</span>.tasks.create(name: <span class="string">"copySharedFlutterAssets$&#123;variant.name.capitalize()&#125;"</span>, type: <span class="keyword">Copy</span>) &#123;</span><br><span class="line">	<span class="keyword">from</span>(<span class="keyword">project</span>.zipTree(chosenFlutterJar))</span><br><span class="line">	<span class="keyword">include</span> <span class="string">'assets/flutter_shared/*'</span></span><br><span class="line">	<span class="keyword">into</span> <span class="string">"src/$&#123;variant.name&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再让<code>copyFlutterAssetsTask</code>任务依赖于它，而<code>app</code>硬编码名称的兼容，则更简单了，通过在Native工程中<code>local.properties</code>配置Module名，再在<code>flutter_proxy.gradle</code>脚本中加入读取该属性代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String appName = <span class="function"><span class="title">loadRootProjectProperty</span><span class="params">(project, <span class="string">"FLUTTER_APP_NAME"</span>, <span class="string">"app"</span>)</span></span></span><br><span class="line">Task mergeAssets = project<span class="class">.tasks</span><span class="class">.findByPath</span>(<span class="string">":$&#123;appName&#125;:merge$&#123;variant.name.capitalize()&#125;Assets"</span>)</span><br></pre></td></tr></table></figure>
<p>而对于<code>build.gradle</code>构建脚本的代理，我们可以通过在执行<code>Gradle</code>构建时，通过<code>-c</code>命令进行<code>settings.gradle</code>的代理，进而代理掉<code>build.gradle</code>和指定Module中的<code>build.gradle</code>脚本，如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .android</span><br><span class="line">.<span class="regexp">/gradlew assembleDebug -c ../</span>script<span class="regexp">/proxy/</span>settings.gradle</span><br></pre></td></tr></table></figure>
<p>而通过代理的<code>settings.gradle</code>文件再进行<code>build.gradle</code>的代理：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getRootProject</span><span class="params">()</span></span><span class="class">.buildFileName</span> = <span class="string">'build_proxy.gradle'</span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(<span class="string">":flutter"</span>)</span></span><span class="class">.buildFileName</span> = <span class="string">"build_proxy.gradle"</span></span><br></pre></td></tr></table></figure>
<p>其中代理的<code>Flutter/build.gradle</code>中的脚本apply会改为修复的Flutter SDK中的脚本代理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">apply</span> from: <span class="string">"<span class="variable">$&#123;project.projectDir.parentFile.parentFile.absolutePath&#125;</span>/script/proxy/flutter_proxy.gradle"</span></span><br></pre></td></tr></table></figure>
<p>这样<code>.android</code>工程在构建时期可以完全由我们自主控制，包括加入一些产物收集插件、产物发布到远程插件等定制功能</p>
<p>不过这种方式需要执行构建命令时手动指定代理脚本，对于本地依赖时Native自动构建来说，是不会指定的，所有基于这种方式，我们再优化一下，因为<code>Flutter Module</code>中<code>.android</code>与<code>.ios</code>工程是通过Flutter SDK内部模版自动生成的，只要执行<code>build|packages get</code>等命令都会自动生成，首先想到是更改Flutter SDK内部工程模版，在Flutter SDK的<code>packages/flutter_tools/templates</code>目录下，不过这与我们无侵入Flutter SDK违背了，所以不能选取这种方式</p>
<p>回想我们的Flutter SDK版本一致性管理是通过<code>flutterw</code>脚本进行自动化的，而最终会链接调用到原生Flutter SDK中的命令，所以，我们可以在<code>flutterw</code>中加入脚本，用于在<code>.android</code>与<code>.ios</code>工程生成后，进行内部脚本文件的替换，把<code>build.gradle</code>和<code>settings.gradle</code>脚本内容直接替换为我们的代理脚本的内容，这样既不侵入Flutter SDK，在后续维护起来也方便，后续不需要这个功能了，只需要把这段脚本代码注释就好了，随即又恢复原生的构建脚本了，<code>flutterw</code>脚本执行过程如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="preprocessor"># ...</span></span><br><span class="line">		link_flutter <span class="string">"$@"</span></span><br><span class="line">    	inject_proxy_build_script</span><br><span class="line">    	<span class="preprocessor"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inject_proxy_build_script</code>这个Shell函数会把对应脚本进行我们的脚本替换掉，当前函数内部也有对应判断，因为<code>flutterw</code>主要用于Flutter SDK版本一致性管理，这里仅对Flutter Module工程生效。所以这种方式不管是在本地依赖构建下还是通过命令行构建都可以完美支持</p>
<h4 id="2-IOS-1"><a href="#2-IOS-1" class="headerlink" title="2. IOS"></a><strong>2. IOS</strong></h4><p>在IOS平台上述问题和定制化的解决策略，对于IOS主要是对<code>Podfile</code>与<code>podhelper.rb</code>脚本进行支持，而对<code>Podfile</code>的支持，这个比较简单，在<code>Podfile</code>头部通过脚本注入我们自己私有的<code>Specs</code>仓库即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="string">'https://***/XXSpecs.git'</span></span><br><span class="line"><span class="keyword">source</span> <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">platform :ios, <span class="string">'8.0'</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure>
<p>这个工作同样在<code>flutterw</code>执行后进行兼容，后续不需要了可以直接注释，这个自动注入脚本也仅对Flutter Module工程生效</p>
<p>而<code>podhelper.rb</code>脚本的兼容，主要是在进行本地依赖时，内部已经用了<code>post_install</code>函数，该函是在pod install后执行，这会与Native已经使用了该函数的发生冲突并报错，所以我们通过<code>flutterw</code>脚本的执行后默认注释掉该脚本中的<code>post_install</code>使用处，但是肯定不能平白无故注释掉，我们要了解这段的作用，其实就是设置环境变量，为后续<code>xcode_backend.sh</code>脚本的构建执行做准备，而注释掉怎么用另外一种方式恢复环境变量的设置这个后面再讲，注释后<code>podhelper.rb</code>脚本代码片段为：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># post_install do |installer|</span></span><br><span class="line"><span class="preprocessor">#     installer.pods_project.targets.each do |target|</span></span><br><span class="line"><span class="preprocessor">#         target.build_configurations.each do |config|</span></span><br><span class="line"><span class="preprocessor">#             config.build_settings['ENABLE_BITCODE'] = 'NO'</span></span><br><span class="line"><span class="preprocessor">#             xcconfig_path = config.base_configuration_reference.real_path</span></span><br><span class="line"><span class="preprocessor">#             File.open(xcconfig_path, 'a+') do |file|</span></span><br><span class="line"><span class="preprocessor">#                 file.puts "#include \"#&#123;File.realpath(File.join(framework_dir, 'Generated.xcconfig'))&#125;\""</span></span><br><span class="line"><span class="preprocessor">#             end</span></span><br><span class="line"><span class="preprocessor">#         end</span></span><br><span class="line"><span class="preprocessor">#     end</span></span><br><span class="line"><span class="preprocessor"># end</span></span><br></pre></td></tr></table></figure>
<p>最终在<code>flutterw</code>自动支持上述处理脚本执行流程为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">		<span class="comment"># ...</span></span><br><span class="line">		link_flutter <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">    	<span class="comment"># ...</span></span><br><span class="line">    	podfile_support</span><br><span class="line">    	podhelper_support</span><br><span class="line">    	collect_ios_product <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内部判断仅针对Flutter Module工程生效，毕竟其它Flutter Plugin工程不需要这种处理</p>
<h3 id="2-本地依赖无侵入流程"><a href="#2-本地依赖无侵入流程" class="headerlink" title="2. 本地依赖无侵入流程"></a><strong>2. 本地依赖无侵入流程</strong></h3><p>我们要做到只通过一个属性配置文件，在配置文件中通过配置开发来打开或关闭本地的Flutter Module链接依赖，只按官方的依赖方式肯定是不行的，不管是Android还是IOS，都会直接侵入Native工程，影响其它无Flutter环境同学的开发且影响打包平台上的打包。所以，肯定得做优化，我们在官方这种依赖方式中加一层，作为<code>代理层</code>，而代理层主要做的工作是判断本地是否有对应的属性配置文件且属性值是否符合本地依赖Flutter Module的条件，如果是则进行本地Flutter Module的依赖，如果不是则Return掉，默认不做任何处理</p>
<p>所以通过这种代理方式即不影响Native工程原先的开发流程，对其它业务开发同学和打包平台也是透明的</p>
<p>对于代理层的实现，Android与IOS平台各不一样</p>
<h4 id="1-Android-2"><a href="#1-Android-2" class="headerlink" title="1. Android"></a><strong>1. Android</strong></h4><p>Android是通过一个<code>Gradle脚本</code>进行自动管理的，这个Gradle脚本主要在<code>settings.gradle</code>和<code>build.gradle</code>中做<code>local.properties</code>配置文件的属性值校验，决定是否开启本地Flutter Module链接的</p>
<h4 id="2-IOS-2"><a href="#2-IOS-2" class="headerlink" title="2. IOS"></a><strong>2. IOS</strong></h4><p>IOS则较为复杂一些，因为涉及到<code>Podfile</code>中的ruby执行脚本代理与<code>Build Phases</code>时期的Shell脚本代理，所以得写两种类型的代理脚本：Ruby和Shell，代理脚本的最终执行还是会调用被代理的脚本，只是在调用前做一层包装逻辑判断。而IOS中本身没有本地配置文件，所以我们新建一个IOS的本地配置文件为<code>local.xcconfig</code>，这个配置文件不随版本进行管理，会gitignore掉，于是，在IOS中<code>Podfile</code>最终调用的脚本是：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(<span class="keyword">File</span>.<span class="keyword">read</span>(<span class="keyword">File</span>.<span class="keyword">join</span>(<span class="string">'./'</span>, <span class="string">'FlutterSupport'</span>, <span class="string">'podhelper_proxy.rb'</span>)), binding)</span><br></pre></td></tr></table></figure>
<p>而在<code>Build Phases</code>调用的是：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> <span class="string">"<span class="subst">$&#123;SRCROOT&#125;</span>/FlutterSupport/xcode_backend_proxy.sh"</span></span><br><span class="line"><span class="string">"<span class="subst">$&#123;SRCROOT&#125;</span>/FlutterSupport/xcode_backend_proxy.sh"</span> flutterBuild</span><br></pre></td></tr></table></figure>
<p>而刚刚上面说到的<code>podhelper.rb</code>脚本中<code>post_install</code>函数被注释掉后怎么用另一种方式进行替换，我们知道这段函数主要就是提供在IOS构建阶段时执行<code>xcode_backend.sh</code>的环境变量的，比如会获取<code>FLUTTER_ROOT</code>等属性值，这些环境变量由Flutter Module中<code>Generated.xcconfig</code>来提供，而如果我们把这个文件的内容通过脚本拷贝到IOS工程下对应构建配置的xcconfig中，如<code>debug.xcconfig</code>、<code>release.xcconfig</code>，这种方式可行，不过会侵入Native工程，导致Native工程中多了这些变量，而且不优雅，我们要做到的是保证无侵入性</p>
<p>既然我们已经通过代理脚本进行代理，那么这些环境变量我们完全可以获取出来，通过Shell脚本的特性，子Shell会继承于父Shell中<code>export</code>的环境变量值，所以，在代理Shell脚本中再加段下面代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">export_xcconfig</span></span>() &#123;</span><br><span class="line">	<span class="built_in">export</span> ENABLE_BITCODE=NO</span><br><span class="line">	<span class="keyword">if</span> [[ <span class="variable">$#</span> != <span class="number">0</span> ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">local</span> g_xcconfig=<span class="variable">$1</span>/.ios/Flutter/Generated.xcconfig</span><br><span class="line">		<span class="keyword">if</span> [[ <span class="operator">-f</span> <span class="string">"<span class="variable">$g_xcconfig</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">			<span class="comment"># no piping.</span></span><br><span class="line">			<span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">  				<span class="keyword">if</span> [[ ! <span class="string">"<span class="variable">$line</span>"</span> =~ ^// ]]; <span class="keyword">then</span></span><br><span class="line">					<span class="built_in">export</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">				<span class="keyword">fi</span></span><br><span class="line">			<span class="keyword">done</span> &lt; <span class="variable">$g_xcconfig</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中注意不能使用管道，管道会在另外一个Shell进程</p>
<h3 id="3-远程依赖产物打包流程"><a href="#3-远程依赖产物打包流程" class="headerlink" title="3. 远程依赖产物打包流程"></a><strong>3. 远程依赖产物打包流程</strong></h3><p>Flutter的远程产物依赖，Android是通过<code>Aar</code>依赖，IOS是通过<code>.a</code>和<code>.framework</code>静态库进行依赖，要进行这些远程依赖很简单，关键是如何打包获取这些依赖的产物以及上传到远程，因为按照现有组件化的打包，除了聚合层Flutter Module中有对应的<code>flutter-debug.aar</code>和<code>App.framework</code>、<code>flutter_assets</code>等产物的生成，其中业务组件和基础组件中，也有对应的打包产物，这些打包产物会对应各自平台打包不同类型产物，Android还是<code>aar</code>，而IOS则是<code>.a</code>静态库了，下面就分别讲下Android与IOS的打包流程</p>
<h4 id="1-Android-3"><a href="#1-Android-3" class="headerlink" title="1. Android"></a><strong>1. Android</strong></h4><p>Android的打包比较简单，通过在Flutter Module中的<code>.android</code>子工程下执行<code>./gradlew assembleRelease</code>，则会在对应Flutter中Android子工程的build目录下输出对应<code>aar</code>产物，而重点是怎么获取依赖的各组件（Flutter Plugin）中的产物，则是通过<code>.flutter-plugins</code>文件，该文件是在<code>packages get</code>时自动生成的，里面包含了该Flutter工程通过<code>Pub</code>所依赖的库，我们可以解析这个文件，来获取对应依赖库的产物</p>
<h4 id="2-IOS-3"><a href="#2-IOS-3" class="headerlink" title="2. IOS"></a><strong>2. IOS</strong></h4><p>IOS上的打包相比Android来说更复杂一些，我们借助<code>.ios/Runner</code>来打包出静态库等产物，所以还需要设置签名，通过在Flutter Module中直接执行<code>./flutterw build ios --release</code>，该命令会自动执行<code>pod install</code>，所以我们不必再单独执行它，IOS中构建出的产物获取也相对繁琐些，除了获取Flutter的相关产物，还需要获取所依赖的各组件的静态库以及头文件，需要获取的产物如下：</p>
<blockquote>
<p>Flutter.framework<br>App.framework<br>FlutterPluginRegistrant<br>flutter_assets<br>所有依赖的Plugin的<code>.a</code>静态库以及头文件</p>
</blockquote>
<p>其中<code>Flutter.framework</code>为Flutter引擎，类似Android中的<code>flutter.so</code>，而<code>App.framework</code>则是Flutter中Dart编译后的产物（Debug模式下它仅为一个空壳，具体Dart代码在flutter_assets中，Release模式下为编译后的机器指令），FlutterPluginRegistrant是所有插件Channel的注册表，也是自动生成的，<code>flutter_assets</code>含字体等资源，剩下一些<code>.a</code>静态库则是各组件在IOS平台层的实现了</p>
<p>而收集IOS产物除了在<code>.ios/Flutter</code>目录下收集<code>*.framework</code>静态库和<code>flutter_assets</code>外，剩下的就是收集<code>.a</code>静态库以及对应的头文件了，而这些产物则是在构建<code>Runner</code>工程后，在Flutter Module下的</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/ios/<span class="variable">$variant-iphoneos</span></span><br></pre></td></tr></table></figure>
<p>目录下，<code>variant</code>对应所构建变体名，我们还是通过解析<code>.flutter-plugins</code>文件，来获取对应所依赖Flutter插件的名称，进而在上述的输出目录下找到对应的<code>.a</code>静态库，但是对应的头文件而不在对应<code>.a</code>静态库目录下，所以对于头文件单独获取，因为解析了<code>.flutter-plugins</code>获取到了KV键值对，对应的V则是该Flutter插件工程地址，所以头文件我们从里面获取</p>
<p>最后还需要获取<code>FlutterPluginRegistrant</code>注册表的静态库以及头文件</p>
<h4 id="3-产物收集与传递依赖"><a href="#3-产物收集与传递依赖" class="headerlink" title="3. 产物收集与传递依赖"></a><strong>3. 产物收集与传递依赖</strong></h4><p>对于通过Flutter Module聚合层构建出来的产物，我们进行收集后再聚合到单独的产物输出目录下，当然这一切都是通过脚本自动做掉的</p>
<p>在Android上，通过Gradle插件Hook <code>assembleTask</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collectAarTask<span class="class">.dependsOn</span> assembleTask</span><br><span class="line">assembleTask<span class="class">.finalizedBy</span> collectAarTask</span><br></pre></td></tr></table></figure>
<p>这样当执行完<code>./gradlew assemble${variant}</code>命令后则会自动进行产物收集</p>
<p>在IOS上，通过<code>flutterw</code>脚本，在构建完后判断构建命令是否是IOS构建命令，进而自动收集构建后的产物：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect_ios_product</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="string">[[ $# != 0 &amp;&amp; $# &gt; 2 ]]</span>; <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> <span class="string">[[ "$1" = "build" &amp;&amp; "$2" = "ios" ]]</span>; <span class="keyword">then</span></span><br><span class="line">			# <span class="keyword">do</span> collect...</span><br><span class="line">		fi</span><br><span class="line">	fi	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应<code>.a</code>静态库和头文件的收集关键脚本代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> [[ ! <span class="string">"<span class="variable">$line</span>"</span> =~ ^// &amp;&amp; ! <span class="string">"<span class="variable">$line</span>"</span> =~ ^<span class="comment"># ]]; then</span></span><br><span class="line">		array=(<span class="variable">$&#123;line//=/ &#125;</span>)</span><br><span class="line">		<span class="built_in">local</span> library=<span class="variable">$product_dir</span>/<span class="variable">$&#123;array[0]&#125;</span>/lib<span class="variable">$&#123;array[0]&#125;</span>.a</span><br><span class="line">		<span class="keyword">if</span> [[ <span class="operator">-f</span> <span class="string">"<span class="variable">$library</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">local</span> plugin=<span class="variable">$dest_dir</span>/plugins/<span class="variable">$&#123;array[0]&#125;</span></span><br><span class="line">			rm -rf <span class="variable">$plugin</span></span><br><span class="line">			mkdir -p <span class="variable">$plugin</span></span><br><span class="line">			cp <span class="operator">-f</span> <span class="variable">$library</span> <span class="variable">$plugin</span></span><br><span class="line">			<span class="built_in">local</span> classes=<span class="variable">$&#123;array[1]&#125;</span>ios/Classes</span><br><span class="line">			<span class="keyword">for</span> header <span class="keyword">in</span> `find <span class="string">"<span class="variable">$classes</span>"</span> -name *.h`; <span class="keyword">do</span></span><br><span class="line">				cp <span class="operator">-f</span> <span class="variable">$header</span> <span class="variable">$plugin</span></span><br><span class="line">			<span class="keyword">done</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"The static library <span class="variable">$library</span> do not exist!"</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$flutter_plugins</span></span><br></pre></td></tr></table></figure>
<p>如下是Android与IOS的打包后产物收集后的目录结构如下：<br><img src="https://raw.githubusercontent.com/Sunzxyong/ImageRepository/master/flutter_product.jpg" width="360"></p>
<p>对于传递依赖的支持，我们知道单独的<code>aar</code>文件以及通过podspec声明这些静态库产物，是会丢失传递依赖的，丢失传递依赖可能导致我们Native工程中没有使用到的一些三方库，而Flutter工程中引用了，然后App运行Crash，而保证传递依赖的方式，则是Android发布到远程Maven，最后通过远程依赖，上述产物只是本地依赖，IOS则是解析所有Flutter插件中的<code>podspec</code>文件，把它还原为JSON格式，通过解析<code>dependency</code>对象，获取对应的依赖库命名以及版本号，最后在IOS远程产物的<code>podspec</code>配置文件中添加这些依赖</p>
<p>对于IOS的远程依赖，我们知道单独建一个独立的Git仓库就可以解决，通过配置好<code>podspec</code>，即可在IOS Native端进行远程依赖，但是像<code>Flutter.framework</code>与<code>App.framework</code>这种大文件，如果直接上传到Git仓库中有些不太友好，比如可以上传到CDN中，然后通过<code>podspec</code>的<code>spec.prepare_command</code>特性，在pod库安装时候预先执行一段脚本把这两个产物拉下来，对于目前来说，可以先传到Git中，这样比较直观与可控，便于版本的管理</p>
<h3 id="4-Flutter混合开发工程化整体流程"><a href="#4-Flutter混合开发工程化整体流程" class="headerlink" title="4. Flutter混合开发工程化整体流程"></a><strong>4. Flutter混合开发工程化整体流程</strong></h3><p><img src="https://raw.githubusercontent.com/Sunzxyong/ImageRepository/master/flutter_hybrid_project.jpg" alt=""></p>
<h2 id="九、后序"><a href="#九、后序" class="headerlink" title="九、后序"></a><strong>九、后序</strong></h2><p>对于现有工程使用Flutter进行混合开发，坑点还是有的，比如性能、页面栈管理等方面，只是目前还未踩到，加上目前Flutter上一些基础库不成熟，对于项目内的重要页面以及动态化强度比较高的页面，目前还是不建议使用Flutter进行开发，如果要使用也须做好降级方案，相反可以使用稍微轻量级点的页面，且在设计时对于Flutter与Native层的通信，应该让Flutter作为消费层消费Native层提供的服务，Native端应做尽量少的改动，最好仅增加一处页面路由的拦截器代码，在拦截器中通过Native与Flutter页面的映射关系，把Native的页面路由跳转替换为Flutter页面路由，这样可以保证Native与Flutter的零耦合</p>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a><strong>关于</strong></h2><p>建了个微信公众号，后续博客会迁往以及在公众号第一时间发布，欢迎关注：<br><img src="https://raw.githubusercontent.com/Sunzxyong/ImageRepository/master/qrcode_Bytes.jpg" width="200"></p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2018/12/16/Flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9E%B6%E6%9E%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>也谈Manifest与资源Merge</title>
      <link>http://zhengxiaoyong.com/2017/07/12/%E4%B9%9F%E8%B0%88Manifest%E4%B8%8E%E8%B5%84%E6%BA%90Merge/</link>
      <guid>http://zhengxiaoyong.com/2017/07/12/%E4%B9%9F%E8%B0%88Manifest%E4%B8%8E%E8%B5%84%E6%BA%90Merge/</guid>
      <pubDate>Wed, 12 Jul 2017 12:00:30 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们知道构建一个apk时必然存在的一个过程—res与manifest的合并，因为资源与manifest除了存在于主资源集中，对于第三方aar或构建变体中也可存在，当构建一个apk时，必然会对它们所含有的资源或manifest进行合并，而不是把所有存在的资源或manifest全打包进apk中，构建一个apk时，主要有以下三种资源会进行merge：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、主资源集(src/main/)&lt;br&gt;2、构建变体(buildType、productFlavor、productFlavorBuildType)&lt;br&gt;3、三方依赖(aar)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个资源名在上述资源集中唯一存在时，那么将直接打包进apk中，当一个资源名在不同资源集中存在多个版本时(资源类型与资源限定符相同情况下)，这时将只有一个会被打包进apk中，这种情况就是通过merge进行处理，同理，manifest也一样，对于相同的标签存在多个版本时，也将进行merge。资源和manifest的merge都遵循如下优先级：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;build variant &amp;gt; build type &amp;gt; product flavor &amp;gt; main source set &amp;gt; library dependencies&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>我们知道构建一个apk时必然存在的一个过程—res与manifest的合并，因为资源与manifest除了存在于主资源集中，对于第三方aar或构建变体中也可存在，当构建一个apk时，必然会对它们所含有的资源或manifest进行合并，而不是把所有存在的资源或manifest全打包进apk中，构建一个apk时，主要有以下三种资源会进行merge：</p>
<blockquote>
<p>1、主资源集(src/main/)<br>2、构建变体(buildType、productFlavor、productFlavorBuildType)<br>3、三方依赖(aar)</p>
</blockquote>
<p>当一个资源名在上述资源集中唯一存在时，那么将直接打包进apk中，当一个资源名在不同资源集中存在多个版本时(资源类型与资源限定符相同情况下)，这时将只有一个会被打包进apk中，这种情况就是通过merge进行处理，同理，manifest也一样，对于相同的标签存在多个版本时，也将进行merge。资源和manifest的merge都遵循如下优先级：</p>
<blockquote>
<p><strong>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</strong></p>
</blockquote>
<a id="more"></a>
<p>下面讲res与manifest的合并策略之前先了解一下构建变体</p>
<h2 id="Build-Type"><a href="#Build-Type" class="headerlink" title="Build Type"></a><strong>Build Type</strong></h2><p>构建类型通过<code>buildTypes</code>代码块进行配置，AS在创建一个Module时会自动默认配置<code>debug</code>和<code>release</code>两个构建类型，其中<code>debug</code>构建类型是每个项目默认的构建类型，任何一个项目创建时都会默认的创建它为默认的构建类型，且默认配置了一个公开通用的签名配置，路径为：<code>~/.android/debug.keystore</code>，这样的目的主要是为了更方便的调试应用，<code>debug</code>构建类型在新项目创建时并不会在<code>buildTypes</code>代码块中创建，不过我们可以手动的配置<code>debug</code>构建类型以便设置我们需要的配置，当然也可以在<code>buildTypes</code>中新建一个构建类型以满足个性需求，如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">buildTypes</span> &#123;</span><br><span class="line">    <span class="title">debug</span> &#123;</span><br><span class="line">        <span class="title">applicationIdSuffix</span> <span class="string">'.debug'</span></span><br><span class="line">        versionNameSuffix <span class="string">'-debug'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beta.initWith(buildTypes.<span class="built_in">debug</span>)</span><br><span class="line">    beta &#123;</span><br><span class="line">        <span class="title">applicationIdSuffix</span> <span class="string">'.beta'</span></span><br><span class="line">        versionNameSuffix <span class="string">'-beta'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="title">minifyEnabled</span> <span class="built_in">false</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中新建一个构建类型可以通过<code>initWith</code>方式来创建（如beta），这样新建的构建类型的配置将于传入的构建类型的所有配置将一样，并且可以在新建的构建类型中来覆写某些不同的配置，另外一个方式即不通过<code>initWith</code>方式，所有的配置将由自己定义，否则将使用默认的值，创建一个构建类型gradle也会对应的创建一个资源集</p>
<h2 id="Product-Flavor"><a href="#Product-Flavor" class="headerlink" title="Product Flavor"></a><strong>Product Flavor</strong></h2><p>产品风味主要被用来创建App的不同的版本，如内测版与线上版，在<code>productFlavors</code>代码块中进行配置，创建一个产品风味对应的也会创建一个资源集，如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">productFlavors</span> &#123;</span><br><span class="line">    <span class="tag">google</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Source-Set"><a href="#Source-Set" class="headerlink" title="Source Set"></a><strong>Source Set</strong></h2><p>资源集位于Module中src目录下，共有以下几种：</p>
<blockquote>
<p>src/<strong><code>main</code></strong>/<br>src/<strong><code>&lt;buildType&gt;</code></strong>/<br>src/<strong><code>&lt;productFlavor&gt;</code></strong>/<br>src/<strong><code>&lt;productFlavorBuildType&gt;</code></strong>/</p>
</blockquote>
<p>如我们的主资源集<code>src/main</code>，AS会默认创建<code>main/</code>主资源集目录，用于存储要在所有构建类型、产品风味、构建变体之间共享的资源，我们项目中的主要资源也位于主资源集目录下，当我们新建一个<code>buildType</code>或<code>productFlavor</code>时，gradle也会相应的创建一个对应的资源集，该资源集的名称和构建类型、产品风味的名称一样，位于src目录下，只不过这需要我们手动创建对应的目录添加需要的资源，当构建类型和产品风味都存在时，gradle还会把它们进行组合成一个<code>buildVariant</code>构建变体，名称为产品风味与构建类型的名称的组合，gradle也会为构建变体创建一个资源集，名称和构建变体名称一样，所以，在创建了一个<code>beta</code>构建类型和<code>google</code>产品风味的情况下，共有如下的资源集：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-07-12-14994128490664.jpg" alt=""><br>对于每个资源集，我们可以在<code>sourceSets</code>代码块中进行各自配置，如<code>manifest</code>、<code>res</code>自定义路径等：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java.srcDirs = [<span class="symbol">'src</span>/main/java', <span class="symbol">'other</span>/java']</span><br><span class="line">        res.srcDirs = [<span class="symbol">'src</span>/main/res', <span class="symbol">'src</span>/main/res2']</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beta &#123;</span><br><span class="line">        res.srcDirs = [<span class="symbol">'src</span>/beta/res', <span class="symbol">'src</span>/beta/res2']</span><br><span class="line">        manifest.srcFile <span class="symbol">'src</span>/beta/<span class="type">AndroidManifest</span>.xml'</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    googleBeta &#123;</span><br><span class="line">        res.srcDirs = [<span class="symbol">'src</span>/googleBata/res']</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Build-Variant"><a href="#Build-Variant" class="headerlink" title="Build Variant"></a><strong>Build Variant</strong></h2><p>构建变体=productFlavor+buildType，在创建<code>productFlavor</code>时gradle自动结合构建类型生成对应的构建变体，没有创建产品风味时将为构建类型，如：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-07-12-14994211392401.jpg" alt=""></p>
<h3 id="Library-Module"><a href="#Library-Module" class="headerlink" title="Library Module"></a><strong>Library Module</strong></h3><p>library依赖于其它module时将默认使用release构建类型，如果要更改为我们自己的构建类型时，有两种方法：</p>
<h4 id="1、defaultPublishConfig"><a href="#1、defaultPublishConfig" class="headerlink" title="1、defaultPublishConfig"></a><strong>1、defaultPublishConfig</strong></h4><p>我们可以使用<code>defaultPublishConfig</code>来配置library的依赖构建变体，假如该library构建变体如上，新加了一个beta构建类型和google产品风味，那么依赖构建类型需要为googleBeta，即在library中配置：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultPublishConfig <span class="string">"googleBeta"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>告诉gradle该library默认发布构建类型为<code>googleBeta</code></p>
<h4 id="2、publishNonDefault"><a href="#2、publishNonDefault" class="headerlink" title="2、publishNonDefault"></a><strong>2、publishNonDefault</strong></h4><p>上面这种方式限定死了library的发布构建类型，下面这种将让library更加灵活，完全由宿主Module控制，在library中配置：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">android </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  // Note that this might increase <span class="keyword">build </span>times <span class="keyword">because </span>Gradle must</span><br><span class="line">  // <span class="keyword">build </span><span class="keyword">multiple </span>AARs, instead of only one.</span><br><span class="line">  publishNonDefault true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置<code>publishNonDefault</code>为true，将告诉gradle所有的构建变体将可用，具体使用哪个由所依赖的Module进行配置，所以，在宿主Module中进行依赖配置：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">compile</span> <span class="tag">project</span>(<span class="attribute">path</span>:<span class="string">':library'</span>, <span class="attribute">configuration</span>:<span class="string">'demoDebug'</span>)</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="tag">debugCompile</span> <span class="tag">project</span>(<span class="attribute">path</span>:<span class="string">':library'</span>, <span class="attribute">configuration</span>:<span class="string">'demoDebug'</span>)</span><br><span class="line">    <span class="tag">releaseCompile</span> <span class="tag">project</span>(<span class="attribute">path</span>:<span class="string">':library'</span>, <span class="attribute">configuration</span>:<span class="string">'release'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宿主将引用library的<code>demoDebug</code>构建变体的版本</p>
<h2 id="Resource-Merge"><a href="#Resource-Merge" class="headerlink" title="Resource Merge"></a><strong>Resource Merge</strong></h2><p>一个资源是否需要merge主要看资源名是否唯一，该唯一性是在含有相同的资源类型和资源限定符的情况下，资源merge遵循如下优先级：</p>
<blockquote>
<p><strong>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</strong></p>
</blockquote>
<p>如：<br>主资源集中含有资源：</p>
<blockquote>
<p>src/main/res/layout/foo.xml<br>src/main/res/layout-land/foo.xml<br>src/main/res/drawable/avatar.png</p>
</blockquote>
<p>beta资源集中含有资源：</p>
<blockquote>
<p>src/beta/res/layout/foo.xml</p>
</blockquote>
<p>googleBeta资源集中含有资源：</p>
<blockquote>
<p>src/googleBeta/res/drawable/avatar.png</p>
</blockquote>
<p>若采用<code>googleBeta</code>构建变体构建，最终的apk中将包含的资源为：</p>
<blockquote>
<p>src/main/res/layout-land/foo.xml<br>src/beta/res/layout/foo.xml<br>src/googleBeta/res/drawable/avatar.png</p>
</blockquote>
<p>如果一个资源集中资源目录存在多个，且它们都包含一个相同的资源，那么在merge时将会报duplicate resources错误</p>
<blockquote>
<p>如果多个 AAR 库之间发生冲突，将使用依赖项列表首先列出（位于 dependencies 块顶部）的库中的资源，所以为了避免常用资源 ID 的资源冲突，请使用在模块（或在所有项目模块）中具有唯一性的前缀或其他一致的命名方案</p>
</blockquote>
<p>上面说到资源merge是在相同的资源类型与资源限定符的情况下，资源类型比如drawable、layout、values等等，资源限定符是加在资源类型后面用于限定该资源所能应用的条件，比如drawable-xxhdpi、drawable-en-port等等，限定符目前共有19中，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">配置</th>
<th style="text-align:center">限定符值示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MCC 和 MNC</td>
<td style="text-align:center">mcc310</td>
<td style="text-align:center">移动国家代码、移动网络代码</td>
</tr>
<tr>
<td style="text-align:center">语言和区域</td>
<td style="text-align:center">en、fr</td>
<td style="text-align:center">由两个字母组成的语言代码</td>
</tr>
<tr>
<td style="text-align:center">布局方向</td>
<td style="text-align:center">ldrtl、ldltr</td>
<td style="text-align:center">应用的布局方向</td>
</tr>
<tr>
<td style="text-align:center">最小宽度</td>
<td style="text-align:center">sw720dp</td>
<td style="text-align:center">设备可用屏幕区域的最小尺寸(宽或高)</td>
</tr>
<tr>
<td style="text-align:center">可用宽度</td>
<td style="text-align:center">w720dp</td>
<td style="text-align:center">设备最小可用屏幕宽度</td>
</tr>
<tr>
<td style="text-align:center">可用高度</td>
<td style="text-align:center">h1024dp</td>
<td style="text-align:center">设备最小可用屏幕高度</td>
</tr>
<tr>
<td style="text-align:center">屏幕尺寸</td>
<td style="text-align:center">normal、large</td>
<td style="text-align:center">设备的屏幕密度</td>
</tr>
<tr>
<td style="text-align:center">屏幕纵横比</td>
<td style="text-align:center">long、notlong</td>
<td style="text-align:center">设备屏幕是否为宽屏</td>
</tr>
<tr>
<td style="text-align:center">圆形屏幕<span class="Apple-tab-span" style="white-space:pre"></span></td>
<td style="text-align:center">round、notround</td>
<td style="text-align:center">设备屏幕是否为圆屏</td>
</tr>
<tr>
<td style="text-align:center">屏幕方向</td>
<td style="text-align:center">port、land</td>
<td style="text-align:center">设备当前的方向</td>
</tr>
<tr>
<td style="text-align:center">UI 模式</td>
<td style="text-align:center">car、watch</td>
<td style="text-align:center">设备运行时变化的模式</td>
</tr>
<tr>
<td style="text-align:center">夜间模式</td>
<td style="text-align:center">night、notnight</td>
<td style="text-align:center">是否夜间模式</td>
</tr>
<tr>
<td style="text-align:center">屏幕像素密度</td>
<td style="text-align:center">xhdpi、xxhdpi、nodpi</td>
<td style="text-align:center">设备像素密度</td>
</tr>
<tr>
<td style="text-align:center">触摸屏类型</td>
<td style="text-align:center">finger、notouch</td>
<td style="text-align:center">设备上的触摸屏类型</td>
</tr>
<tr>
<td style="text-align:center">键盘可用性</td>
<td style="text-align:center">keysexposed、keyssoft</td>
<td style="text-align:center">设备可用的键盘</td>
</tr>
<tr>
<td style="text-align:center">主要文本输入法</td>
<td style="text-align:center">nokeys、qwerty</td>
<td style="text-align:center">设备可用的主要文本输入法</td>
</tr>
<tr>
<td style="text-align:center">导航键可用性</td>
<td style="text-align:center">navexposed、navhidden</td>
<td style="text-align:center">设备导航键是否处于隐藏状态</td>
</tr>
<tr>
<td style="text-align:center">主要非触摸导航方法</td>
<td style="text-align:center">nonav</td>
<td style="text-align:center">设备可用的导航方法类型</td>
</tr>
<tr>
<td style="text-align:center">平台版本（API 级别）</td>
<td style="text-align:center">v4、v7</td>
<td style="text-align:center">设备支持的最小 API 级别</td>
</tr>
</tbody>
</table>
<p>对于资源文件夹的命名，也必须遵循上表出现顺序的规则，如<code>drawable-hdpi-port</code>这是错误的命名，而应该是<code>drawable-port-hdpi/</code>，在资源进行merge时，也将是对相同限定符与类型的资源进行合并，而限定符或类型不相同的资源不进行合并</p>
<h3 id="Resource-Overlay"><a href="#Resource-Overlay" class="headerlink" title="Resource Overlay"></a><strong>Resource Overlay</strong></h3><p>资源的overlay重叠包机制和资源merge差不多，主要是对资源一种额外补充，当在主资源集中未找到该资源时，这时会在我们添加的重叠包中进行查找，可通过aapt的<code>-S</code>、<code>--auto-add-overlay</code>配置来添加额外的资源重叠包和确保重叠包可用<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-07-12-14996947290552.jpg" alt=""><br>我们可以通过配置<code>aaptOptions</code>来为app添加资源重叠包提供资源，在gradle中配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">aaptOptions</span> &#123;</span><br><span class="line">    <span class="title">additionalParameters</span> <span class="string">'-S'</span>, <span class="string">'src/main/res2'</span>,</span><br><span class="line">            <span class="string">'-S'</span>, <span class="string">'src/main/res3'</span>,</span><br><span class="line">            <span class="string">'--auto-add-overlay'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在主资源集中资源未定义时，而res2与res3中都定义了，那么在app中引用该资源将会使用res2目录中的，假如res2未定义，那么将使用res3中的，如果res2与res3互换位置，那么则优先使用最先扫描到的目录res3的资源</p>
<h2 id="Manifest-Merge"><a href="#Manifest-Merge" class="headerlink" title="Manifest Merge"></a><strong>Manifest Merge</strong></h2><p>在构建一个apk时，manifest文件主要来自三种地方：主资源集、构建变体、第三方aar，对此，对于众多不同地方的manifest文件势必需要合成一个最终的manifest文件打包进apk中，对于manifest的merge，和资源merge一样遵循相同的优先级：</p>
<blockquote>
<p><strong>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependencies</strong></p>
</blockquote>
<p>和资源merge不同的是，manifest文件的merge并不是从高优先级开始查找，找到了则将被添加至最终apk资源目录中，因为资源merge针对的是一个drawable、layout或string的类型的一个独立资源，而manifest是由众多节点标签和属性进行配置的，所以对于manifest的merge需要对任何一个manifest内容进行收集再合并<br>manifest合并遵循从低优先级到高优先级的合并顺序，如下：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-07-12-14995251974843.jpg" alt=""></p>
<p>也就是对于aar中的manifest文件会先进行合并至主资源集中的manifest文件中，然后主资源集的再合并至构建变体的manifest文件中，而这个构建变体的manifest为最终的manifest文件，将打包至apk中</p>
<blockquote>
<p>值得注意的一点，在<code>build.gradle</code>中配置的构建属性将会直接替换manifest中的对应的属性，如在manifest中定义<code>versionCode</code>、<code>versionName</code>或<code>targetSdkVersion</code>等，只要在gradle文件中也相应的配置了对应的值，gradle的值总会覆盖manifest中的值，那么apk最终将使用gradle中配置的</p>
</blockquote>
<h3 id="Manifest合并策略-合并冲突启发式算法"><a href="#Manifest合并策略-合并冲突启发式算法" class="headerlink" title="Manifest合并策略-合并冲突启发式算法"></a><strong>Manifest合并策略-合并冲突启发式算法</strong></h3><p>Manifest合并工具在合并时会把某个manifest文件中标签元素与其它待合并的manifest文件中对应的标签元素进行匹配，而这个匹配的过程则是由一个<strong>合并关键字</strong>进行匹配的，比如manifest中配置了众多<code>activity</code>标签，单靠这个标签是不能对应的识别该Activity是否与另外一个manifest文件中所表示的一样。所以合并工具会根据每个标签所具备的唯一标识<code>合并关键字</code>进行与其它manifest中标签进行匹配，进而通过如下三种合并策略进行manifest文件的合并：</p>
<blockquote>
<p>1、<strong>合并</strong>—将所有非冲突属性合并到同一标签中，如果配置了<code>合并规则标记</code>那么将会按各自配置的合并规则进行合并属性与子标签，如果有属性发生冲突，那么请使用<code>合并规则标记</code>来配置需要以哪种规则进行合并，否则在项目编译合并时将报错，大都数标签使用该策略<br>2、<strong>仅合并子项</strong>—该标签仅保留优先级最高的manifest文件提供的属性，如<code>&lt;manifest&gt;</code>标签中的属性将永远使用优先级最高的manifest文件<br>3、<strong>保留</strong>—将子标签直接将其添加至合并文件中的父元素，如<code>&lt;intent-filter&gt;</code>标签，将直接添加其它manifest文件中该标签至合并文件</p>
</blockquote>
<p>上面所说大都标签元素都采用合并策略进行合并的，使用仅合并子项策略的有<code>&lt;manifest&gt;</code>标签元素，使用保留策略的有<code>&lt;intent-filter&gt;</code>标签元素。在进行manifest文件合并时，低优先级的manifest文件中的标签元素如果与高优先级的manifest文件中的不匹配时，那么这些标签元素将直接添加到合并后的manifest中，如果有匹配的标签元素，那么将会将匹配的标签的所有属性进行合并（入股配置了合并规则标记，那么将采取该标记的合并规则来进行合并），如果有相同的属性但值不同则合并会冲突，此时需要配置一个合并规则标记来处理冲突，如下，manifest默认的合并规则：</p>
<table>
<thead>
<tr>
<th style="text-align:center">低优先级属性</th>
<th style="text-align:center">高优先级属性</th>
<th style="text-align:center">属性合并结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">没有值</td>
<td style="text-align:center">没有值</td>
<td style="text-align:center">没有值</td>
</tr>
<tr>
<td style="text-align:center">值B</td>
<td style="text-align:center">没有值</td>
<td style="text-align:center">值B</td>
</tr>
<tr>
<td style="text-align:center">没有值</td>
<td style="text-align:center">值A</td>
<td style="text-align:center">值A</td>
</tr>
<tr>
<td style="text-align:center">值A</td>
<td style="text-align:center">值A</td>
<td style="text-align:center">值A</td>
</tr>
<tr>
<td style="text-align:center">值B</td>
<td style="text-align:center">值A</td>
<td style="text-align:center">冲突-须使用合并规则标记处理</td>
</tr>
</tbody>
</table>
<p>Manifest合并时一些特殊的处理方式：</p>
<blockquote>
<p>1、<code>&lt;manifest&gt;</code>标签中的属性绝不合并，仅使用优先级最高的manifest文件中的属性<br>2、对于<code>&lt;manifest&gt;</code>的子标签<code>&lt;uses-feature&gt;</code>与<code>&lt;application&gt;</code>的子标签<code>uses-library</code>，如果在合并时出现冲突，那么系统将默认将应用该标签的<code>android:required</code>属性为true，并包含所有manifest对应该标签所需要的功能或库<br>3、<code>&lt;uses-sdk&gt;</code>标签始终使用优先级最高的manifest中的值，如果在gradle中定义了对应的值，那么将始终使用gradle中的，如果出现第三方aar中定义的minSdkVersion大于当前最高优先级manifest定义的，那么将需要使用<code>overrideLibrary</code>属性来处理此冲突<br>4、对于<code>&lt;intent-filter&gt;</code>标签，会将所有manifest中的对应该标签添加至合并后的manifest文件中</p>
</blockquote>
<p>对于上面的当第三方aar的minSdkVersion大于最高优先级的manifest文件中定义的，那么在合并时将出错，使用<code>overrideLibrary</code>属性进行处理，该属性值是一个或者多个aar库的包名，假如lib1与lib2的minSdkVersion值都大于最高优先级清单中定义的14，那么则在该manifest中uses-sdk标签加入overrideLibrary属性进行处理，如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk <span class="string">android:</span>targetSdkVersion=<span class="string">"24"</span> <span class="string">android:</span>minSdkVersion=<span class="string">"14"</span></span><br><span class="line"><span class="label">          tools:</span>overrideLibrary=<span class="string">"com.example.lib1, com.example.lib2"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Manifest合并规则标记"><a href="#Manifest合并规则标记" class="headerlink" title="Manifest合并规则标记"></a><strong>Manifest合并规则标记</strong></h3><p>合并规则标记是一个标签的属性，它属于android tools命名空间，它可改变合并时默认的合并行为，一般我们在某个manifest文件内定义了这些标记，那么在比它低优先级的manifest与它进行合并时，高优先级清单将应用这些合并规则进行合并，如我们最常用到的<code>tools:replace=&quot;attr, ...&quot;</code>属性标记，通常是一些三方aar库中的清单文件中定义了一些属性与主清单或更高优先级的清单文件中的对应标签的属性冲突了，所以在高优先级的清单中冲突的标签配置该属性，表示始终使用高优先级清单中该标签的属性值</p>
<p>合并规则标记类型分两种：</p>
<blockquote>
<p><strong>节点标记</strong>—标记一个节点标签，对该标签的所有属性与所有子标签都应用该合并规则<br><strong>属性标记</strong>—标记一个节点标签，仅对该标记中声明的属性应用该合并规则</p>
</blockquote>
<h4 id="节点标记"><a href="#节点标记" class="headerlink" title="节点标记"></a><strong>节点标记</strong></h4><ul>
<li><strong>tools:node=”merge”</strong></li>
</ul>
<p>该规则是manifest所有标签默认的合并规则，可不显示声明，在manifest文件在合并时没有冲突时，则会合并该标记的标签中所有的属性与子标签，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:node</span>=<span class="value">"merge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> </span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:node=”merge-only-attributes”</strong></li>
</ul>
<p>该规则是仅仅合并所标记的标签中的属性，但不合并嵌套的子标签，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:node</span>=<span class="value">"merge-only-attributes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:node=”remove”</strong></li>
</ul>
<p>从合并清单中删除用此标记的标签，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">tools:node</span>=<span class="value">"remove"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:node=”removeAll”</strong></li>
</ul>
<p>与tools:node=”remove”类似，remove只是删除一个它所标记的标签，而removeAll则是删除与此标签相匹配的所有标签（在相同的父标签内），如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">tools:node</span>=<span class="value">"removeAll"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到在该父标签内，所有有关<code>&lt;intetn-filter&gt;</code>的标签全部删除了</p>
<ul>
<li><strong>tools:node=”replace”</strong></li>
</ul>
<p>用此标记所标记的标签，将完全替换掉低优先级所对应的标签（包含子标签元素），也就是完全保留该标记所标记的标签的内容，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"low"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"xixi"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:node</span>=<span class="value">"replace"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"high"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"haha"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"high"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"haha"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>&lt;intent-filter&gt;</code>标签是以保留策略进行合并的，所以对它标记将无作用，可对<code>meta-data</code>进行标记，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"say"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"hi"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"say"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"hello"</span></span><br><span class="line">        <span class="attribute">tools:node</span>=<span class="value">"replace"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.action1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>            </span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"say"</span></span><br><span class="line">        <span class="attribute">android:value</span>=<span class="value">"hello"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:node=”strict”</strong></li>
</ul>
<p>配置了严格模式的标签，当在合并时只要该标签任何属性或子标签与合并时另外清单中的不完全一样时，将会报错，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:node</span>=<span class="value">"strict"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并时将报一个Merging Error，提示两个清单中所对应的元素不一样</p>
<h4 id="属性标记"><a href="#属性标记" class="headerlink" title="属性标记"></a><strong>属性标记</strong></h4><ul>
<li><strong>tools:remove=”attr, …”</strong></li>
</ul>
<p>从合并清单中删除指定的属性，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:remove</span>=<span class="value">"android:launchMode"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:replace=”attr, …”</strong></li>
</ul>
<p>从合并清单中，利用高优先级清单文件中的属性值替换低优先级的属性值，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"standard"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:replace</span>=<span class="value">"android:launchMode"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并后的清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"standard"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tools:strict=”attr, …”</strong></li>
</ul>
<p>指定的属性值在合并时，若低优先级的与高优先级的不一直时将报错，这是所有属性默认的标记配置，如：<br>低优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"singleTask"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>高优先级清单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.zxy.merge.demo.MainActivity"</span></span><br><span class="line">    <span class="attribute">android:launchMode</span>=<span class="value">"standard"</span></span><br><span class="line">    <span class="attribute">android:screenOrientation</span>=<span class="value">"portrait"</span></span><br><span class="line">    <span class="attribute">tools:strict</span>=<span class="value">"android:launchMode"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>合并时将报Merging Error，因为<code>launchMode</code>在不同清单中属性值不一样</p>
<h3 id="查看合并后的Manifest"><a href="#查看合并后的Manifest" class="headerlink" title="查看合并后的Manifest"></a><strong>查看合并后的Manifest</strong></h3><p>通过AS的Merged Manifest工具进行查看，选择最高优先级的清单文件，如：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-07-12-14998441405889.jpg" alt=""><br>不同的颜色块对应右边<code>Manifest Sources</code>中所对应的manifest路径来源，上图表示manifest来源有三个不同的资源集，而下面的表示虽然这些资源集含有manifest文件，但是不含构成最终manifest文件的元素或属性值，右边的最下方将会显示Merging Log或合并出错后Merging Error</p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2017/07/12/%E4%B9%9F%E8%B0%88Manifest%E4%B8%8E%E8%B5%84%E6%BA%90Merge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>也谈图片压缩</title>
      <link>http://zhengxiaoyong.com/2017/04/23/%E4%B9%9F%E8%B0%88%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</link>
      <guid>http://zhengxiaoyong.com/2017/04/23/%E4%B9%9F%E8%B0%88%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</guid>
      <pubDate>Sun, 23 Apr 2017 08:44:20 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;随着目前设备像素的不断提高，基本随便一张照片即是M级别的大小，对于如此大的图片，不管是在内存空间、带宽资源和服务器数据空间上都是非常耗费的，特别是在移动端，由图片引起的OOM和图片上传质量过大等问题我想大家都遇到过，所以对于图片内存占用上和物理空间占用上进行压缩很有必要，在Android上，我们使用到的图片格式无非这五种：PNG、JPEG、Webp、SVG、GIF。其中GIF的位深为8位，所以文件通常比较小而且支持alpha通道以及动画，Webp在等质量的大小上和等大小的清晰度上都占极大优势，而SVG矢量图是由xml文件进行描述的，可以适配于任何分辨率的设备而保证图像不失真，Google的官方视频中也提到可用这两种格式进行某些场景下替换PNG或JPEG图像，这不但能节约带宽资源还能提高图片加载速度，所以图片压缩主要是对PNG和JPEG这两种格式，关于图片的压缩，有无损压缩和有损压缩两种方式，这两种压缩方式区别如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;无损压缩&lt;/strong&gt;：通过对冗余数据的存储方式进行优化，该方式不会丢失文件内容，压缩率受冗余度的影响，所以压缩率较低&lt;br&gt;&lt;strong&gt;有损压缩&lt;/strong&gt;：通过丢失不会对文件造成太大影响的数据来达到压缩效果，所以压缩率较高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中PNG是无损压缩格式图片，JPEG是有损压缩格式图片，所以对应的也有各自的压缩算法，在Android系统中，png的压缩是使用libpng进行压缩，场景有两个：编译阶段以及api层调用方式进行压缩。其中在编译阶段通过aapt打包工具会对drawable目录下png图片进行压缩，压缩率大约在40%以下，如果我们对编译后的apk进行解压，可以发现解压后drawable目录下的png图片比原先的变小了，但是，也有例外，对于&lt;code&gt;NinePatch(.9)&lt;/code&gt;图片却变大了，这里先讲下原因，因为对于&lt;code&gt;.9&lt;/code&gt;图片在编译过程中aapt会对它额外进行处理，使得&lt;code&gt;.9&lt;/code&gt;图片会增加2~3个不同类型的&lt;code&gt;Chunk&lt;/code&gt;块（&lt;strong&gt;注&lt;/strong&gt;：api层调用方式进行压缩不会对&lt;code&gt;.9&lt;/code&gt;进行额外处理），而jpeg的压缩是用libjpeg（7.0后有变化，后面另外说）进行压缩，场景只有在api层进行调用方式进行压缩。下面将主要围绕图片的压缩原理、压缩策略以及在Android上的运用进行讲解。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>随着目前设备像素的不断提高，基本随便一张照片即是M级别的大小，对于如此大的图片，不管是在内存空间、带宽资源和服务器数据空间上都是非常耗费的，特别是在移动端，由图片引起的OOM和图片上传质量过大等问题我想大家都遇到过，所以对于图片内存占用上和物理空间占用上进行压缩很有必要，在Android上，我们使用到的图片格式无非这五种：PNG、JPEG、Webp、SVG、GIF。其中GIF的位深为8位，所以文件通常比较小而且支持alpha通道以及动画，Webp在等质量的大小上和等大小的清晰度上都占极大优势，而SVG矢量图是由xml文件进行描述的，可以适配于任何分辨率的设备而保证图像不失真，Google的官方视频中也提到可用这两种格式进行某些场景下替换PNG或JPEG图像，这不但能节约带宽资源还能提高图片加载速度，所以图片压缩主要是对PNG和JPEG这两种格式，关于图片的压缩，有无损压缩和有损压缩两种方式，这两种压缩方式区别如下：</p>
<blockquote>
<p><strong>无损压缩</strong>：通过对冗余数据的存储方式进行优化，该方式不会丢失文件内容，压缩率受冗余度的影响，所以压缩率较低<br><strong>有损压缩</strong>：通过丢失不会对文件造成太大影响的数据来达到压缩效果，所以压缩率较高</p>
</blockquote>
<p>其中PNG是无损压缩格式图片，JPEG是有损压缩格式图片，所以对应的也有各自的压缩算法，在Android系统中，png的压缩是使用libpng进行压缩，场景有两个：编译阶段以及api层调用方式进行压缩。其中在编译阶段通过aapt打包工具会对drawable目录下png图片进行压缩，压缩率大约在40%以下，如果我们对编译后的apk进行解压，可以发现解压后drawable目录下的png图片比原先的变小了，但是，也有例外，对于<code>NinePatch(.9)</code>图片却变大了，这里先讲下原因，因为对于<code>.9</code>图片在编译过程中aapt会对它额外进行处理，使得<code>.9</code>图片会增加2~3个不同类型的<code>Chunk</code>块（<strong>注</strong>：api层调用方式进行压缩不会对<code>.9</code>进行额外处理），而jpeg的压缩是用libjpeg（7.0后有变化，后面另外说）进行压缩，场景只有在api层进行调用方式进行压缩。下面将主要围绕图片的压缩原理、压缩策略以及在Android上的运用进行讲解。<br><a id="more"></a></p>
<h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a><strong>色彩空间</strong></h2><p>在此之前，我们先了解一下ColorSpace(色彩空间)，通常来说，我们看一张彩色图片，会有几千甚至上万种颜色构成，色彩空间就是用来表示图片所构成的色彩范围，对于图片最常用的是使用三原色组成的<code>RGB</code>色彩空间，它最大可表示<code>2^24</code>(16777216)种颜色，其它的色彩空间还有<code>YUV</code>、<code>CMYK</code>、<code>YCCK</code>等，其中<code>YUV</code>在视频的开发方面会经常涉及到，它主要用于表示彩色视频中彩色图像的颜色空间，为什么使用这种呢？因为它节约带宽，每个像素位深最大不超过12位，最小为6位，在此不过多描述，了解即可，顺便提一点平时在进行视频相关开发时，进行视频采集到的图像数据都是<code>YUV</code>编码的，如果需保存某一帧图像，需把图像数据编码方式<code>YUV</code>转成<code>RGB</code>。</p>
<p>上面说到<code>RGB</code>色彩空间，它根据每个分量的所占位数不同又可以分为这两种：<code>RGB_565</code>、<code>RGB_888</code>，其中带alpha通道的有这两种：<code>ARGB_4444</code>、<code>ARGB_8888</code>，区别如下：</p>
<blockquote>
<p><strong>RGB_565</strong>：每个像素占两个字节，R分量占5位，G分量占6位，B分量占5位，最多能表示<code>2^16</code>(65536)中颜色<br><strong>RGB_888</strong>：每个像素占三个字节，R、G、B分量各占8位，最多能表示<code>2^24</code>(16777216)中颜色<br><strong>ARGB_4444</strong>：每个像素占两个字节，A、R、G、B分量各占4位，最多能表示<code>2^12</code>(4096)中颜色，成像效果比较差，所以Google给了它一个<code>Deprecated</code>，并且v4.4+后如果使用了它会自动转成用<code>ARGB_8888</code><br><strong>ARGB_8888</strong>：每个像素占四个字节，A、R、G、B分量各占8位，最多能表示<code>2^24</code>(16777216)中颜色，其中前面8位alpha（0~255）通道表示每个像素点的透明度</p>
</blockquote>
<h2 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a><strong>存储形式</strong></h2><p>图片的存储形式，主要以以下三种形式存在：File、Stream、Bitmap。其中在Android上File主要有PNG、JPEG、XML(VectorDrawable)、Webp和GIF这五种类型格式进行存储，下面分别对这三种存储形式以及压缩方式进行分析。</p>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a><strong>PNG</strong></h3><p>PNG是一种无损压缩的图像存储格式，正由于它使用的是无损压缩算法进行压缩，所以相同像素宽高的图像保存为PNG在文件大小上比JPEG往往要大的多，一般是JPEG大小的几倍左右。由于无损压缩不会丢失图像数据，并且支持alpha通道而且完整的保存了图像数据且无锯齿，所以一般应用在PS素材或图标上，这就为什么不管Android和iOS图标都是使用的png格式。</p>
<p>PNG图像根据每个像素位数的不同，可分为三种格式：<code>PNG8</code>、<code>PNG24</code>、<code>PNG32</code>。PNG8只支持256色，有索引色透明和Alpha透明两种方式，索引色透明只能简单的指明一个像素点为透明还是不透明，Alpha透明则支持像素点的透明度，PNG24支持全色1670万色，只支持不透明，PNG32支持全色1670万色，在PNG24基础上增加了8位的alpha分量，支持Alpha透明，目前大部分PNG图片使用的格式大都为PNG32。</p>
<h4 id="PNG数据结构"><a href="#PNG数据结构" class="headerlink" title="PNG数据结构"></a><strong>PNG数据结构</strong></h4><p>一个标准PNG图像文件数据结构如下：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-04-23-14926780180052.jpg" alt=""><br>其中一个最简单的PNG图像应该至少包含PNG文件的签名<code>Signature</code>、文件头数据块<code>IHDR</code>、图像内容数据块<code>IDAT</code>以及图像结束数据块<code>IEND</code>，这三个的数据块叫做<code>关键数据块</code>，是每一个PNG文件必须包含的，否则PNG文件将无法正常显示，另外还有<code>辅助数据块</code>，如：<code>PLTE</code>(调色板数据块，仅用于索引PNG)、<code>tEXt</code>(文本信息数据块)，这些辅助数据块是可选的，用于额外表示一个PNG文件的内容。<br>这些Chunk都由四部分内容组成：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-04-23-14927460668608.jpg" alt=""><br>含义如下：</p>
<blockquote>
<p><strong>Length</strong>：占4个字节，表示该Chunk中Data域的长度<br><strong>Type</strong>：占4个字节，表示该Chunk的类型，如：IHDR、IDAT等<br><strong>Data</strong>：占n个字节，存储着该Chunk的数据<br><strong>CRC</strong>：占4个字节，循环冗余校验码</p>
</blockquote>
<p>下面主要说下这三个关键数据块，它们表示的含义如下：</p>
<blockquote>
<p><strong>Signature</strong>：占8个字节，用于表示该文件是一个PNG文件，内容固定<br><strong>IHDR</strong>：占25字节，其中Data域占13个字节，用于表示图像的基本信息，如图像的宽高与位深等，并且它永远都是第一个数据块<br><strong>IDAT</strong>：占n个字节，用于表示图像的数据信息，它存储真实的图像数据，在一个PNG文件中，该数据块出现的数量为&gt;=1<br><strong>IEND</strong>：占12个字节，用于表示数据块内容已结束，永远都是最后一个数据块，内容固定</p>
</blockquote>
<p>如下，我们查看一张最简单的PNG文件结构：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-04-23-14927497364378.jpg" alt=""></p>
<p>可以看到这张PNG图像只包含了<code>Signature</code>、<code>IHDR</code>、一个<code>IDAT</code>以及结束数据块<code>IEND</code>，可以说是最简单的PNG图像。</p>
<p>前8个字节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>E <span class="number">47</span> <span class="number">0</span>D <span class="number">0</span>A <span class="number">1</span>A <span class="number">0</span>A</span><br></pre></td></tr></table></figure>
<p>描述的<code>Signature</code>为ASCII字符<code>.PNG</code>表示该文件为PNG文件。<br>后续的25个字节：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>D <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">57</span> <span class="number">02</span> F9 <span class="number">87</span></span><br></pre></td></tr></table></figure>
<p>描述的是<code>IHDR</code>头数据块，其中前4个字节<code>00 00 00 0D</code>表示该数据块Data域的长度为13字节，然后是4个字节<code>49 48 44 52</code>描述的该数据块类型，对应的ASCII字符为<code>IHDR</code>，接下来是数据块真正存储的数据Data域，最后是4个字节的CRC校验码。关于<code>IHDR</code>数据块的Data，主要有四个我们比较关心的数据：图像宽高、色深以及颜色类型。其中宽和高各占4个字节，位深和颜色类型占1个字节，对应字节为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">30</span> <span class="number">08</span> <span class="number">06</span></span><br></pre></td></tr></table></figure>
<p>从中可以得知该PNG图像宽和高都为<code>00 00 00 30</code>(48px)，色深为8bit，颜色类型为6（6代表带alpha通道的彩色图像）。</p>
<p>更多细节可以参考<a href="http://baike.baidu.com/link?url=ZHBwHuH3wybjXZyxOLKzMtBRuJ1c4XydcWoJKzd3uA8SsjIFm-uwFLRx8UHH7xgNxcWjTNw0opY2LPlA0dhlwq#3" target="_blank" rel="external">PNG百科</a>以及<a href="https://www.w3.org/TR/PNG/" target="_blank" rel="external">W3C Introduce</a></p>
<h4 id="NinePatch-9"><a href="#NinePatch-9" class="headerlink" title="NinePatch(.9)"></a><strong>NinePatch(.9)</strong></h4><p>NinePatch(.9)图片是Android上一个可动态伸缩的PNG图片，为什么它具有这种特性呢？原理是在PNG图像基础上添加一个额外的1像素的边框来描述动态伸缩与内容填充的区域，然后在编译打包时通过aapt工具对.9图进行额外处理，具体是提取所添加的1像素边框的信息，这些信息会通过额外类型<code>npTc</code>和<code>npOl</code>的<code>Chunk</code>数据块保存在PNG文件中，当在图片加载时，会在判断该图片是否为.9图来选择性的构造一个<code>NinePatchDrawable</code>还是<code>BitmapDrawable</code>对象，<code>NinePatchDrawable</code>即是一个可对内容区域进行动态伸缩的Drawable，判断是否为.9图以及构造一个<code>NinePatchDrawable</code>代码为：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] npChunk = bitmap.getNinePatchChunk();</span><br><span class="line"><span class="keyword">if</span> (npChunk != <span class="keyword">null</span> &amp;&amp; NinePatch.isNinePatchChunk(npChunk)) &#123;</span><br><span class="line">    NinePatchDrawable npDrawable = <span class="keyword">new</span> NinePatchDrawable(getResources(), bitmap, npChunk, <span class="keyword">new</span> Rect(), <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个.9图片可以由自带的<code>draw9patch</code>工具进行制作，制作后文件的后缀为<code>.9.png</code>。</p>
<h4 id="PNG压缩"><a href="#PNG压缩" class="headerlink" title="PNG压缩"></a><strong>PNG压缩</strong></h4><p>关于对PNG图片的压缩，Android默认使用的是libpng库进行PNG图片的压缩，场景有两个地方：aapt打包时和bitmap.compress()时。<br>所以对于Android中PNG的压缩或想获取更好的压缩率，我们有两种做法：</p>
<blockquote>
<p>1、屏蔽在aapt打包时默认的libpng的压缩，我们自己使用第三方压缩工具进行png图像的压缩<br>2、对于api层面，使用自己编译的lib库替换系统的api进行png的压缩</p>
</blockquote>
<p>对于一些第三方png压缩工具，有：<a href="https://pngquant.org/" target="_blank" rel="external">Pngquant</a>、<a href="http://advsys.net/ken/utils.htm" target="_blank" rel="external">Pngout</a>、<a href="https://tinypng.com/" target="_blank" rel="external">TinyPng</a>、<a href="http://optipng.sourceforge.net/" target="_blank" rel="external">Optipn</a>以及<a href="https://imageoptim.com/mac" target="_blank" rel="external">ImageOptim</a>等。</p>
<p>通常来说如果我们不满足于在aapt打包时进行的png图片压缩，我们可以通过上面的工具进行png的压缩，此时，必须屏蔽aapt打包时的压缩，为什么呢？避免压缩覆盖，因为每个压缩工具的压缩算法也不同，所以对于压缩只能并且最好只有一次，否则极可能导致经过第三方压缩后再经过libpng压缩，最后的png图片大小并没有发生明显的变化。</p>
<p>我们可以通过gradle的<code>aaptOptions</code>配置来屏蔽aapt打包时对png进行压缩，进而使用我们自己压缩的png图片，通过以下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">aaptOptions</span> &#123;</span><br><span class="line">        <span class="title">cruncherEnabled</span> <span class="built_in">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中这不会屏蔽对.9图片的处理，所以不影响.9图的使用。</p>
<h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a><strong>JPEG</strong></h3><p>JPEG是一种有损压缩的图像存储格式，不支持alpha通道，由于它具有高压缩比，在压缩过程中把重复的数据和无关紧要的数据会选择性的丢失，所以如果不需要用到alpha通道，那么大都图片格式都用该格式。</p>
<h4 id="JPEG数据结构"><a href="#JPEG数据结构" class="headerlink" title="JPEG数据结构"></a><strong>JPEG数据结构</strong></h4><p>一张JPEG图片的数据结构大致如下：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2017-04-23-14927671878612.jpg" alt=""></p>
<p>JPEG文件主要是由多个<code>segment</code>段组成，每个<code>segment</code>又由<code>标识码</code>和<code>压缩数据</code>组成，标识码由两个字节组成，第一个为固定值<code>0xFF</code>，而区分每个标识码的类型主要由第二个进行区分，下面介绍一下常用的标识码：</p>
<blockquote>
<p><strong>FFD8</strong>：表示图像的开始，段名为<code>SOI</code><br><strong>FFE0</strong>：表示JFIF数据块，段名为<code>APP0</code><br><strong>FFC0</strong>：表示图像帧开始，段名为<code>SOFO</code><br><strong>FFC4</strong>：表示Huffman表，段名为<code>DHT</code><br><strong>FFDA</strong>：表示从上往下开始扫描图像，段名为<code>SOS</code><br><strong>FFD9</strong>：表示图像结束，段名为<code>EOI</code></p>
</blockquote>
<p>更多JPEG格式细节可以看<a href="https://en.wikipedia.org/wiki/JPEG" target="_blank" rel="external">JPEG Wiki</a></p>
<h4 id="JPEG压缩"><a href="#JPEG压缩" class="headerlink" title="JPEG压缩"></a><strong>JPEG压缩</strong></h4><p>对于JPEG图片的压缩，文章开头说到了Android默认使用的是libjpeg库进行压缩的，不过在Android7.0+发生了一点点变化，主要是做了两点优化</p>
<blockquote>
<p>1、内部使用的JPEG压缩库改为<code>libjpeg-turbo</code>，这是一个基于<code>libjpeg</code>的涡轮增压库，主要的一特点就是速度比<code>libjpeg</code>快<br>2、使用<code>Huffman</code>编码替代<code>Arithmetic</code>编码</p>
</blockquote>
<p>上面第二点为主要优化点，有兴趣的同学可以用一台Android7.0+手机以及7.0以下版本的手机，压缩相同一张图片，会发现在相同质量下Android7.0+机子上的压缩后的图片大小比7.0以下的要小。</p>
<h3 id="VectorDrawable"><a href="#VectorDrawable" class="headerlink" title="VectorDrawable"></a><strong>VectorDrawable</strong></h3><p>矢量图是通过一系列的xml标签进行描述图像的行为信息，通过xml文件进行存储，使得它文件比一般PNG、JPEG更小，同时具备高度的伸缩性且不失真，但在Android上的矢量图(VectorDrawable)描述标签和广义上的SVG矢量图有些差别，在Android具体的对矢量图进行描述的标签主要是<code>vector</code>与<code>path</code>，其中<code>path</code>的格式和定义是一样的，矢量图的行为内容描述也主要在该标签中，在支持上：</p>
<blockquote>
<p> 1、在Android5.0+提供原生支持<br> 2、使用support-library-v23.2+版本提供全版本支持，具体可查看<a href="https://android-developers.googleblog.com/2016/02/android-support-library-232.html" target="_blank" rel="external">官方博客</a></p>
</blockquote>
<h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a><strong>WebP</strong></h3><p>Webp图片格式是Google推出的一个支持alpha通道的有损压缩格式，据Google官方表明，同质量情况下Webp图像要比JPEG、PNG图像小25%~45%左右，在支持上Android4.0+版本提供原生支持，使用<code>libwebp</code>库进行编解码。</p>
<h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a><strong>GIF</strong></h3><p>GIF图像最广泛的应用是用于显示动画图像，它具备文件小且支持alpha通道的优点，不过它是由8位进行表示每个像素的色彩，仅支持256色，所以在对色彩要求比较高的场合不太适合。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><strong>Stream</strong></h3><p>图片的存储形式从File转到内存中时，图片内容以字节方式存储在Stream中，此时所占的内存大小为File文件大小。</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a><strong>Bitmap</strong></h3><p>在Android中，任何图片资源的显示对象都是通过bitmap来显示的，除了xml资源则是通过Canvas来绘制的，所以，对于某些纯色或者规则类的图像，可以通过xml进行描述或Canvas来绘制，这样所占用的内存比通过bitmap来显示将少几个等级。</p>
<p>Bitmap所占用内存的计算：</p>
<blockquote>
<p>pixelWidth <em> pixelHeight </em> bytesPerPixel</p>
</blockquote>
<p>即Bitmap的宽x高x每像素所占字节数，所以相同一个Bitmap对象，对于每像素占2字节的<code>RGB_565</code>色彩空间所占内存是每像素4字节的<code>ARGB_8888</code>占用内存的一半。</p>
<h4 id="Bitmap与Drawable的联系"><a href="#Bitmap与Drawable的联系" class="headerlink" title="Bitmap与Drawable的联系"></a><strong>Bitmap与Drawable的联系</strong></h4><p>关于Bitmap和Drawable的关系，可以看官方的解释，Drawable是一个抽象的概念，来描述某些具备可绘制的的对象，它是一个抽象类，而Bitmap是一个最简单的Drawable实体对象，Bitmap并不继承于Drawable，它们之间建立关联最终是通过<code>BitmapDrawable</code>对象，该对象会把具体的Bitmap实例对象渲染到Canvas上。Drawable更注重描述的是某绘制的行为，而Bitmap则是注重存储着图像的像素信息。</p>
<h4 id="Bitmap存储空间"><a href="#Bitmap存储空间" class="headerlink" title="Bitmap存储空间"></a><strong>Bitmap存储空间</strong></h4><p>随着版本的变化以及存储空间的变化，Bitmap的存储空间主要有三个地方<br><strong>Native Memory</strong><br>Android2.3以下版本，bitmap像素数据存储在native内存中，释放内存需主动调用<code>recycle()</code>方法<br><strong>Dalvik Heap</strong><br>Android3.0+版本，在Android2.3版本引入了并发的垃圾回收器后，在3.0以后的版本bitmap的像素数据则存储在虚拟机堆中，不需要主动调用<code>recycle()</code>来回收内存，gc会主动回收<br><strong>Ashmem</strong><br>匿名共享内存空间，说到这个，就会联想起大名鼎鼎的<code>Fresco</code>图片库，它巧妙的利用了这一空间来进行Bitmap对象的存储，对于<code>Ashmem</code>空间，首先想到的是与App进程空间是隔离且互不影响的，这点在Android4.4以下版本是这样的，在Android4.4+后版本，<code>Ashmem</code>空间将会包含在App所占用的内存空间中。看Fresco源码也可以看出，对于4.4+版本，对于Bitmap的解码使用了另外的解码器。在Android4.4以下版本如何使用<code>Ashmem</code>进行bitmap的存储呢？通过DecodeOptions：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">options</span>.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">options</span>.inInputShareable = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>以及通过<code>MemoryFile</code>可将图片的字节数据存储在<code>Ashmem</code>中。</p>
<h2 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a><strong>压缩方式</strong></h2><p>对于图片的压缩方式，针对内存空间来说主要有两个类型：</p>
<blockquote>
<p>1、减少虚拟机堆中所占用的内存大小<br>2、减少在硬盘中所占用的物理内存大小</p>
</blockquote>
<p>下面主要说说这两种类型的压缩方式</p>
<h3 id="降低色彩位数"><a href="#降低色彩位数" class="headerlink" title="降低色彩位数"></a><strong>降低色彩位数</strong></h3><p>所谓的降低色彩位数，就是降低RGB各个分量的位数，如<code>ARGB_8888</code>到<code>RGB_565</code>，每个像素所占字节从4个减小到2个字节，对应的内存大小也节约了一半。</p>
<p>对于每个像素的R、G、B分量的转换过程，即一个分量占用8bit需要转换为5bit(6bit)，或者是一个分量占用5bit(6bit)需要转换为8bit，这两个过程叫：<strong>压缩</strong>、<strong>补偿</strong>。</p>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a><strong>压缩</strong></h4><p>压缩是各个分量位数的降低</p>
<p>以<code>RGB_888</code>到<code>RGB_565</code>为例：</p>
<p><strong>RGB_888</strong>每个分量占8位，每个像素的位深为24bit，如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">R7</span> <span class="literal">R6</span> <span class="literal">R5</span> <span class="literal">R4</span> <span class="literal">R3</span> <span class="literal">R2</span> <span class="literal">R1</span> <span class="literal">R0</span> <span class="title">| G7 G6 G5 G4 G3 G2 G1 G0 |</span> <span class="keyword">B7 </span><span class="keyword">B6 </span><span class="keyword">B5 </span><span class="keyword">B4 </span><span class="keyword">B3 </span><span class="keyword">B2 </span><span class="keyword">B1 </span><span class="keyword">B0</span></span><br></pre></td></tr></table></figure>
<p><strong>RGB_565</strong>每个分量分别占5位、6位、5位，每个像素位深为16bit，对于各分量的压缩，避免不了丢失一些精度，为使得精度丢失最小，我们只需取其高位即可，<code>RGB_888</code>到<code>RGB_565</code>的转换后最终每个分量值为：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">R7</span> <span class="literal">R7</span> <span class="literal">R5</span> <span class="literal">R4</span> <span class="literal">R3</span> <span class="title">| G7 G6 G5 G4 G3 G2 |</span> <span class="keyword">B7 </span><span class="keyword">B6 </span><span class="keyword">B5 </span><span class="keyword">B4 </span><span class="keyword">B3</span></span><br></pre></td></tr></table></figure>
<h4 id="补偿"><a href="#补偿" class="headerlink" title="补偿"></a><strong>补偿</strong></h4><p>补偿是各个分量位数的增加</p>
<p>以<code>RGB_565</code>到<code>RGB_888</code>为例：<br><strong>RGB_565</strong>每个分量分别占5位、6位、5位，每个像素位深为16bit，如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">R4</span> <span class="literal">R3</span> <span class="literal">R2</span> <span class="literal">R1</span> <span class="literal">R0</span> <span class="title">| G5 G4 G3 G2 G1 G0 |</span> <span class="keyword">B4 </span><span class="keyword">B3 </span><span class="keyword">B2 </span><span class="keyword">B1 </span><span class="keyword">B0</span></span><br></pre></td></tr></table></figure>
<p><strong>RGB_888</strong>每个分量占8位，每个像素的位深为24bit，对于各个分量的补偿，常用的做法是</p>
<blockquote>
<p>用原分量的值进行填充，剩下的用原分量的低位进行循环补偿</p>
</blockquote>
<p><code>RGB_565</code>到<code>RGB_888</code>的转换后最终每个分量的值为：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">R4</span> <span class="literal">R3</span> <span class="literal">R2</span> <span class="literal">R1</span> <span class="literal">R0</span> <span class="literal">R2</span> <span class="literal">R1</span> <span class="literal">R0</span> <span class="title">| G5 G4 G3 G2 G1 G0 G1 G0 |</span> <span class="keyword">B4 </span><span class="keyword">B3 </span><span class="keyword">B2 </span><span class="keyword">B1 </span><span class="keyword">B0 </span><span class="keyword">B2 </span><span class="keyword">B1 </span><span class="keyword">B0</span></span><br></pre></td></tr></table></figure>
<h3 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a><strong>尺寸压缩</strong></h3><p>尺寸压缩主要是缩减bitmap的大小，当加载一张大图片时，进行合适的尺寸的压缩是减小内存占用的很有效的方法</p>
<h4 id="SamplingSize"><a href="#SamplingSize" class="headerlink" title="SamplingSize"></a><strong>SamplingSize</strong></h4><p>采样率压缩，这基本是人人皆知的办法，在图片decode阶段，先获取其宽高然后进行判断是否符合我们预期的，否则进行一定比例的缩放，代码为：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bitmap decode(String filePath) &#123;</span><br><span class="line">    BitmapFactory.<span class="keyword">Options</span> <span class="keyword">options</span> = <span class="keyword">new</span> BitmapFactory.<span class="keyword">Options</span>();</span><br><span class="line">    <span class="keyword">options</span>.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeFile(filePath, <span class="keyword">options</span>);</span><br><span class="line">    <span class="keyword">int</span> outWidth = <span class="keyword">options</span>.outWidth;</span><br><span class="line">    <span class="keyword">int</span> outHeight = <span class="keyword">options</span>.outHeight;</span><br><span class="line">    <span class="keyword">options</span>.inSampleSize = computeSampleSize(outWidth, outHeight);</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeFile(filePath, <span class="keyword">options</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式采样率只能支持2的幂次方的值进行缩放，所以一般decode出来的bitmap大小往往不是我们预期的大小，有可能大很多也有可能小很多</p>
<h4 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a><strong>Matrix</strong></h4><p>Matrix矩阵变换，可以对bitmap进行非常多的操作，其中一项是对bitmap进行等比缩放，这种方式可以精确的缩放到符合我们预期的bitmap大小，代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bitmapWidth = bitmap.getWidth();</span><br><span class="line"><span class="type">int</span> bitmapHeight = bitmap.getHeight();</span><br><span class="line"><span class="type">Matrix</span> matrix = new <span class="type">Matrix</span>();</span><br><span class="line"><span class="type">float</span> rate = computeScaleRate(bitmapWidth, bitmapHeight);</span><br><span class="line">matrix.postScale(rate, rate);</span><br><span class="line"><span class="type">Bitmap</span> <span class="literal">result</span> = <span class="type">Bitmap</span>.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmapWidth, bitmapHeight, matrix, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="设备屏幕密度与drawable关系"><a href="#设备屏幕密度与drawable关系" class="headerlink" title="设备屏幕密度与drawable关系"></a><strong>设备屏幕密度与drawable关系</strong></h4><p>我们知道在不同屏幕密度的设备下，会选择最适合该设备的资源目录进行资源的加载，如对于屏幕dpi为480的则会最优选择<code>xxhdpi</code>目录，关于分辨率与dpi以及屏幕密度对应关系为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Dpi</th>
<th style="text-align:center">分辨率</th>
<th style="text-align:center">Res</th>
<th style="text-align:center">Density</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">160dpi</td>
<td style="text-align:center">320x533</td>
<td style="text-align:center">mdpi</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">240dpi</td>
<td style="text-align:center">480x800</td>
<td style="text-align:center">hdpi</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">320dpi</td>
<td style="text-align:center">720x1280</td>
<td style="text-align:center">xhdpi</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">480dpi</td>
<td style="text-align:center">1080x1920</td>
<td style="text-align:center">xxhdpi</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">560dpi</td>
<td style="text-align:center">1440x2560</td>
<td style="text-align:center">xxxhdpi</td>
<td style="text-align:center">3.5</td>
</tr>
</tbody>
</table>
<p>如果没有对应的目录，则会使用默认目录。假如有一设备dpi为480，并且没有xxdpi目录下没有该图片资源，那么在进行图片资源decode时候，会把图片适配到对应的屏幕分辨率，进行放大或缩小，缩放比例是：</p>
<blockquote>
<p>宽、高 * (当前设备dpi/目标资源目录对应的dpi)</p>
</blockquote>
<p>对于获取设备的dpi以及density可由Resources静态方法方便获取：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics displayMetrics = Resources.getSystem().getDisplayMetrics();</span><br><span class="line"><span class="built_in">int</span> densityDpi = displayMetrics.densityDpi;</span><br><span class="line"><span class="built_in">int</span> density = displayMetrics.density;</span><br><span class="line"><span class="built_in">int</span> <span class="variable">width</span> = displayMetrics.widthPixels;</span><br><span class="line"><span class="built_in">int</span> <span class="variable">height</span> = displayMetrics.heightPixels;</span><br></pre></td></tr></table></figure>
<p><strong>一些建议</strong><br>对于某些高清无码比较大的图片，如一些背景或者引导图等，可由第三方压缩工具进行压缩后放入assets目录中，避免可能在drawable目录下加载引起的放大导致消耗内存过大或缩小导致图片过小等问题。</p>
<h3 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a><strong>质量压缩</strong></h3><p>对于质量压缩，也就是图片的所占物理内存的大小，主要是通过一些lib库进行压缩，如Android默认的<code>bitmap.compress()</code>，可选择PNG与JPEG等进行压缩，如果不满足于内置的lib压缩库效果，可自己选择替换系统api进行压缩，在上述JPEG这节中说的Android底层所用libjpeg库在7.0+版本变化，主要是进行了JPEG图片压缩的优化，所以为了弥补在Android7.0以下对JPEG压缩的质量问题以及对bitmap压缩进行合理适配，特此写了一个开源库<a href="https://github.com/Sunzxyong/Tiny" target="_blank" rel="external"><strong><code>Tiny</code></strong></a>，对于JPEG的压缩选择和Android7.0后一样的库<code>libjpeg-turbo</code>库进行压缩，同时也开启了<code>Huffman</code>编码。</p>
<h2 id="Tiny"><a href="#Tiny" class="headerlink" title="Tiny"></a><strong>Tiny</strong></h2><p>下面是使用<a href="https://github.com/Sunzxyong/Tiny" target="_blank" rel="external">Tiny</a>图片压缩库进行压缩与微信朋友圈的效果对比示例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">图片信息</th>
<th style="text-align:center">Tiny</th>
<th style="text-align:center">Wechat</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6.66MB (3500x2156)</td>
<td style="text-align:center">151KB (1280x788)</td>
<td style="text-align:center">135KB (1280x789)</td>
</tr>
<tr>
<td style="text-align:center">4.28MB (4160x3120)</td>
<td style="text-align:center">219KB (1280x960)</td>
<td style="text-align:center">195KB (1280x960)</td>
</tr>
<tr>
<td style="text-align:center">2.60MB (4032x3024)</td>
<td style="text-align:center">193KB (1280x960))</td>
<td style="text-align:center">173KB (1280x960)</td>
</tr>
<tr>
<td style="text-align:center">372KB (500x500)</td>
<td style="text-align:center">38.67KB (500x500)</td>
<td style="text-align:center">34.05KB (500x500)</td>
</tr>
<tr>
<td style="text-align:center">236KB (960x1280)</td>
<td style="text-align:center">127KB (960x1280)</td>
<td style="text-align:center">118KB (960x1280)</td>
</tr>
</tbody>
</table>
<h3 id="Tiny项目地址为：戳我"><a href="#Tiny项目地址为：戳我" class="headerlink" title="Tiny项目地址为：戳我"></a>Tiny项目地址为：<a href="https://github.com/Sunzxyong/Tiny" target="_blank" rel="external">戳我</a></h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><strong>Reference</strong></h2><blockquote>
<p><a href="https://www.youtube.com/watch?v=r_LpCi6DQME&amp;index=2&amp;list=PLWz5rJ2EKKc8jQTUYvIfqA9lMvSGQWtte" target="_blank" rel="external">Image compression for Android developers - Google I/O 2016</a><br><a href="https://android-developers.googleblog.com/2016/02/android-support-library-232.html" target="_blank" rel="external">Android Support Library 23.2</a><br><a href="https://developers.google.com/speed/webp/docs/compression" target="_blank" rel="external">WebP Compression Techniques in Detail</a><br><a href="https://developer.android.com/topic/performance/graphics/manage-memory.html" target="_blank" rel="external">Managing Bitmap Memory</a></p>
</blockquote>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2017/04/23/%E4%B9%9F%E8%B0%88%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android图片压缩框架-Tiny</title>
      <link>http://zhengxiaoyong.com/2017/04/23/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%A1%86%E6%9E%B6-Tiny/</link>
      <guid>http://zhengxiaoyong.com/2017/04/23/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%A1%86%E6%9E%B6-Tiny/</guid>
      <pubDate>Sun, 23 Apr 2017 08:23:56 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;为了简化对图片压缩的调用，提供最简洁与合理的api压缩逻辑，对于压缩为Bitmap根据屏幕分辨率动态适配最佳大小，对于压缩为File优化底层&lt;code&gt;libjpeg&lt;/code&gt;的压缩，整个图片压缩过程全在压缩线程池中异步压缩，结束后分发回UI线程。&lt;/p&gt;
&lt;h2 id=&quot;支持的压缩类型&quot;&gt;&lt;a href=&quot;#支持的压缩类型&quot; class=&quot;headerlink&quot; title=&quot;支持的压缩类型&quot;&gt;&lt;/a&gt;&lt;strong&gt;支持的压缩类型&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Tiny&lt;/code&gt;图片压缩框架支持的压缩数据源类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、Bytes&lt;br&gt;2、File&lt;br&gt;3、Bitmap&lt;br&gt;4、Stream&lt;br&gt;5、Resource&lt;br&gt;6、Uri（network、file、content）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Tiny&lt;/code&gt;支持单个数据源压缩以及批量压缩，支持的压缩类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、数据源—&amp;gt;压缩为Bitmap&lt;br&gt;2、数据源—&amp;gt;压缩为File&lt;br&gt;3、数据源—&amp;gt;压缩为File并返回压缩后的Bitmap&lt;br&gt;4、批量数据源—&amp;gt;批量压缩为Bitmap&lt;br&gt;5、批量数据源—&amp;gt;批量压缩为File&lt;br&gt;6、批量数据源—&amp;gt;批量压缩为File并返回压缩后Bitmap&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h2><p>为了简化对图片压缩的调用，提供最简洁与合理的api压缩逻辑，对于压缩为Bitmap根据屏幕分辨率动态适配最佳大小，对于压缩为File优化底层<code>libjpeg</code>的压缩，整个图片压缩过程全在压缩线程池中异步压缩，结束后分发回UI线程。</p>
<h2 id="支持的压缩类型"><a href="#支持的压缩类型" class="headerlink" title="支持的压缩类型"></a><strong>支持的压缩类型</strong></h2><p><code>Tiny</code>图片压缩框架支持的压缩数据源类型：</p>
<blockquote>
<p>1、Bytes<br>2、File<br>3、Bitmap<br>4、Stream<br>5、Resource<br>6、Uri（network、file、content）</p>
</blockquote>
<p><code>Tiny</code>支持单个数据源压缩以及批量压缩，支持的压缩类型：</p>
<blockquote>
<p>1、数据源—&gt;压缩为Bitmap<br>2、数据源—&gt;压缩为File<br>3、数据源—&gt;压缩为File并返回压缩后的Bitmap<br>4、批量数据源—&gt;批量压缩为Bitmap<br>5、批量数据源—&gt;批量压缩为File<br>6、批量数据源—&gt;批量压缩为File并返回压缩后Bitmap</p>
</blockquote>
<a id="more"></a>
<h3 id="压缩参数"><a href="#压缩参数" class="headerlink" title="压缩参数"></a><strong>压缩参数</strong></h3><h4 id="Tiny-BitmapCompressOptions"><a href="#Tiny-BitmapCompressOptions" class="headerlink" title="Tiny.BitmapCompressOptions"></a><strong>Tiny.BitmapCompressOptions</strong></h4><p><strong>Bitmap</strong>压缩参数可配置三个：</p>
<blockquote>
<p>1、width<br>2、height<br>3、Bitmap.Config</p>
</blockquote>
<p>如果不配置，<code>Tiny</code>内部会根据屏幕动态适配以及默认使用<code>ARGB_8888</code></p>
<h4 id="Tiny-FileCompressOptions"><a href="#Tiny-FileCompressOptions" class="headerlink" title="Tiny.FileCompressOptions"></a><strong>Tiny.FileCompressOptions</strong></h4><p><strong>File</strong>压缩参数可配置四个：</p>
<blockquote>
<p>1、quality-压缩质量，默认为76<br>2、isKeepSampling-是否保持原数据源图片的宽高<br>3、fileSize-压缩后文件大小<br>4、outfile-压缩后文件存储路径</p>
</blockquote>
<p>如果不配置，<code>Tiny</code>内部会根据默认压缩质量进行压缩，压缩后文件默认存储在：ExternalStorage/Android/data/${packageName}/tiny/目录下</p>
<h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a><strong>接入</strong></h3><p>见项目<a href="https://github.com/Sunzxyong/Tiny/blob/master/README.md" target="_blank" rel="external">README</a></p>
<h3 id="压缩为Bitmap"><a href="#压缩为Bitmap" class="headerlink" title="压缩为Bitmap"></a><strong>压缩为Bitmap</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.BitmapCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.BitmapCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).asBitmap().withOptions(<span class="keyword">options</span>).compress(<span class="keyword">new</span> BitmapCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, Bitmap bitmap) &#123;</span><br><span class="line">        <span class="comment">//return the compressed bitmap object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="压缩为File"><a href="#压缩为File" class="headerlink" title="压缩为File"></a><strong>压缩为File</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.FileCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.FileCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).asFile().withOptions(<span class="keyword">options</span>).compress(<span class="keyword">new</span> FileCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, String outfile) &#123;</span><br><span class="line">        <span class="comment">//return the compressed file path</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="压缩为File并返回Bitmap"><a href="#压缩为File并返回Bitmap" class="headerlink" title="压缩为File并返回Bitmap"></a><strong>压缩为File并返回Bitmap</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.FileCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.FileCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).asFile().withOptions(<span class="keyword">options</span>).compress(<span class="keyword">new</span> FileWithBitmapCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, Bitmap bitmap, String outfile) &#123;</span><br><span class="line">        <span class="comment">//return the compressed file path and bitmap object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="批量压缩为Bitmap"><a href="#批量压缩为Bitmap" class="headerlink" title="批量压缩为Bitmap"></a><strong>批量压缩为Bitmap</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.BitmapCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.BitmapCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).batchAsBitmap().withOptions(<span class="keyword">options</span>).batchCompress(<span class="keyword">new</span> BitmapBatchCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, Bitmap[] bitmaps) &#123;</span><br><span class="line">        <span class="comment">//return the batch compressed bitmap object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="批量压缩为File"><a href="#批量压缩为File" class="headerlink" title="批量压缩为File"></a><strong>批量压缩为File</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.FileCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.FileCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).batchAsFile().withOptions(<span class="keyword">options</span>).batchCompress(<span class="keyword">new</span> FileBatchCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, String[] outfile) &#123;</span><br><span class="line">        <span class="comment">//return the batch compressed file path</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="批量压缩为File并返回Bitmap"><a href="#批量压缩为File并返回Bitmap" class="headerlink" title="批量压缩为File并返回Bitmap"></a><strong>批量压缩为File并返回Bitmap</strong></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tiny.FileCompressOptions <span class="keyword">options</span> = <span class="keyword">new</span> Tiny.FileCompressOptions();</span><br><span class="line">Tiny.getInstance().<span class="keyword">source</span>(<span class="string">""</span>).batchAsFile().withOptions(<span class="keyword">options</span>).batchCompress(<span class="keyword">new</span> FileWithBitmapBatchCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> callback(<span class="keyword">boolean</span> isSuccess, Bitmap[] bitmaps, String[] outfile) &#123;</span><br><span class="line">        <span class="comment">//return the batch compressed file path and bitmap object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Tiny与微信朋友圈的压缩率比较"><a href="#Tiny与微信朋友圈的压缩率比较" class="headerlink" title="Tiny与微信朋友圈的压缩率比较"></a><strong>Tiny与微信朋友圈的压缩率比较</strong></h2><p>下面是使用<a href="https://github.com/Sunzxyong/Tiny" target="_blank" rel="external">Tiny</a>图片压缩库进行压缩的效果对比示例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">图片信息</th>
<th style="text-align:center">Tiny</th>
<th style="text-align:center">Wechat</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6.66MB (3500x2156)</td>
<td style="text-align:center">151KB (1280x788)</td>
<td style="text-align:center">135KB (1280x789)</td>
</tr>
<tr>
<td style="text-align:center">4.28MB (4160x3120)</td>
<td style="text-align:center">219KB (1280x960)</td>
<td style="text-align:center">195KB (1280x960)</td>
</tr>
<tr>
<td style="text-align:center">2.60MB (4032x3024)</td>
<td style="text-align:center">193KB (1280x960))</td>
<td style="text-align:center">173KB (1280x960)</td>
</tr>
<tr>
<td style="text-align:center">372KB (500x500)</td>
<td style="text-align:center">38.67KB (500x500)</td>
<td style="text-align:center">34.05KB (500x500)</td>
</tr>
<tr>
<td style="text-align:center">236KB (960x1280)</td>
<td style="text-align:center">127KB (960x1280)</td>
<td style="text-align:center">118KB (960x1280)</td>
</tr>
</tbody>
</table>
<h2 id="Tiny项目地址"><a href="#Tiny项目地址" class="headerlink" title="Tiny项目地址"></a>Tiny项目地址</h2><h3 id="Tiny"><a href="#Tiny" class="headerlink" title="Tiny"></a><a href="https://github.com/Sunzxyong/Tiny" target="_blank" rel="external">Tiny</a></h3><h3 id="也谈图片压缩"><a href="#也谈图片压缩" class="headerlink" title="也谈图片压缩"></a><a href="http://zhengxiaoyong.me/2017/04/23/%E4%B9%9F%E8%B0%88%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" target="_blank" rel="external">也谈图片压缩</a></h3>]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2017/04/23/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E6%A1%86%E6%9E%B6-Tiny/#disqus_thread</comments>
    </item>
    
    <item>
      <title>简述RTMPDump与编译移植</title>
      <link>http://zhengxiaoyong.com/2016/11/20/%E7%AE%80%E8%BF%B0RTMPDump%E4%B8%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/</link>
      <guid>http://zhengxiaoyong.com/2016/11/20/%E7%AE%80%E8%BF%B0RTMPDump%E4%B8%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/</guid>
      <pubDate>Sun, 20 Nov 2016 11:47:59 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;RTMPDump概述&quot;&gt;&lt;a href=&quot;#RTMPDump概述&quot; class=&quot;headerlink&quot; title=&quot;RTMPDump概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;RTMPDump概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://rtmpdump.mplayerhq.hu/&quot;&gt;RTMPDump主页&lt;/a&gt;，RTMPDump库主要包含三部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、一个基本的客户端程序&lt;br&gt;2、两个服务器程序（rtmpsrv、rtmpsuck）&lt;br&gt;3、一个支持rtmp协议的库—librtmp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载RTMPDump最新源码，可以通过git拉取master分支上的最新代码：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;git&lt;/span&gt;://git.ffmpeg.org/rtmpdump&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者下载以前版本的代码—&lt;a href=&quot;http://rtmpdump.mplayerhq.hu/download/&quot;&gt;Download old version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面主要介绍librtmp和librtmp的编译&lt;/p&gt;
&lt;h3 id=&quot;librtmp概述&quot;&gt;&lt;a href=&quot;#librtmp概述&quot; class=&quot;headerlink&quot; title=&quot;librtmp概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;librtmp概述&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;librtmp库提供了大量客户端函数和少部分的服务器端的函数用来支持RTMP、RTMPT（RTMP使用Http通道），RTMPE（加密的RTMP），RTMPS（基于SSL/TLS的RTMP）和RTMPTE、RTMPTS（使用Http通道的加密和基于SSL/TLS的RTMP）协议&lt;/p&gt;
&lt;p&gt;使用librtmp库进行的流媒体交互都是使用&lt;strong&gt;FLV&lt;/strong&gt;封包格式进行传输的，当然编码不限定，不过为了拉流端同时也支持&lt;strong&gt;HLS&lt;/strong&gt;协议，最好使用&lt;strong&gt;H264&lt;/strong&gt;编码视频和&lt;strong&gt;AAC&lt;/strong&gt;编码音频数据&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="RTMPDump概述"><a href="#RTMPDump概述" class="headerlink" title="RTMPDump概述"></a><strong>RTMPDump概述</strong></h2><p><a href="http://rtmpdump.mplayerhq.hu/" target="_blank" rel="external">RTMPDump主页</a>，RTMPDump库主要包含三部分：</p>
<blockquote>
<p>1、一个基本的客户端程序<br>2、两个服务器程序（rtmpsrv、rtmpsuck）<br>3、一个支持rtmp协议的库—librtmp</p>
</blockquote>
<p>下载RTMPDump最新源码，可以通过git拉取master分支上的最新代码：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://git.ffmpeg.org/rtmpdump</span><br></pre></td></tr></table></figure>
<p>或者下载以前版本的代码—<a href="http://rtmpdump.mplayerhq.hu/download/" target="_blank" rel="external">Download old version</a></p>
<p>下面主要介绍librtmp和librtmp的编译</p>
<h3 id="librtmp概述"><a href="#librtmp概述" class="headerlink" title="librtmp概述"></a><strong>librtmp概述</strong></h3><p>librtmp库提供了大量客户端函数和少部分的服务器端的函数用来支持RTMP、RTMPT（RTMP使用Http通道），RTMPE（加密的RTMP），RTMPS（基于SSL/TLS的RTMP）和RTMPTE、RTMPTS（使用Http通道的加密和基于SSL/TLS的RTMP）协议</p>
<p>使用librtmp库进行的流媒体交互都是使用<strong>FLV</strong>封包格式进行传输的，当然编码不限定，不过为了拉流端同时也支持<strong>HLS</strong>协议，最好使用<strong>H264</strong>编码视频和<strong>AAC</strong>编码音频数据</p>
<a id="more"></a>
<p>使用librtmp通过<strong><code>RTMP[T][E|S]</code></strong>协议进行一次流媒体交互的基本过程为：</p>
<blockquote>
<p><strong>推流端</strong>：</p>
<ol>
<li><strong>RTMP_Alloc()</strong>-创建一个RTMP会话句柄</li>
<li><strong>RTMP_Init()</strong>-初始化RTMP句柄</li>
<li><strong>RTMP_SetupURL()</strong>-设置推流RTMP Url</li>
<li><strong>RTMP_EnableWrite()</strong>-配置该媒体流可进行写操作</li>
<li><strong>RTMP_Connect()</strong>-建立RTMP网络连接</li>
<li><strong>RTMP_ConnectStream()</strong>-建立RTMP流连接</li>
<li><strong>RTMP_Write()</strong>-对该媒体流进行写入流媒体信息</li>
<li><strong>RTMP_Close()</strong>-关闭RTMP连接</li>
<li><strong>RTMP_Free()</strong>-释放此次连接的会话句柄</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p><strong>播放端</strong>：</p>
<ol>
<li><strong>RTMP_Alloc()</strong>-创建一个RTMP会话句柄</li>
<li><strong>RTMP_Init()</strong>-初始化RTMP句柄</li>
<li><strong>RTMP_SetupURL()</strong>-设置拉流RTMP Url</li>
<li><strong>RTMP_Connect()</strong>-建立RTMP网络连接</li>
<li><strong>RTMP_ConnectStream()</strong>-建立RTMP流连接</li>
<li><strong>RTMP_Read()</strong>-读取媒体流数据，返回0时则媒体流读取完毕</li>
<li><strong>RTMP_Pause()</strong>-暂停读取媒体流数据或取消暂停（options）</li>
<li><strong>RTMP_Seek()</strong>-可通过它改变流播放的位置（options）</li>
<li><strong>RTMP_Close()</strong>-当媒体流读取完毕后进行RTMP连接的关闭</li>
<li><strong>RTMP_Free()</strong>-释放此次连接的会话句柄</li>
</ol>
</blockquote>
<p>上述方法的具体实现可以在librtmp包中的<code>rtmp.c</code>文件中找到，同时，它还提供了其它众多方法来处理RTMP的流媒体交互过程</p>
<h3 id="librtmp的RTMP-URL格式"><a href="#librtmp的RTMP-URL格式" class="headerlink" title="librtmp的RTMP URL格式"></a><strong>librtmp的RTMP URL格式</strong></h3><p>一个基本的RTMP URL格式为：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp[<span class="link_label">t</span>][<span class="link_reference">e|s</span>]://host[<span class="link_label">:port</span>][<span class="link_reference">/app[/playpath</span>]]</span><br></pre></td></tr></table></figure>
<p>和http类似，不过某些地方不一样，下面简单说说：<br>scheme为rtmp或者rtmp协议的诸多变种之一，这就不需要多解释了，像websocket协议scheme为ws或者wss，http协议scheme为http或https。<br>host为主机名，后面紧接着为端口号，如果不指定，rtmp协议默认端口号为1935.<br>app代表服务器上的一个Application应用程序，这个名称是由服务器定义的，如：live。<br>playpath则是表示该Application下的一个媒体流的路径，如：room100。</p>
<p>当然也可以追加额外的参数，只不过这和我们使用http协议追加参数的方式不同，librtmp是采取空格为分隔符，通过追加”key=value”的方式进行追加额外的参数，如：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rtmp://localhost:1935/live/room100 app=happylive"</span></span><br></pre></td></tr></table></figure>
<p>这就追加了额外的key为app，value为happylive的参数，表示使用happylive应用来连接而代替rtmp url中的live应用</p>
<p>关于librtmp的更多额外的参数配置，可以看<a href="http://rtmpdump.mplayerhq.hu/librtmp.3.html" target="_blank" rel="external">librtmp文档</a></p>
<h3 id="librtmp编译"><a href="#librtmp编译" class="headerlink" title="librtmp编译"></a><strong>librtmp编译</strong></h3><p>由于librtmp默认依赖zlib和openssl这两个库，所以编译时需要链接这两个库，由于NDK自带了zlib库，所以不需要单独去下载和编译，在编译librtmp时配置<code>Android.mk</code>文件的<code>LOCAL_LDLIBS</code>属性为<code>-lz</code>链接即可，编译时会在指定的platforms的arch-xxx/usr/lib/目录下搜索</p>
<p>编译librtmp，在librtmp目录下新建Android.mk文件，内容如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译模块输出的名称</span></span><br><span class="line">LOCAL_MODULE := rtmp</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译所需的头文件路径</span></span><br><span class="line">LOCAL_C_INCLUDES += \</span><br><span class="line">$(LOCAL_PATH)/</span><br><span class="line"><span class="preprocessor">#$(LOCAL_PATH)/../openssl/include/ #链接openssl库</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译所需的源文件路径</span></span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">amf.c       \</span><br><span class="line">log.c       \</span><br><span class="line">parseurl.c  \</span><br><span class="line">rtmp.c      \</span><br><span class="line">hashswf.c</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 编译时候需要链接的动态库库存在静态库形式，将会链接到对应的静态库而不是动态库</span></span><br><span class="line"><span class="preprocessor"># LOCAL_FORCE_STATIC_EXECUTABLE := true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 添加编译配置选项，一些常用编译配置：</span></span><br><span class="line"><span class="preprocessor"># -fPIC:编译位置无关的代码，一般用于编译动态库</span></span><br><span class="line"><span class="preprocessor"># -02:编译优化程度</span></span><br><span class="line"><span class="preprocessor"># -lxxx:链接名为libxxx库</span></span><br><span class="line"><span class="preprocessor"># -I添加编译器搜索-l指定的库文件的搜索</span></span><br><span class="line"><span class="preprocessor"># -D:加入宏定义，如：NO_CRYPTO，不使用加密</span></span><br><span class="line">LOCAL_CFLAGS += -DRTMPDUMP_VERSION=v2<span class="number">.4</span> -DNO_CRYPTO -Wall -fPIC -O2 </span><br><span class="line"><span class="preprocessor">#LOCAL_CFLAGS += -I$(LOCAL_PATH)/../openssl -lssl -lcrypto #可选添加openssl支持，需去除-DNO_CRYPTO</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 添加编译时需要链接器链接的那些存在于NDK目录下的其它库，所链接库的以“-lxxx”格式命名，如：-lz 表示编译时会加载libz.so库</span></span><br><span class="line">LOCAL_LDLIBS += -lz</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># include $(BUILD_STATIC_LIBRARY)</span></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>关于mk文件的编写和参数配置，可以阅读<a href="https://developer.android.com/ndk/guides/android_mk.html" target="_blank" rel="external">mk官网文档</a>，上面也给出了全部编译时参数配置的注释，由于上面配置加入了<code>NO_CRYPTO</code>定义，没有链接openssl库，需要的可以自己加或者使用<a href="https://tls.mbed.org/" target="_blank" rel="external">PolarSSL</a>、<a href="http://www.gnu.org/software/gnutls/" target="_blank" rel="external">GnuTLS</a>来替代<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a></p>
<p>然后在rtmpdump目录下也建立个Android.mk文件，内容为：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">LOCAL_PATH</span> := <span class="variable">$(</span>call my-dir)</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(</span><span class="constant">CLEAR_VARS</span>)</span><br><span class="line">subdirs := <span class="variable">$(</span>addprefix <span class="variable">$(</span><span class="constant">LOCAL_PATH</span>)/,<span class="variable">$(</span>addsuffix /<span class="constant">Android</span>.mk, \</span><br><span class="line">librtmp \</span><br><span class="line">))</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(</span>subdirs)</span><br></pre></td></tr></table></figure>
<p>其实不需要这个也行，不过加入该文件目的是为了能够统一rtmpdump文件夹下和子目录中的mk的编译运行入口，这样只需调用这一个mk文件即可，上面配置的只会运行librtmp目录下的mk文件，如果需要加入其它的，则在<code>subdirs</code>中加入即可，如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subdirs </span>:= $(<span class="keyword">addprefix </span>$(LOCAL_PATH)/,$(<span class="keyword">addsuffix </span>/<span class="keyword">Android.mk, </span>\</span><br><span class="line"><span class="label">librtmp</span> \</span><br><span class="line"><span class="label">otherdir</span> \</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>最后在rtmpdump中新建jni目录，新建Application.mk文件，内容为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NDK_TOOLCHAIN_VERSION</span> := 4.9</span><br><span class="line"><span class="constant">APP_PLATFORM</span> := android-14</span><br><span class="line"><span class="constant">APP_ABI</span> := all</span><br><span class="line"><span class="constant">APP_OPTIM</span> := release</span><br><span class="line"><span class="constant">APP_PROJECT_PATH</span> := <span class="variable">$(shell pwd)</span></span><br><span class="line"><span class="constant">APP_BUILD_SCRIPT</span> := <span class="variable">$(APP_PROJECT_PATH)</span>/Android.mk</span><br></pre></td></tr></table></figure>
<p>主要是对编译时的编译配置进行配置，<code>APP_ABI := all</code>表示支持当前平台支持的的全部CPU架构</p>
<p>然后新建一个开始执行编译的脚本文件，内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">NDK=<span class="variable">$HOME</span>/Library/Android/sdk/ndk-bundle</span><br><span class="line"><span class="variable">$NDK</span>/ndk-build NDK_APPLICATION_MK=./jni/Application.mk NDK_PROJECT_PATH=./</span><br></pre></td></tr></table></figure>
<p>其中NDK路径替换为自己的即可，开始编译：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> rtmpdump</span><br><span class="line">./build_librtmp.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>成功后，可以在rtmpdump目录下看到obj和libs两个文件夹，libs存放着编译出来的动态库，而obj则是存放静态库，这取决于所配置的是<code>BUILD_SHARED_LIBRARY</code>还是<code>BUILD_STATIC_LIBRARY</code></p>
<p>当然其它库也可以用这种方式进行编译</p>
<h2 id="在FFmpeg中使用librtmp"><a href="#在FFmpeg中使用librtmp" class="headerlink" title="在FFmpeg中使用librtmp"></a><strong>在FFmpeg中使用librtmp</strong></h2><p>由于FFmpeg本身默认自带就支持rtmp、rtmpt协议，不过也可以扩展以便支持rtmp协议的多种变种协议（rtmps、rtmpt、rtmpts、rtmpte和rtmpe协议），在FFmpeg加入openssl库的支持，可以支持rtmps、rtmpts协议，加入libgcrypt库的支持，可以支持rtmpe、rtmpte协议，这样支持相对麻烦，可以直接使用librtmp来支持rtmp以及它的多种变种协议，可通过链接librtmp库来支持，在FFmpeg的编译脚本中加入以下配置：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--enable-librtmp</span><br><span class="line">--extra-cflags=-I/<span class="variable">$LIBRTMP</span>_INCLUDE_PATH</span><br><span class="line">--extra-ldflags=-L/<span class="variable">$LIBRTMP</span>_LIB_PATH</span><br></pre></td></tr></table></figure>
<p>上面的<code>$LIBRTMP_INCLUDE_PATH</code>和<code>$LIBRTMP_LIB_PATH</code>分别是librtmp头文件和静态库的路径<br>关于FFmpeg如何链接第三方库请看我的这篇文章<a href="http://zhengxiaoyong.me/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">初识FFmpeg编译那些事</a></p>
<p>如果在编译时发生错误或警告<code>xxx-pkg-config not found</code>，请找到FFmpeg的configure文件中的如下内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enabled librtmp           &amp;&amp; require_pkg_config librtmp librtmp/rtmp<span class="class">.h</span> RTMP_Socket</span><br></pre></td></tr></table></figure>
<p>将后面的<code>&amp;&amp; require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket</code>删了，因为FFmpeg在链接librtmp时会运行pkg-config，此时找不到pkg-config则会报错，当然还有链接其它库时如果发生类似错误也可以用同样的方法解决</p>
<h2 id="Librtmp编译源码"><a href="#Librtmp编译源码" class="headerlink" title="Librtmp编译源码"></a><strong>Librtmp编译源码</strong></h2><p><a href="https://github.com/Sunzxyong/Librtmp-Compile-For-Android" target="_blank" rel="external">librtmp编译源码</a></p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/11/20/%E7%AE%80%E8%BF%B0RTMPDump%E4%B8%8E%E7%BC%96%E8%AF%91%E7%A7%BB%E6%A4%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>初识FFmpeg编译那些事</title>
      <link>http://zhengxiaoyong.com/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <guid>http://zhengxiaoyong.com/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <pubDate>Sun, 13 Nov 2016 12:45:10 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;FFmpeg简介&quot;&gt;&lt;a href=&quot;#FFmpeg简介&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;FFmpeg简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;FFMPEG是一套具有非常强大功能的多媒体处理工具，它几乎涵盖了目前所有主流的多媒体数据封装格式、多媒体传输协议以及音视频编解码器，并且支持多媒体后处理，视频色彩转换、滤镜和缩放等，也支持众多主流的协议：HTTP、RTP、RTSP、RTMP、HLS、UDP等&lt;br&gt;安装可以通过Homebrew&lt;/p&gt;
&lt;p&gt;FFmpeg它主要含有以下几个核心库：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、libavcodec-提供了更加全面的编解码实现的合集&lt;br&gt;2、libavformat-提供了更加全面的音视频容器格式的封装和解析以及所支持的协议&lt;br&gt;3、libavutil-提供了一些公共函数&lt;br&gt;4、libavfilter-提供音视频的过滤器，如视频加水印、音频变声等&lt;br&gt;5、libavdevice-提供支持众多设备数据的输入与输出，如读取摄像头数据、屏幕录制&lt;br&gt;6、libswresample,libavresample-提供音频的重采样工具&lt;br&gt;7、libswscale-提供对视频图像进行色彩转换、缩放以及像素格式转换，如图像的YUV转换&lt;br&gt;8、libpostproc-多媒体后处理器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及包含以下几个工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、ffmpeg-一个流媒体的编解码、格式转换以及多媒体流的内容处理工具&lt;br&gt;2、ffplay-一个使用FFmpeg编解码的播放器&lt;br&gt;3、ffprobe-一个多媒体分析工具&lt;br&gt;4、ffserver-一个流多媒体服务器&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="FFmpeg简介"><a href="#FFmpeg简介" class="headerlink" title="FFmpeg简介"></a><strong>FFmpeg简介</strong></h2><p>FFMPEG是一套具有非常强大功能的多媒体处理工具，它几乎涵盖了目前所有主流的多媒体数据封装格式、多媒体传输协议以及音视频编解码器，并且支持多媒体后处理，视频色彩转换、滤镜和缩放等，也支持众多主流的协议：HTTP、RTP、RTSP、RTMP、HLS、UDP等<br>安装可以通过Homebrew</p>
<p>FFmpeg它主要含有以下几个核心库：</p>
<blockquote>
<p>1、libavcodec-提供了更加全面的编解码实现的合集<br>2、libavformat-提供了更加全面的音视频容器格式的封装和解析以及所支持的协议<br>3、libavutil-提供了一些公共函数<br>4、libavfilter-提供音视频的过滤器，如视频加水印、音频变声等<br>5、libavdevice-提供支持众多设备数据的输入与输出，如读取摄像头数据、屏幕录制<br>6、libswresample,libavresample-提供音频的重采样工具<br>7、libswscale-提供对视频图像进行色彩转换、缩放以及像素格式转换，如图像的YUV转换<br>8、libpostproc-多媒体后处理器</p>
</blockquote>
<p>以及包含以下几个工具：</p>
<blockquote>
<p>1、ffmpeg-一个流媒体的编解码、格式转换以及多媒体流的内容处理工具<br>2、ffplay-一个使用FFmpeg编解码的播放器<br>3、ffprobe-一个多媒体分析工具<br>4、ffserver-一个流多媒体服务器</p>
</blockquote>
<a id="more"></a>
<h2 id="FFmpeg命令"><a href="#FFmpeg命令" class="headerlink" title="FFmpeg命令"></a><strong>FFmpeg命令</strong></h2><p>一些命令：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取帮助</span></span><br><span class="line">ffmpeg -help</span><br><span class="line"><span class="comment">//支持的格式</span></span><br><span class="line">ffmpeg -formats</span><br><span class="line"><span class="comment">//支持的解码</span></span><br><span class="line">ffmpeg -decoders</span><br><span class="line"><span class="comment">//支持的编码</span></span><br><span class="line">ffmpeg -encoders</span><br><span class="line"><span class="comment">//支持的协议</span></span><br><span class="line">ffmpeg -protocols</span><br><span class="line"><span class="comment">//本地视频文件推流至指定rtmp流媒体服务器</span></span><br><span class="line">ffmpeg -re -<span class="tag">i</span> movie<span class="class">.mp4</span> -c copy -f flv rtmp:<span class="comment">//localhost:1935/live/room</span></span><br><span class="line"><span class="comment">//媒体流保存为视频文件</span></span><br><span class="line">ffmpeg -<span class="tag">i</span> rtmp:<span class="comment">//localhost:1935/live/room -c copy moive.flv</span></span><br></pre></td></tr></table></figure>
<p>更多命令请看文档<a href="http://ffmpeg.org/documentation.html" target="_blank" rel="external">FFmpeg文档</a></p>
<h2 id="FFmpeg编译"><a href="#FFmpeg编译" class="headerlink" title="FFmpeg编译"></a><strong>FFmpeg编译</strong></h2><p>首先在官网下载<a href="http://ffmpeg.org/" target="_blank" rel="external">FFmpeg</a></p>
<p>在root dir编辑configure文件，把以下内容</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">SLIBNAME_WITH_MAJOR</span>='<span class="variable">$(SLIBNAME)</span>.<span class="variable">$(LIBMAJOR)</span>'</span><br><span class="line"><span class="constant">LIB_INSTALL_EXTRA_CMD</span>='$<span class="variable">$(RANLIB)</span> "<span class="variable">$(LIBDIR)</span>/<span class="variable">$(LIBNAME)</span>"'</span><br><span class="line"><span class="constant">SLIB_INSTALL_NAME</span>='<span class="variable">$(SLIBNAME_WITH_VERSION)</span>'</span><br><span class="line"><span class="constant">SLIB_INSTALL_LINKS</span>='<span class="variable">$(SLIBNAME_WITH_MAJOR)</span> <span class="variable">$(SLIBNAME)</span>'</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">SLIBNAME_WITH_MAJOR</span>='<span class="variable">$(SLIBPREF)</span><span class="variable">$(FULLNAME)</span>-<span class="variable">$(LIBMAJOR)</span><span class="variable">$(SLIBSUF)</span>'</span><br><span class="line"><span class="constant">LIB_INSTALL_EXTRA_CMD</span>='$<span class="variable">$(RANLIB)</span> "<span class="variable">$(LIBDIR)</span>/<span class="variable">$(LIBNAME)</span>"'</span><br><span class="line"><span class="constant">SLIB_INSTALL_NAME</span>='<span class="variable">$(SLIBNAME_WITH_MAJOR)</span>'</span><br><span class="line"><span class="constant">SLIB_INSTALL_LINKS</span>='<span class="variable">$(SLIBNAME)</span>'</span><br></pre></td></tr></table></figure>
<p>目的是修改so的文件名，为了编译出来的so能够被android平台正常使用，否则将编译出<code>libavcodec.so.57.64.100</code>这种类型的so，替换后将编译成我们能正常使用的<code>libavcodec-57.so</code>动态链接库，后面的数字为版本号</p>
<p>一般对于so，我们只需兼容arm cpu架构的即可，在root dir下新建bash脚本文件，内容为：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">NDK=$HOME/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=$NDK/platforms/android-14/arch-arm/</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64</span><br><span class="line"></span><br><span class="line">CPU=arm</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">ADDI_CFLAGS=""</span><br><span class="line">ADDI_LDFLAGS=""</span><br><span class="line"></span><br><span class="line">function build_arm</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    -<span class="ruby">-prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line"></span>    -<span class="ruby">-enable-shared \</span><br><span class="line"></span>    -<span class="ruby">-disable-static \</span><br><span class="line"></span>    -<span class="ruby">-disable-doc \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffmpeg \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffplay \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffprobe \</span><br><span class="line"></span>    -<span class="ruby">-disable-ffserver \</span><br><span class="line"></span>    -<span class="ruby">-disable-symver \</span><br><span class="line"></span>    -<span class="ruby">-enable-avresample \</span><br><span class="line"></span>    -<span class="ruby">-enable-small \</span><br><span class="line"></span>    -<span class="ruby">-cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \</span><br><span class="line"></span>    -<span class="ruby">-target-os=linux \</span><br><span class="line"></span>    -<span class="ruby">-arch=arm \</span><br><span class="line"></span>    -<span class="ruby">-enable-cross-compile \</span><br><span class="line"></span>    -<span class="ruby">-sysroot=<span class="variable">$SYSROOT</span> \</span><br><span class="line"></span>    -<span class="ruby">-extra-cflags=<span class="string">"-Os -fpic $ADDI_CFLAGS"</span> \</span><br><span class="line"></span>    -<span class="ruby">-extra-ldflags=<span class="string">"$ADDI_LDFLAGS"</span> \</span><br><span class="line"></span>    $ADDITIONAL_CONFIGURE_FLAG</span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_arm</span><br></pre></td></tr></table></figure>
<p>NDK目录改为自己的NDK目录即可，关于configure配置，可以根据自己需要进行配置，可配置的属性在FFmpeg root dir的configure文件中show_help方法中查看，我摘一段：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Program options:</span><br><span class="line">-<span class="ruby">-disable-programs       <span class="keyword">do</span> <span class="keyword">not</span> build command line programs</span><br><span class="line"></span>-<span class="ruby">-disable-ffmpeg         disable ffmpeg build</span><br><span class="line"></span>-<span class="ruby">-disable-ffplay         disable ffplay build</span><br><span class="line"></span>-<span class="ruby">-disable-ffprobe        disable ffprobe build</span><br><span class="line"></span>-<span class="ruby">-disable-ffserver       disable ffserver build</span></span><br></pre></td></tr></table></figure>
<p><code>--disable-ffmpeg</code>意为禁用ffmpeg工具，编译时不编译出ffmpeg工具，<code>--enable-ffmpeg</code>为启用，但是configure文件配置有个特点，FFmpeg的默认的配置不是以show_help方法中的配置配置的，而是以前缀<code>disable</code>or<code>enable</code>取反配置的，也就是FFmpeg中各属性默认的配置把show_help中各个配置的前缀取反即可，<code>disable</code>变为<code>enable</code>，<code>enable</code>变为<code>disable</code>，如：在上面那段配置中，<code>--disable-ffmpeg</code>意为启用ffmpeg工具。</p>
<p>但是我们编译的bash脚本中却不是这样，而是配置的实意配置，<code>disable</code>就是<code>disable</code>。</p>
<p>运行上面的bash脚本：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ffmpeg-3.2</span><br><span class="line">./build_ffmpeg_arm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>编译完成后可以发现在FFmpeg的root目录下多了一个android目录，该目录就是所生成对应cup架构的so目录<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-11-14788686122391.jpg" alt=""></p>
<hr>
<p>按以上配置的bash脚本，会发现<code>libavcodec-57.so</code>比较大，有7.6M，肯定不能在Android中使用，所以，在编译时，我们可以针对自己需要的功能来进行配置，更改bash脚本，加入配置：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--disable-everything</span></span><br></pre></td></tr></table></figure>
<p>该属性会把下列所有的组件都不加入编译：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Individual component options:</span><br><span class="line">-<span class="ruby">-disable-everything     disable all components listed below</span><br><span class="line"></span>-<span class="ruby">-disable-encoder=<span class="constant">NAME</span>   disable encoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-encoder=<span class="constant">NAME</span>    enable encoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-encoders       disable all encoders</span><br><span class="line"></span>-<span class="ruby">-disable-decoder=<span class="constant">NAME</span>   disable decoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-decoder=<span class="constant">NAME</span>    enable decoder <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-decoders       disable all decoders</span><br><span class="line"></span>-<span class="ruby">-disable-hwaccel=<span class="constant">NAME</span>   disable hwaccel <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-hwaccel=<span class="constant">NAME</span>    enable hwaccel <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-hwaccels       disable all hwaccels</span><br><span class="line"></span>-<span class="ruby">-disable-muxer=<span class="constant">NAME</span>     disable muxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-muxer=<span class="constant">NAME</span>      enable muxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-muxers         disable all muxers</span><br><span class="line"></span>-<span class="ruby">-disable-demuxer=<span class="constant">NAME</span>   disable demuxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-enable-demuxer=<span class="constant">NAME</span>    enable demuxer <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-demuxers       disable all demuxers</span><br><span class="line"></span>-<span class="ruby">-enable-parser=<span class="constant">NAME</span>     enable parser <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-parser=<span class="constant">NAME</span>    disable parser <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-parsers        disable all parsers</span><br><span class="line"></span>-<span class="ruby">-enable-bsf=<span class="constant">NAME</span>        enable bitstream filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-bsf=<span class="constant">NAME</span>       disable bitstream filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-bsfs           disable all bitstream filters</span><br><span class="line"></span>-<span class="ruby">-enable-protocol=<span class="constant">NAME</span>   enable protocol <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-protocol=<span class="constant">NAME</span>  disable protocol <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-protocols      disable all protocols</span><br><span class="line"></span>-<span class="ruby">-enable-indev=<span class="constant">NAME</span>      enable input device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-indev=<span class="constant">NAME</span>     disable input device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-indevs         disable input devices</span><br><span class="line"></span>-<span class="ruby">-enable-outdev=<span class="constant">NAME</span>     enable output device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-outdev=<span class="constant">NAME</span>    disable output device <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-outdevs        disable output devices</span><br><span class="line"></span>-<span class="ruby">-disable-devices        disable all devices</span><br><span class="line"></span>-<span class="ruby">-enable-filter=<span class="constant">NAME</span>     enable filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-filter=<span class="constant">NAME</span>    disable filter <span class="constant">NAME</span></span><br><span class="line"></span>-<span class="ruby">-disable-filters        disable all filters</span></span><br></pre></td></tr></table></figure>
<p>而我们生成的<code>libavcodec-57.so</code>过大也是由于加入了过多我们不需要使用的组件，禁用了所有的，接下来就是把自己需要的加入到bash脚本中配置即可，比如加入下面两个配置确保h264和aac的解码功能的保留：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-enable-decoder=h264</span><br><span class="line"></span>-<span class="ruby">-enable-decoder=aac</span></span><br></pre></td></tr></table></figure>
<p>等等，当然还有其它的，可以参考上面禁用的配置进行选择性保留。</p>
<h2 id="编译支持H-264编码的FFmpeg动态链接库"><a href="#编译支持H-264编码的FFmpeg动态链接库" class="headerlink" title="编译支持H.264编码的FFmpeg动态链接库"></a><strong>编译支持H.264编码的FFmpeg动态链接库</strong></h2><h3 id="x264"><a href="#x264" class="headerlink" title="x264"></a><strong>x264</strong></h3><p>首先下载<a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="external">x264源码</a><br>x264是一个开源的H.264编码器，据说是最好的视频有损编码器，和编译FFmpeg类似，要编译x264成动态so库，一样通过configure配置文件，需要先修改configure文件中的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"SOSUFFIX=so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SONAME=libx264.so.$API"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SOFLAGS=-shared -Wl,-soname,\$(SONAME) $SOFLAGS"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"SOSUFFIX=so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SONAME=libx264-$API.so"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br><span class="line">echo <span class="string">"SOFLAGS=-shared -Wl,-soname,\$(SONAME) $SOFLAGS"</span> <span class="prompt">&gt;&gt; </span>config.mak</span><br></pre></td></tr></table></figure>
<p>目的一样，确保可以在Android平台下可用，然后使用下面的bash脚本进行编译，arm为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">NDK=<span class="variable">$HOME</span>/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=<span class="variable">$NDK</span>/platforms/android-<span class="number">14</span>/arch-arm/</span><br><span class="line">TOOLCHAIN=<span class="variable">$NDK</span>/toolchains/arm-linux-androideabi-<span class="number">4.9</span>/prebuilt/darwin-x86_64</span><br><span class="line"></span><br><span class="line">CPU=arm</span><br><span class="line">PREFIX=$(<span class="built_in">pwd</span>)/android/<span class="variable">$CPU</span></span><br><span class="line">ADDI_CFLAGS=<span class="string">""</span></span><br><span class="line">ADDI_LDFLAGS=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> build_arm</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    --prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --disable-asm \</span><br><span class="line">    --enable-pic \</span><br><span class="line">    --enable-strip \</span><br><span class="line">    --host=arm-linux-androideabi \</span><br><span class="line">    --cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \</span><br><span class="line">    --sysroot=<span class="variable">$SYSROOT</span></span><br><span class="line">    --extra-cflags=<span class="string">"-Os -fpic <span class="variable">$ADDI_CFLAGS</span>"</span> \</span><br><span class="line">    --extra-ldflags=<span class="string">"<span class="variable">$ADDI_LDFLAGS</span>"</span> \</span><br><span class="line">    <span class="variable">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build_arm</span><br></pre></td></tr></table></figure>
<p>NDK目录同样改为自己的<br>运行上面脚本：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> x264</span><br><span class="line">./build_x264_arm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>编译完成后可以android目录找到<code>libx264-148.so</code>库</p>
<h3 id="静态链接x264编译"><a href="#静态链接x264编译" class="headerlink" title="静态链接x264编译"></a><strong>静态链接x264编译</strong></h3><p>FFmpeg默认是不支持H.264的编码，不过支持H.264解码，但是FFmpeg为我们提供了众多配置，可添加额外功能库的支持，方便我们自己链接所需要额外功能的库，在FFmpeg的configure文件配置中，可以看到这么一段配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">External library support:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">-<span class="ruby">-enable-libfdk-aac      enable <span class="constant">AAC</span> de/encoding via libfdk-aac [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libopenh264     enable <span class="constant">H</span>.<span class="number">264</span> encoding via <span class="constant">OpenH264</span> [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libopenjpeg     enable <span class="constant">JPEG</span> <span class="number">2000</span> de/encoding via <span class="constant">OpenJPEG</span> [no]</span><br><span class="line"></span>-<span class="ruby">-enable-librtmp         enable <span class="constant">RTMP</span>[<span class="constant">E</span>] support via librtmp [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libwebp         enable <span class="constant">WebP</span> encoding via libwebp [no]</span><br><span class="line"></span>-<span class="ruby">-enable-libx264         enable <span class="constant">H</span>.<span class="number">264</span> encoding via x264 [no]</span><br><span class="line"></span>-<span class="ruby">-enable-opengl          enable <span class="constant">OpenGL</span> rendering [no]</span><br><span class="line"></span>-<span class="ruby">-enable-openssl         enable openssl, needed <span class="keyword">for</span> https support</span><br><span class="line"></span>if gnutls is not used [no]</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>避免篇幅太长，做了一部分删减，留了一些比较眼熟的，FFmpeg可以让我们自己配置添加需要的功能库，如使用fdk-aac库来做aac的编解码，H.264编码可选x264或openh264以及可选其它功能库的支持</p>
<p>要编译支持x264编码的FFmpeg动态链接库，首先是编译出x264静态链接库<code>libx264.a</code>，然后修改FFmpeg的编译脚本，配置x264静态链接库和头文件路径，接下来即可编译了</p>
<h4 id="1、编译x264静态链接库"><a href="#1、编译x264静态链接库" class="headerlink" title="1、编译x264静态链接库"></a><strong>1、编译x264静态链接库</strong></h4><p>因为FFmpeg是使用静态链接方式链接其它额外的外部功能库，所以需要把x264库编译成<code>.a</code>静态库，通过<code>--enable-static</code>配置参数来编译出<code>.a</code>静态库，而<code>--enable-shared</code>则是编译动态链接so库，所以只需在上面的x264脚本中增加个配置：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-<span class="keyword">static</span></span><br></pre></td></tr></table></figure>
<p>编译成功后可以看到如下目录结构：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-13-14789707702522.jpg" alt=""></p>
<h4 id="2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译"><a href="#2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译" class="headerlink" title="2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译"></a><strong>2、在FFmpeg脚本中配置x264静态链接库和头文件路径及编译</strong></h4><p>在此之前，先安装yasm：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install yasm</span><br></pre></td></tr></table></figure>
<p>然后在之前FFmpeg的脚本基础上添加以下配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-enable-gpl \</span><br><span class="line"></span>-<span class="ruby">-enable-libx264 \</span><br><span class="line"></span>-<span class="ruby">-enable-yasm \</span><br><span class="line"></span>-<span class="ruby">-extra-cflags=<span class="string">"-I../x264/android/arm/include"</span> \</span><br><span class="line"></span>-<span class="ruby">-extra-ldflags=<span class="string">"-L../x264/android/arm/lib"</span> \</span></span><br></pre></td></tr></table></figure>
<p>FFmpeg默认的LICENSE是LGPL，而libx264需要GPL，所以加入<code>--enable-gpl</code>，最后面两项配置是配置编译x264出的头文件和静态链接库路径，在这里我把x264和FFmpeg放在了同一目录层级，故可这样配置。<br>如果你需要修改<code>--extra-cflags</code>和<code>--extra-ldflags</code>路径为自己x264头文件和静态链接库路径，必须符合<code>--extra-cflags</code>以-I开头，<code>--extra-ldflags</code>以-L开头，这些参数含义为：</p>
<blockquote>
<p>-D：用于在编译时定义宏<br>-I：编译阶段生效的参数，用于指定头文件的搜索路径<br>-L：链接阶段生效的参数，用于指定链接库的搜索路径，-l用于指定链接库的名称，一般两者一起使用的话，就可以指定动态链接库</p>
</blockquote>
<p>比如x264在桌面上，路径为：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-extra-cflags=<span class="string">"-I/Users/Sunzxyong/Desktop/x264/android/arm/include"</span> \</span><br><span class="line"></span>-<span class="ruby">-extra-ldflags=<span class="string">"-L/Users/Sunzxyong/Desktop/x264/android/arm/lib"</span> \</span></span><br></pre></td></tr></table></figure>
<p>然后进行编译，编译中可以看到encode的支持选择中，多了libx264的支持：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/2016-11-13-14790203252342.jpg" alt=""></p>
<p>其它外部添加库如fdk-aac、openh264等也类似方式链接编译</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a><strong>Github</strong></h2><p><a href="https://github.com/Sunzxyong/FFmpeg-Compile-For-Android" target="_blank" rel="external">FFmpeg编译脚本</a></p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/11/13/%E5%88%9D%E8%AF%86FFmpeg%E7%BC%96%E8%AF%91%E9%82%A3%E4%BA%9B%E4%BA%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android运行时Crash自动恢复框架-Recovery</title>
      <link>http://zhengxiaoyong.com/2016/09/05/Android%E8%BF%90%E8%A1%8C%E6%97%B6Crash%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E6%A1%86%E6%9E%B6-Recovery/</link>
      <guid>http://zhengxiaoyong.com/2016/09/05/Android%E8%BF%90%E8%A1%8C%E6%97%B6Crash%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E6%A1%86%E6%9E%B6-Recovery/</guid>
      <pubDate>Mon, 05 Sep 2016 11:35:32 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;App Crash的恢复，这个想法很早之前就有，目前有些时间就实现了一把，主要是对App运行时发生Crash后，对Activity的堆栈和数据进行恢复，或者重启应用，或者重启并清空缓存，避免因本地的数据类型或格式错误而导致App在读取时一直Crash，Debug模式还包括Crash信息的显示和保存，便于在开发、测试时查看相应CrashInfo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Crash的处理&quot;&gt;&lt;a href=&quot;#Crash的处理&quot; class=&quot;headerlink&quot; title=&quot;Crash的处理&quot;&gt;&lt;/a&gt;&lt;strong&gt;Crash的处理&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对于应用的Crash，一般的做法我们往往都是实现个自定义&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，而这个自定义的CustomUncaughtHandler我们一般都用于捕捉Crash信息进行上报和监控是否发生Crash，还有一个作用就是可以屏蔽系统默认的Crash对话框，也就是拦截Crash后不把系统默认的UncaughtHandler设置进去，而是直接进行KillProcess，这个过程就是屏蔽了系统的默认Crash处理流程，原因是系统的处理其中在AMS的crashApplication()中会执行这么一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;Message&lt;/span&gt; msg = &lt;span class=&quot;type&quot;&gt;Message&lt;/span&gt;.obtain();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg.what = &lt;span class=&quot;type&quot;&gt;SHOW_ERROR_MSG&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;HashMap&lt;/span&gt; data = new &lt;span class=&quot;type&quot;&gt;HashMap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.put(&lt;span class=&quot;string&quot;&gt;&quot;result&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.put(&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;msg.obj = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mUiHandler.sendMessage(msg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;发送一个显示Dialog的消息，之后便创建一个AppErrorDialog进行显示。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><blockquote>
<p>App Crash的恢复，这个想法很早之前就有，目前有些时间就实现了一把，主要是对App运行时发生Crash后，对Activity的堆栈和数据进行恢复，或者重启应用，或者重启并清空缓存，避免因本地的数据类型或格式错误而导致App在读取时一直Crash，Debug模式还包括Crash信息的显示和保存，便于在开发、测试时查看相应CrashInfo</p>
</blockquote>
<h1 id="Crash的处理"><a href="#Crash的处理" class="headerlink" title="Crash的处理"></a><strong>Crash的处理</strong></h1><p>对于应用的Crash，一般的做法我们往往都是实现个自定义<code>UncaughtExceptionHandler</code>，而这个自定义的CustomUncaughtHandler我们一般都用于捕捉Crash信息进行上报和监控是否发生Crash，还有一个作用就是可以屏蔽系统默认的Crash对话框，也就是拦截Crash后不把系统默认的UncaughtHandler设置进去，而是直接进行KillProcess，这个过程就是屏蔽了系统的默认Crash处理流程，原因是系统的处理其中在AMS的crashApplication()中会执行这么一段代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> msg = <span class="type">Message</span>.obtain();</span><br><span class="line">msg.what = <span class="type">SHOW_ERROR_MSG</span>;</span><br><span class="line"><span class="type">HashMap</span> data = new <span class="type">HashMap</span>();</span><br><span class="line">data.put(<span class="string">"result"</span>, <span class="literal">result</span>);</span><br><span class="line">data.put(<span class="string">"app"</span>, r);</span><br><span class="line">msg.obj = data;</span><br><span class="line">mUiHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>发送一个显示Dialog的消息，之后便创建一个AppErrorDialog进行显示。<br><a id="more"></a><br>当然还有另外一种屏蔽系统默认ErrorDialog的方法，就是对AMP进行Hook，拦截handleApplicationCrash()方法后进行KillProcess，这样的话永远都将不会出现系统默认对话框，即使把系统默认的设置进去了，这个方法建议App内对AMP进行了Hook的做，其它App反而只为实现这个小功能而进行Hook成本太高，还是用自定义的做法进行屏蔽。</p>
<h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a><strong>Recovery</strong></h1><h2 id="Crash处理流程"><a href="#Crash处理流程" class="headerlink" title="Crash处理流程"></a><strong>Crash处理流程</strong></h2><p>对于Recovery，在应用发生Crash时，会进入一个Recovery界面，在该界面可以进行界面的恢复、应用的重启，或进入debug模式进行Crash信息的查看与保存</p>
<h2 id="接入"><a href="#接入" class="headerlink" title="接入"></a><strong>接入</strong></h2><h3 id="请戳这里"><a href="#请戳这里" class="headerlink" title="请戳这里"></a><a href="https://github.com/Sunzxyong/Recovery/blob/master/README.md" target="_blank" rel="external">请戳这里</a></h3><h2 id="RecoveryActivity"><a href="#RecoveryActivity" class="headerlink" title="RecoveryActivity"></a><strong>RecoveryActivity</strong></h2><p>在应用发生Crash后，将进入RecoveryActivity界面<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/Recovery.png" alt="Recovery"></p>
<h2 id="ActivityStack的恢复"><a href="#ActivityStack的恢复" class="headerlink" title="ActivityStack的恢复"></a><strong>ActivityStack的恢复</strong></h2><p>对于恢复界面，默认是恢复整个Activity的堆栈，以便保护用户之前的数据</p>
<p>当应用在前台时崩溃无非就三种：<br>1、界面一创建就崩溃，可能在onCreate等方法中读取数据造成的Crash<br>2、界面创建且绘制完成正常显示，在用户执行某个操作，如点击按钮执行某个操作等造成的Crash<br>3、其它异步线程、服务等在后台执行任务时导致的Crash</p>
<p>上面的情况都应恢复绘制完成后的界面，也就是栈顶Activity是在Crash之前用户所看到的界面，而之前创建且未销毁的Activity也应该进行恢复。</p>
<p>当应用在后台时：<br>1、进程未挂，无非就是异步线程、server等后台任务发生异常时导致的Crash<br>2、进程已挂，进程被360等工具杀死了，常见的是push过来了然后唤起App进程，在解析push信息时候导致Crash</p>
<p>上面的情况App在后台时导致的Crash，Recovery提供了一个参数（recoverInBackgroud），用来设置是否在后台Crash时进行恢复。</p>
<p>ActivityStack恢复的操作，都是先恢复栈中的Activity，无Activity时则重启应用</p>
<h2 id="主页的回退"><a href="#主页的回退" class="headerlink" title="主页的回退"></a><strong>主页的回退</strong></h2><p>在进行恢复Activity时，如果只是恢复栈顶Activity，当用户在这个界面不进行跳转操作而是直接按返回键，这将导致直接退出程序，所以对于这个情况应该是回退到应用的主页，Recovery中有个参数mainPage，如果设置了就表示需要回退到主页，没有设置则不进行回退</p>
<p>这个过程中涉及到获取App内Activity栈内的数量和栈底Activity，是开发人员应该都知道获取这两个信息是通过getRunningTasks来获取，不过可惜，在5.0以后Google对权限进行了收敛，目地是保护App的信息安全，这个方法在5.0以后将失效，所以需要另外一种方法进行兼容，于是乎看6.0源码又发现Google在5.0收敛了整个权限，导致本App的都获取不到，但是在6.0又放出来了，不过只能获取本应用的数据，所以兼容的策略是5.0~6.0自己维护一个ActivityStack</p>
<h2 id="连续Crash的处理"><a href="#连续Crash的处理" class="headerlink" title="连续Crash的处理"></a><strong>连续Crash的处理</strong></h2><p>如果一分钟内进行了两次恢复后还导致Crash，则不进行恢复而是重启应用，或者重启并清空缓存，以便恢复App刚安装时的状态</p>
<h2 id="静默恢复"><a href="#静默恢复" class="headerlink" title="静默恢复"></a><strong>静默恢复</strong></h2><p>对于应用运行时发生Crash后的恢复，默认是显示RecoveryActivity，也就是上图的界面来让用户选择是否需要进行恢复，同时也支持静默恢复，也就是不显示界面，在发生Crash后根据所配置参数自动的恢复（重启、恢复ActivityStack、恢复栈顶Activity、重启并清空缓存）</p>
<h2 id="无图言屌"><a href="#无图言屌" class="headerlink" title="无图言屌"></a><strong>无图言屌</strong></h2><p>下面是效果图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/recovery.gif" alt="Gif"></p>
<p>静默恢复的效果图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/recovery_silence.gif" alt="silence"></p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a><strong>项目地址</strong></h2><p>欢迎star或提建议</p>
<h3 id="还是戳我"><a href="#还是戳我" class="headerlink" title="还是戳我"></a><a href="https://github.com/Sunzxyong/Recovery" target="_blank" rel="external">还是戳我</a></h3>]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/09/05/Android%E8%BF%90%E8%A1%8C%E6%97%B6Crash%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E6%A1%86%E6%9E%B6-Recovery/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android端应用秒开优化体验</title>
      <link>http://zhengxiaoyong.com/2016/07/18/Android%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C/</link>
      <guid>http://zhengxiaoyong.com/2016/07/18/Android%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C/</guid>
      <pubDate>Mon, 18 Jul 2016 13:43:26 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近部门内抛出了一个问题，应用启动很慢、卡图标？主要表现在中低端机型中。究其这个问题，由于对性能优化比较感兴趣，借了个低端机和一个中端机来一看究竟，对同一应用分别测了下它在中低端机的启动时间，下面为启动耗时情况：&lt;br&gt;&lt;img src=&quot;http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_one.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;启动了三次，基本都在4s左右。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近部门内抛出了一个问题，应用启动很慢、卡图标？主要表现在中低端机型中。究其这个问题，由于对性能优化比较感兴趣，借了个低端机和一个中端机来一看究竟，对同一应用分别测了下它在中低端机的启动时间，下面为启动耗时情况：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_one.jpg" alt=""></p>
<p>启动了三次，基本都在4s左右。<br><a id="more"></a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a><strong>原因</strong></h2><p>究其原因，主要因素是任务在界面绘制前过于集中化。</p>
<p>应用启动过程从用户点击launcher图标到看到第一帧这个过程中，主要会经过以下这些过程：</p>
<blockquote>
<p>main()-&gt;Application:attachBaseContext()-&gt;onCreate()-&gt;Activity:onCreate()-&gt;onStart()-&gt;onPostCreate()-&gt;onResume()-&gt;onPostResume()</p>
</blockquote>
<p>而一般我们的初始化任务主要都会集中化在Application:onCreate()方法中，这就使得初始化任务在第一帧绘制之前得完成，这就造成了卡图标、应用启动慢。那么把任务打散呢？分散在LaunchActivity中去分段初始化？还是不行的，因为界面开始绘制是在onResume()方法开始后才开始绘制，所以，得从Activity的创建过程找办法。</p>
<p>main-&gt;Activity创建的这个过程会经过一系列framework层的操作，这些操作都是系统自动执行的，不易进行优化，不过可以在Activity创建这个过程前后来找一些蛛丝马迹，因为Activity的创建都会辗转到ActivityThread:performLaunchActivity()这个方法中，在这个方法中可以知道这么几件事：<br>1、先通过Instrumentation:newActivity()来创建一个Activity实例<br>2、再判断Application实例是否已创建，已创建则直接返回，否则调用<br>Instrumentation:newApplication()来创建Application实例，在这个过程中会依次执行attachBaseContext()和onCreate()方法<br>3、之后Activity:attach()方法会创建一个PhoneWindow对象，它就是界面，它有一个DecorView，调用setContentView()时会给配置DecorView，其中就会设置一个背景：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launc_code.jpg" alt=""></p>
<p>我们的View也是add进DecorView中显示，它作为RootView肯定是最先显示，所以可以给它设置个默认背景<br>4、最后依次调用Activity的onCreate、onStart等方法</p>
<h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a><strong>措施</strong></h2><blockquote>
<p>1、任务分级<br>2、任务并行<br>3、界面预显示</p>
</blockquote>
<p>对于任务集中初始化化、耗时初始化原因导致应用在中低端机启动过慢，而Activity界面绘制的时机导致简单的将任务分给Activity初始化也不起作用，我们必须找一个切入点</p>
<blockquote>
<p>界面的创建和界面的绘制，这两个过程第一个是Application的attachBaseConte和onCreate这两个方法影响的，第二个则是Application创建一直到界面绘制</p>
</blockquote>
<p>所以，可以对任务进行分级的临界点可以这样分：</p>
<blockquote>
<p>1、CoreSDK——Application的创建<br>2、HighPrioritySDK——Activity的创建<br>3、LowPrioritySDK——Activity界面完成绘制<br>4、AsyncSDK——Activity的创建</p>
</blockquote>
<p>如图：<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/launch.png" alt="launch"></p>
<p>对任务这样分级后，测了一下，应用的启动即使在低端机上，也能秒开:<br><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/launch_two.jpg" alt=""></p>
<h2 id="分级带来的问题"><a href="#分级带来的问题" class="headerlink" title="分级带来的问题"></a><strong>分级带来的问题</strong></h2><p>正常启动过程那肯定是没问题的，不过有这么几种场景：</p>
<blockquote>
<p>1、App切回后台，内存不足导致Application被回收，从最近任务列表中恢复界面时Application需重新创建<br>2、应用没挂起时，Push推送需从Notification跳入应用内某界面<br>3、应用没挂起时，浏览器外链需跳入应用内某界面</p>
</blockquote>
<p>这些Case可能导致的问题是被跳入的界面使用到了未初始化的SDK，可能导致Crash或者数据异常，所以目标页面启动前必须确保SDK已经初始化，这个过程的原因是没有唤起启动页来初始化SDK，可以通过hook newActivity解决，其中判断Application是否初始化和各个SDK是否初始化，并且判断该次启动不来自系统的Launcher。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InitializeOptimizer.isApplicationCreated()</span><br><span class="line">            &amp;&amp; (!InitializeOptimizer.isHighSDKInitialized()</span><br><span class="line">            || !InitializeOptimizer.isLowSDKInitialized()</span><br><span class="line">            || !InitializeOptimizer.isAsyncSDKInitialized()) &amp;&amp; !InitializeUtil.isAppLauncher(intent)) &#123;</span><br><span class="line">        InitializeOptimizer.setApplicationCreated(<span class="keyword">false</span>);</span><br><span class="line">        intent.addCategory(InitializeUtil.INITIALIZE_CATEGORY);</span><br><span class="line">        <span class="keyword">return</span> (Activity) cl.loadClass(WDInitializeOptimizer.getLaunchClassName()).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    InitializeOptimizer.setApplicationCreated(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">newActivity</span><span class="params">(cl, className, intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/07/18/Android%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>UrlRouter路由框架的设计</title>
      <link>http://zhengxiaoyong.com/2016/04/24/UrlRouter%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
      <guid>http://zhengxiaoyong.com/2016/04/24/UrlRouter%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
      <pubDate>Sun, 24 Apr 2016 14:10:36 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;UrlRouter的设计&quot;&gt;&lt;a href=&quot;#UrlRouter的设计&quot; class=&quot;headerlink&quot; title=&quot;UrlRouter的设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;UrlRouter的设计&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1、可取代使用startActivity、startActivityForResult跳转的情景，便于协同开发&lt;br&gt;2、通过一串url可任意跳转到指定界面，使用应尽可能简单&lt;br&gt;3、支持各种类型参数传递、界面转场动画&lt;br&gt;4、可获取起跳界面的路径和当前界面路径，以便支持后期埋点等需求&lt;br&gt;5、支持从H5到Native，Native到H5，这是Hybrid开发模式中常用到的需求&lt;br&gt;6、对于push、浏览器外链跳转等可方便配置化，通过一个url来跳转指定界面&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="UrlRouter的设计"><a href="#UrlRouter的设计" class="headerlink" title="UrlRouter的设计"></a><strong>UrlRouter的设计</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><blockquote>
<p>1、可取代使用startActivity、startActivityForResult跳转的情景，便于协同开发<br>2、通过一串url可任意跳转到指定界面，使用应尽可能简单<br>3、支持各种类型参数传递、界面转场动画<br>4、可获取起跳界面的路径和当前界面路径，以便支持后期埋点等需求<br>5、支持从H5到Native，Native到H5，这是Hybrid开发模式中常用到的需求<br>6、对于push、浏览器外链跳转等可方便配置化，通过一个url来跳转指定界面</p>
</blockquote>
<a id="more"></a>
<h3 id="url格式"><a href="#url格式" class="headerlink" title="url格式"></a><strong>url格式</strong></h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">scheme:</span><span class="comment">//host/path</span></span><br></pre></td></tr></table></figure>
<p>scheme：APP内自己定义的，不过这个在H5内跳Native时，需要和前端协商定义好，本地间的跳转可以随自己定义，比如：activity<br>host：这个尽可能按各个Activity的所在模块命名<br>path：各个Activity的功能名</p>
<p>这样一来，比如我跳转到商品详情页的url：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">activity:</span><span class="comment">//product/detail</span></span><br></pre></td></tr></table></figure>
<h3 id="匹配对应的Activity"><a href="#匹配对应的Activity" class="headerlink" title="匹配对应的Activity"></a><strong>匹配对应的Activity</strong></h3><p>刚刚我们定义好了跳转的url规则，那么就需要把这个规则配置给对应的Activity，对于规则的配置，要哪种方式好呢？目前网络上的路由框架大致都是通过注解或维护一套映射表来实现的，内部处理也比较麻烦。因此我们需要一套简单的方式来处理，在Android系统中，我们知道startActivity打开界面的原理是在manifest文件中对Intent进行匹配，如果找到了符合该Intent的Activity则打开，否则将报一个异常：<code>ActivityNotFoundException</code>，我想大部分同学在startActivity时可能没有注意到这个异常，因为以往我们都是通过显示的设置一个<code>Activity.class</code>字节码对象给Intent，这在manifest中自然会找到，如果我们设置一个不存在的包名或者类名，那么在跳转时就会抛出这个异常，所以一个良好的实践是在startActivity时判断该Intent是否已经正确匹配到目标Activity，匹配成功则跳转，失败则自己处理，代码如下：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isIntentAvailable(Context context, Intent intent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || intent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">    <span class="keyword">List</span>&lt;ResolveInfo&gt; <span class="keyword">list</span> = packageManager.queryIntentActivities(intent,</span><br><span class="line">            PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>.size() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是通过在manifest中匹配Intent来跳转到指定界面，那么我们可以通过配置Activity的<code>intent-filter</code>规则来匹配，其中Action、Category、Data需要配置，而Action、Category我们可以固定为VIEW和DEFAULT，而Data则才是用来匹配目标Intent的，如下是匹配刚刚商品详情页的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".DetailActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"product"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/detail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假如这个界面也需要支持从H5界面唤起，那么在保持native的跳转功能之外，还可以把前端定义的规则一起加进来，比如前端定义的唤起商品详情页的url为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h5</span>:<span class="comment">//webview/goods_detail</span></span><br></pre></td></tr></table></figure>
<p>当然这是我乱写的，具体的应该定义的更有意义些，这里为了区分就随便定义了下，还有后面肯定是带了参数的，用来传递给打开的界面，为了简洁我给省略了。同时要支持上面这串url，我们只需在指定的Activity配置相应data即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".DetailActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"product"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/detail"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"h5"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:host</span>=<span class="value">"webview"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:path</span>=<span class="value">"/goods_detail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面既然配置好了Activity，那么Intent就可以这样设置了：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>();</span><br><span class="line"><span class="type">intent</span>.setAction(<span class="type">Intent</span>.ACTION_VIEW);</span><br><span class="line"><span class="type">intent</span>.addCategory(<span class="type">Intent</span>.CATEGORY_DEFAULT);</span><br><span class="line"><span class="type">intent</span>.setData(Uri.parse(<span class="string">"activity://product/detail"</span>));</span><br></pre></td></tr></table></figure>
<p>不过还没设置目标Activity的信息，所以这就需要通过<code>packageManager.queryIntentActivities()</code>来查询是否正确匹配符合我们url规则的Activity，有则最终我们会得到一个<code>ResolveInfo</code>对象，通过该对象我们可以得到目标Activity的包名、类名等信息，所以再设置给Intent用来start</p>
<h3 id="参数应怎么传递"><a href="#参数应怎么传递" class="headerlink" title="参数应怎么传递"></a><strong>参数应怎么传递</strong></h3><p>对于参数传递，我相信在使用url的情况下，很容易想到在url后面拼接json、KV或者其它自定义的格式，这种方式在处理普通的int、布尔、字符串确实非常方便，不过在传递对象、List集合情况下就不好处理了，所以，基于这个，可以这样定义，在传递字符串、int、布尔类型时直接使用url拼接形式，涉及到其它复杂的数据类型时使用Bundle传递</p>
<h3 id="匹配到多个Activity的处理"><a href="#匹配到多个Activity的处理" class="headerlink" title="匹配到多个Activity的处理"></a><strong>匹配到多个Activity的处理</strong></h3><p>对于匹配过程中，可能存在一个Intent匹配到多个Activity，这时候就需要处理了，因为最终我们只需要打开一个Activity就行了，这时候千万别使用设置intent-filter的优先级来处理，也即：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:priority</span>=<span class="value">"10"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种做法是错误的，因为这个优先级只对有序广播有效，其它情况下获取到的值都为0，所以正确的处理规则如下：<br>由于系统在匹配过程中，当匹配到多个时，会依匹配符合程度按循序排序好返回给我们，不过这时候难免会有第三方包的Activity，需优先匹配本应用包中的Activity，本包中没有再返回系统最匹配的，代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResolveInfo queryActivity(Context context, Intent intent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || intent == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">    List&lt;ResolveInfo&gt; resolveInfoList = packageManager.queryIntentActivities(intent,</span><br><span class="line">            PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">    <span class="keyword">if</span> (resolveInfoList == <span class="keyword">null</span> || resolveInfoList.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">size</span> = resolveInfoList.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> resolveInfoList.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">String</span> appPackageName = context.getApplicationContext().getPackageName();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        ResolveInfo resolveInfo = resolveInfoList.<span class="built_in">get</span>(i);</span><br><span class="line">        <span class="keyword">String</span> activityName = resolveInfo.activityInfo.name;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(activityName))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (activityName.startsWith(appPackageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolveInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveInfoList.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外置浏览器跳App内页面的处理"><a href="#外置浏览器跳App内页面的处理" class="headerlink" title="外置浏览器跳App内页面的处理"></a><strong>外置浏览器跳App内页面的处理</strong></h3><p>要支持外置浏览器跳App页面，必须在manifest文件中给相应的Activity的<code>intent-filter</code>添加<code>&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</code> 属性，因为从浏览器中发起的intent的Category就是<code>android.intent.category.BROWSABLE</code>，所以要让App中相应的界面接收到浏览器的intent，则必须设置这个Category<br>下面这个filter就支持浏览器跳App内页面:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.BROWSABLE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="UrlRouter框架跳转方式"><a href="#UrlRouter框架跳转方式" class="headerlink" title="UrlRouter框架跳转方式"></a><strong>UrlRouter框架跳转方式</strong></h3><p>最终我们可以封成使用这样的方式来跳转的一个UrlRouter框架：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.<span class="keyword">from</span>(<span class="keyword">this</span>).jump(<span class="string">"activity://native/login"</span>);</span><br></pre></td></tr></table></figure>
<p>当需设置其它params、requestCode、转场动画时，可以这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.from(<span class="keyword">this</span>)</span><br><span class="line">        .params(bundle)</span><br><span class="line">        .requestCode(REQUEST_LOGIN)</span><br><span class="line">        .transitionAnim(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        .jump(<span class="string">"activity://native/login"</span>);</span><br></pre></td></tr></table></figure>
<p>对于需要跳转到主页时，应单独实现一个方法，因为主页的intent的action和category比较特殊，所以主页Activity应这样配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span></span><br><span class="line">    <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme.NoActionBar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">            <span class="attribute">android:host</span>=<span class="value">"native"</span></span><br><span class="line">            <span class="attribute">android:path</span>=<span class="value">"/main"</span></span><br><span class="line">            <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>跳转代码为：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UrlRouter.<span class="keyword">from</span>(<span class="keyword">this</span>).jumpToMain(<span class="string">"activity://native/main"</span>);</span><br></pre></td></tr></table></figure>
<p>这样的方式非常简洁，而且维护也非常方便，因为统一都是在manifest文件中配置，最重要的是没有其它UrlRouter框架那么复杂繁重，最终封的框架只有三个类，简洁精悍！！！</p>
<h2 id="UrlRouter地址"><a href="#UrlRouter地址" class="headerlink" title="UrlRouter地址"></a><strong>UrlRouter地址</strong></h2><p>UrlRouter：<a href="https://github.com/Sunzxyong/UrlRouter" target="_blank" rel="external">github</a></p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/04/24/UrlRouter%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Native与H5交互的那些事</title>
      <link>http://zhengxiaoyong.com/2016/04/20/Native%E4%B8%8EH5%E4%BA%A4%E4%BA%92%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <guid>http://zhengxiaoyong.com/2016/04/20/Native%E4%B8%8EH5%E4%BA%A4%E4%BA%92%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <pubDate>Wed, 20 Apr 2016 04:55:28 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cmdArgs&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;getClass&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[obj]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;[obj].getClass().forName(&lt;span class=&quot;string&quot;&gt;&quot;java.lang.Runtime&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 .getMethod(&lt;span class=&quot;string&quot;&gt;&quot;getRuntime&quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;).invoke(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;).exec(cmdArgs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加&lt;code&gt;@JavascriptInterface&lt;/code&gt;注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的&lt;code&gt;prompt&lt;/code&gt;方法进行解决，只不过&lt;code&gt;需要和前端协商好一套公共的协议&lt;/code&gt;，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span><br><span class="line">            alert(obj);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line">                 .getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加<code>@JavascriptInterface</code>注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的<code>prompt</code>方法进行解决，只不过<code>需要和前端协商好一套公共的协议</code>，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互<br><a id="more"></a></p>
<h2 id="Native与H5怎样安全的进行交互？"><a href="#Native与H5怎样安全的进行交互？" class="headerlink" title="Native与H5怎样安全的进行交互？"></a><strong>Native与H5怎样安全的进行交互？</strong></h2><p>要使得H5内的Js与Native之间安全的相互进行调用，我们除了可以通过添加<code>@JavascriptInterface</code>注解来解决（&gt;=4.2），还有通过<code>prompt</code>的方式，不过如果使用官方的方式，这就需要对4.2以下做兼容了，这样使得我们一个app中有两套Js与Native交互的方式，这样极其不好维护，我们应该只需要一套Js与Native交互的方式，所以，我们借助Js中的<code>prompt</code>方法来实现<code>一套安全的Js与Native交互的JsBridge框架</code></p>
<h3 id="Js与Native代码相互调用"><a href="#Js与Native代码相互调用" class="headerlink" title="Js与Native代码相互调用"></a><strong>Js与Native代码相互调用</strong></h3><p><strong>Native Invoke Js:</strong><br>我们知道如果Native需要调用Js中的方法，只需要使用<code>WebView:loadUrl();</code>方法即可直接调用指定Js代码，如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView<span class="class">.loadUrl</span>("javascript<span class="value">:<span class="function">setUserName</span>(<span class="string">'zhengxiaoyong'</span>);</span>");</span><br></pre></td></tr></table></figure>
<p>这样就直接调用了Js中的<code>setUserName</code>方法并把<code>zhengxiaoyong</code>这个名字传到这个方法中去了，接下来就是Js自己处理了</p>
<p><strong>Js Invoke Native:</strong><br>而如果Js要调用Native中的Java方法呢？这就需要我们自己实现了，因为我们不采取<code>JavascriptInterface</code>的方式，而采取prompt方式<br>对WebView熟悉的同学们应该都知道Js中对应的<code>window.alert()</code>、<code>window.confirm()</code>、<code>window.prompt()</code>这三个方法的调用在<code>WebChromeClient</code>中都有对应的回调方法，分别为：<br><code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt()</code>，对于它们传入的<code>message</code>，都可以在相应的回调方法中接收到，所以，对于Js调Native方法，我们可以借助这个信道，和前端协定好一段特定规则的<code>message</code>，这个规则中应至少包含这些信息：</p>
<blockquote>
<p>所调用Native方法所在类的类名<br>所调用Native的方法名<br>Js调用Native方法所传入的参数</p>
</blockquote>
<p>所以基于这些信息，很容易想到使用http协议的格式来协定规则，如下格式：</p>
<blockquote>
<p><strong>scheme://host:port/path?query</strong><br>对应的我们协定<code>prompt</code>传入<code>message</code>的格式为:<br><strong>jsbridge://class:port/method?params</strong></p>
</blockquote>
<p>这样以来，前端和app端协商好后，以后前端需要通过Js调用Native方法来获取一些信息或功能，就只需要按照协议的格式把需要调用的类名、方法名、参数放入对应得位置即可，而我们会在<code>onJsPrompt</code>方法中接受到，所以我们根据与前端协定好的协议来进行解析，我们可以用一个<code>Uri</code>来包装这段协议，然后通过<code>Uri:getHost、getPath、getQuery</code>方法获取对应的类名，方法名，参数数据，最后通过反射来调用指定类中指定的方法</p>
<p>而此时会有人问？<code>port</code>是用来干嘛的？params格式是KV还是什么格式？<br>当然，既然和前端协定好了协议的格式了，那么params肯定也是需要协定好的，可以用KV格式，也可以用一串Json字符串表示，为了解析方便，还是建议使用<code>Json格式</code><br>而<code>port</code>是用来干嘛的呢？</p>
<blockquote>
<p><code>port</code>我们并不会直接操作它，它是由Js代码自动生成的，port的作用是为了标识Js中的回调<code>function</code>,当Js调用Native方法时，我们会得到本次调用的<code>port</code>号，我们需要在Native方法执行完毕后再把该<code>port</code>、执行的后结果、是否调用成功、调用失败的msg等信息通过调用Js的<code>onComplete</code>方法传入，这时候Js凭什么知道你本次返回的信息是哪次调用的结果呢？就是通过<code>port</code>号，因为在Js调用Native方法时我们会把自动生成的<code>port</code>号和此次回调的<code>function</code>绑定在一起，这样以来Native方法返回结果时把<code>port</code>也带过来，就知道是哪次回调该用哪个<code>function</code>方法来处理</p>
</blockquote>
<p>自动生成<code>port</code>和绑定<code>function回调</code>的Js代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">generatePort: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Math</span>.floor(<span class="type">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">50</span>)) + '' + increase++;</span><br><span class="line">&#125;,</span><br><span class="line">//调用<span class="type">Native</span>方法</span><br><span class="line">callMethod: function (clazz, <span class="keyword">method</span>, param, callback) &#123;</span><br><span class="line">    <span class="keyword">var</span> port = <span class="type">PrivateMethod</span>.generatePort();</span><br><span class="line">    <span class="keyword">if</span> (typeof callback !== 'function') &#123;</span><br><span class="line">        callback = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定对应port的function回调函数</span><br><span class="line">    <span class="type">PrivateMethod</span>.registerCallback(port, callback);</span><br><span class="line">    <span class="type">PrivateMethod</span>.callNativeMethod(clazz, port, <span class="keyword">method</span>, param);</span><br><span class="line">&#125;,</span><br><span class="line">onComplete: function (port, <span class="literal">result</span>) &#123;</span><br><span class="line">    //把<span class="type">Native</span>返回的<span class="type">Json</span>字符串转为<span class="type">JSONObject</span></span><br><span class="line">    <span class="keyword">var</span> resultJson = <span class="type">PrivateMethod</span>.str2Json(<span class="literal">result</span>);</span><br><span class="line">    //获取对应port的function回调函数</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="type">PrivateMethod</span>.getCallback(port).callback;</span><br><span class="line">    <span class="type">PrivateMethod</span>.unRegisterCallback(port);</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        //执行回调</span><br><span class="line">        callback &amp;&amp; callback(resultJson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Js代码上已经注释的很清楚了，就不多解释了。</p>
<p>经过上面介绍，那么在Native方法执行完成后，当然就需要把结果返回给Js了，那么结果的格式又是什么呢？返回给Js方法又是什么呢？<br>没错，还是需要和前端进行协定，建议数据的返回格式为Json字符串，基本格式为：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resultData = &#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">        code: <span class="number">0</span>,<span class="comment">//0:成功，1:失败</span></span><br><span class="line">        msg: <span class="string">'请求超时'</span><span class="comment">//失败时候的提示，成功可为空</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">data</span>: &#123;&#125;<span class="comment">//数据，无数据可以为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中定义了一个<code>status</code>，这样的好处是无论在Native方法调用成功与否、Native方法是否有返回值，Js中都可以收到返回的信息，而这个Json字符串至少都会包含一个<code>status</code>Json对象来描述Native方法调用的状况</p>
<p>而返回给Js的方法自然是上面的<code>onComplete</code>方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">javascript</span><span class="pseudo">:RainbowBridge</span><span class="class">.onComplete</span>(<span class="tag">port</span>,<span class="tag">resultData</span>);</span><br></pre></td></tr></table></figure>
<p>ps:RainbowBridge是我的JsBridge框架的名字</p>
<hr>
<p>至此Js调用Native的流程就分析完成了，一切都看起来那么美妙，因为，我们自己实现一套<code>Js Invoke Native</code>的主要目的是让Js调用Native更加安全，同时也只维护一套<code>JsBridge</code>框架更加方便，那么这个安全性表现在哪里了？<br>我们知道之前原生的方式漏洞就是恶意Js代码可能会调用Native中的其它方法，那么答案出来了，如果需要让<code>Js Invoke Native</code>保证安全性，只需要限制我们通过反射可调用的方法，所以，在JsBridge框架中，我们需要对Js能调用的Native方法给予一定的规则，只有符合这些规则Js才能调用，而我的规则是：</p>
<blockquote>
<p><strong>1、</strong>Native方法包含public static void 这些修饰符（当然还可能有其它的，如：synchronized）<br><strong>2、</strong>Native方法的参数数量和类型只能有这三个：WebView、JSONObject、JsCallback。为什么要传入这三个参数呢？<br><strong>2.1、</strong>第一个参数是为了提供一个WebView对象，以便获取对应Context和执行WebView的一些方法<br><strong>2.2、</strong>第二个参数就是Js中传入过来的参数，这个肯定要的<br><strong>2.3、</strong>第三个参数就是当Native方法执行完毕后，把执行后的结果回调给Js对应的方法中</p>
</blockquote>
<p>所以符合Js调用的Native方法格式为：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> ***(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">	//get some info ...</span><br><span class="line">	<span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断Js调用的方法是否符合该格式的代码为，符合则存入一个Map中供Js调用：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> putMethod(<span class="type">Class</span>&lt;?&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz == null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ArrayMap</span>&lt;<span class="type">String</span>, <span class="type">Method</span>&gt; arrayMap = new <span class="type">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span>;</span><br><span class="line">    <span class="type">Method</span>[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="type">int</span> length = methods.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">method</span> = methods[i];</span><br><span class="line">        <span class="type">int</span> methodModifiers = <span class="keyword">method</span>.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> ((methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">PUBLIC</span>) != <span class="number">0</span> &amp;&amp; (methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">STATIC</span>) != <span class="number">0</span> &amp;&amp; <span class="keyword">method</span>.getReturnType() == <span class="type">void</span>.class) &#123;</span><br><span class="line">            <span class="type">Class</span>&lt;?&gt;[] parameterTypes = <span class="keyword">method</span>.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes != null &amp;&amp; parameterTypes.length == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">WebView</span>.class == parameterTypes[<span class="number">0</span>] &amp;&amp; <span class="type">JSONObject</span>.class == parameterTypes[<span class="number">1</span>] &amp;&amp; <span class="type">JsCallback</span>.class == parameterTypes[<span class="number">2</span>]) &#123;</span><br><span class="line">                    arrayMap.put(<span class="keyword">method</span>.getName(), <span class="keyword">method</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mArrayMap.put(clazz.getSimpleName(), arrayMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于有返回值的方法，并不需要设置它的返回值，因为方法的结果最后我们是通过<code>JsCallback.invokeJsCallback</code>来进行对Js层的回调，比如我贴一个符合该格式的Native方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> getOsSdk(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="literal">result</span> = new <span class="type">JSONObject</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="literal">result</span>.put(<span class="string">"os_sdk"</span>, <span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span>);</span><br><span class="line">    &#125; catch (<span class="type">JSONException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Js调Native代码执行耗时操作情况处理"><a href="#Js调Native代码执行耗时操作情况处理" class="headerlink" title="Js调Native代码执行耗时操作情况处理"></a><strong>Js调Native代码执行耗时操作情况处理</strong></h4><p>一般情况下，比如我们通过Js调用Native方法来获取AppName、OsSDK版本、IMSI号、用户信息等都不会有问题，但是，假如该Native方法需要执行一些耗时操作，如：IO、sp、Bitmap Decode、SQLite等，这时为了保护UI的流畅性，我们需要让这些操作执行在异步线程中，待执行完毕再把结果回调给Js，而我们可以提供一个线程池来专门处理这些耗时操作，如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> doAsync(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, final <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">AsyncTaskExecutor</span>.runOnAsyncThread(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">        @<span class="type">Override</span></span><br><span class="line">        public <span class="type">void</span> run() &#123;</span><br><span class="line">            //<span class="type">IO</span>、sp、<span class="type">Bitmap</span> <span class="type">Decode</span>、<span class="type">SQLite</span></span><br><span class="line">            <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>【注】：对于WebView，它的方法的调用只能在主线程中调用，当设计到WebView的方法调用时，切记不可以放在异步线程中调用，否则就GG了.</strong></p>
<h4 id="Js调Native流程图"><a href="#Js调Native流程图" class="headerlink" title="Js调Native流程图"></a><strong>Js调Native流程图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/jsbridge.png" alt="JsInvokeNative"></p>
<h4 id="JsBridge效果图"><a href="#JsBridge效果图" class="headerlink" title="JsBridge效果图"></a><strong>JsBridge效果图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/js.gif" alt="RainbowBridge"><br>RainbowBridge:<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">github地址</a></p>
<h3 id="白名单Check"><a href="#白名单Check" class="headerlink" title="白名单Check"></a><strong>白名单Check</strong></h3><p>上面我们介绍了JsBridge的基本原理，实现了Js与Native相互调用，而且还避免了恶意Js代码调用Native方法的安全问题，通过这样我们保证了Js调用Native方法的安全性，即Js不能随意调用任意Native方法，不过，对于WebView容器来说，它并不关心所加载的url是Js代码还是网页地址，它所做的工作就是执行我们传入的url，而WebView加载url的方式有两种：get和post，方式如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl<span class="comment">(url)</span>;<span class="comment">//get</span></span><br><span class="line">mWebView.postUrl<span class="comment">(url,data)</span>;<span class="comment">//post</span></span><br></pre></td></tr></table></figure>
<p>对于这两种方式，也有不同的应用点，一般get方式用于查，也就是传入的数据不那么重要，比如：商品列表页、商品详情页等，这些传入的数据只是一些商品类的信息。而post方式一般用于改，post传入的数据往往是比较私密的，比如：订单界面、购物车界面等，这些界面只有在把用户的信息post给服务器后，服务器才能正确的返回相应的信息显示在界面上。所以，对于post方式涉及到用户的私密信息，我们总不能给一个url就把私密数据往这个url里面发吧，当然不可能的，这涉及到安全问题，那么就需要一个白名单机制来检查url是否是我们自己的，是我们自己的那么即可以post数据，不是我们自己的那就不post数据，而白名单的定义通常可以以我们自己的域名来判断，搞一个正则表达式，所以我们可以重写WebView的<code>postUrl</code>方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就对不是我们自己的url进行了拦截，不把数据发送到不是我们自己的服务器中</p>
<p>至此，白名单的Check还没有完成，因为这只是对WebView加载Url时候做的检查，而在WebView内各中链接的跳转、其中有些url还可能被运营商劫持注入了广告，这就有可能在WebView容器内的跳转到某些界面后，该界面的url并不是我们自己的，但是它里面有Js代码调用Native方法来获取一些数据，虽然说Js并不能随便调我们的Native方法，但是有些我们指定可以被调用的Native方法可能有一些获取设备信息、读取文件、获取用户信息等方法，所以，我们也应该在Js调用Native方法时做一层白名单Check，这样才能保证我们的信息安全</p>
<p>所以，白名单检测需要在两个地方进行检测：</p>
<blockquote>
<p>1、WebView:postUrl()前检测url的合法性<br>2、Js调用Native方法前检测当前界面url的合法性</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * <span class="doctag">@param</span> webView WebView</span><br><span class="line"> * <span class="doctag">@param</span> message rainbow://class:port/method?params</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(WebView webView, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span> || TextUtils.isEmpty(message))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(webView.getUrl())) &#123;</span><br><span class="line">        parseMessage(message);</span><br><span class="line">        invokeNativeMethod(webView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除默认内置接口"><a href="#移除默认内置接口" class="headerlink" title="移除默认内置接口"></a><strong>移除默认内置接口</strong></h3><p>WebView内置默认也注入了一些接口，如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除默认内置接口,防止远程代码执行漏洞攻击</span></span><br><span class="line"><span class="keyword">if</span> (Build.<span class="keyword">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"searchBoxJavaBridge_"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibility"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibilityTraversal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些接口虽然不会影响用prompt方式实现的Js与Native交互，但是在使用addJavascriptInterface方式时，有可能有安全问题，最好移除</p>
<h2 id="WebView相关"><a href="#WebView相关" class="headerlink" title="WebView相关"></a><strong>WebView相关</strong></h2><h3 id="WebView的配置"><a href="#WebView的配置" class="headerlink" title="WebView的配置"></a><strong>WebView的配置</strong></h3><p>下面给出WebView的通用配置：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line">webSettings.setSupportZoom(<span class="literal">false</span>);</span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">false</span>);</span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDatabaseEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setGeolocationEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCachePath(getApplicationContext().getCacheDir().getPath());</span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">"UTF-8"</span>);</span><br><span class="line">//屏幕自适应</span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>);</span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    webSettings.setDisplayZoomControls(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mWebView.setScrollBarStyle(WDWebView.SCROLLBARS_INSIDE_OVERLAY);</span><br><span class="line">mWebView.setHorizontalScrollBarEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setHorizontalFadingEdgeEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setVerticalFadingEdgeEnabled(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>其中有一项配置，是在4.4以上版本时设置网页内图片可以自动加载，而4.4以下版本则不可自动加载，原因是4.4WebView内核的改变，使得WebView的性能更优，所以在4.4以下版本不让图片自动加载，而是先让WebView加载网页的其它静态资源：js、css、文本等等，待网页把这些静态资源加载完成后，在<code>onPageFinished</code>方法中再把图片自动加载打开让网页加载图片：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">    <span class="keyword">if</span> (!mWebView.getSettings().getLoadsImagesAutomatically()) &#123;</span><br><span class="line">        mWebView.getSettings().setLoadsImagesAutomatically(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebView的独立进程"><a href="#WebView的独立进程" class="headerlink" title="WebView的独立进程"></a><strong>WebView的独立进程</strong></h3><p>通常来说，WebView的使用会带来诸多问题，内存泄露就是最常见的问题，为了避免WebView内存泄露，目前最流行的有两种做法：</p>
<blockquote>
<p>1、独立进程，简单暴力，不过可能涉及到进程间通信<br>2、动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉</p>
</blockquote>
<p>个人推荐独立进程，好处主要有两点，一是在WebViewActivity使用完毕后直接干掉该进程，防止了内存泄露，二是为我们的app主进程减少了额外的内存占用量</p>
<p>使用独立进程还需注意一点，这个进程中在有多个WebViewActivity，不能在Activity销毁时就干掉进程，不然其它Activity也会蹦了，此时应该在该进程创建一个Activity的维护集合，集合为空时即可干掉进程</p>
<p>关于WebView的销毁，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">destroyWebView</span><span class="params">(WebView webView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    webView.stopLoading();</span><br><span class="line">    ViewParent viewParent = webView.getParent();</span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup)</span><br><span class="line">        ((ViewGroup) viewParent).removeView(webView);</span><br><span class="line">    webView.removeAllViews();</span><br><span class="line">    webView.destroy();</span><br><span class="line">    webView = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebView的兼容性"><a href="#WebView的兼容性" class="headerlink" title="WebView的兼容性"></a><strong>WebView的兼容性</strong></h3><h4 id="不同版本硬件加速的问题"><a href="#不同版本硬件加速的问题" class="headerlink" title="不同版本硬件加速的问题"></a><strong>不同版本硬件加速的问题</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 &amp;&amp; shouldOpenHardware()) &#123;</span><br><span class="line">    mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOpenHardware</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(Build.BRAND))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同设备点击WebView输入框键盘的不弹起"><a href="#不同设备点击WebView输入框键盘的不弹起" class="headerlink" title="不同设备点击WebView输入框键盘的不弹起"></a><strong>不同设备点击WebView输入框键盘的不弹起</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWebView != <span class="keyword">null</span>)</span><br><span class="line">                mWebView.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"><a href="#三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况" class="headerlink" title="三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"></a><strong>三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况</strong></h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">brand </span>= <span class="keyword">android.os.Build.BRAND;</span><br><span class="line"></span><span class="label">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(<span class="keyword">brand) </span>&amp;&amp; <span class="keyword">Build.VERSION.SDK_INT </span>&gt;= <span class="keyword">Build.VERSION_CODES.LOLLIPOP) </span>&#123;</span><br><span class="line">    getWindow().setFlags(</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同版本shouldOverrideUrlLoading的回调时机"><a href="#不同版本shouldOverrideUrlLoading的回调时机" class="headerlink" title="不同版本shouldOverrideUrlLoading的回调时机"></a><strong>不同版本shouldOverrideUrlLoading的回调时机</strong></h4><p>对于<code>shouldOverrideUrlLoading</code>的加载时机，有些同学经常与<code>onProgressChanged</code>这个方法的加载时机混淆，这两个方法有两点不同：</p>
<blockquote>
<p>1、<code>shouldOverrideUrlLoading</code>只会走Get方式的请求，Post方式的请求将不会回调这个方法，而<code>onProgressChanged</code>对Get和Post都会走<br>2、<code>shouldOverrideUrlLoading</code>都知道在WebView内部点击链接（Get）会触发，它在Get请求打开界面时也会触发，<code>shouldOverrideUrlLoading</code>还有一点特殊，就是在按返回键返回到上一个页面时时不会触发的，而<code>onProgressChanged</code>在只要界面更新了都会触发</p>
</blockquote>
<p>对于<code>shouldOverrideUrlLoading</code>的返回值，返回true为剥夺WebView对该此请求的控制权，交给应用自己处理，所以WebView也不会加载该url了，返回false为WebView自己处理</p>
<p>对于<code>shouldOverrideUrlLoading</code>的调用时机，也会有不同，在3.0以上是会正常调用的，而在3.0以下，并不是每次都会调用，可以在<code>onPageStarted</code>方法中做处理，也没必要了，现在应该都适配4.0以上了</p>
<h4 id="页面重定向导致WebView-goBack-无效的处理"><a href="#页面重定向导致WebView-goBack-无效的处理" class="headerlink" title="页面重定向导致WebView:goBack()无效的处理"></a><strong>页面重定向导致WebView:goBack()无效的处理</strong></h4><p>像一些界面有重定向，比如：淘宝等，需要按多次（&gt;1）才能正常返回，一般都是二次，所以可以把那些具有重定向的界面存入一个集合中，在拦截返回事件中这样处理：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> onBackPressed() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    WebBackForwardList backForwardList = mWebView.copyBackForwardList();</span><br><span class="line">    <span class="keyword">if</span> (backForwardList != <span class="keyword">null</span> &amp;&amp; backForwardList.getSize() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> currentIndex = backForwardList.getCurrentIndex();</span><br><span class="line">        WebHistoryItem historyItem = backForwardList.getItemAtIndex(currentIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (historyItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">String</span> backPageUrl = historyItem.getUrl();</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(backPageUrl))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">size</span> = REDIRECT_URL.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (backPageUrl.contains(REDIRECT_URL.<span class="built_in">get</span>(i)))</span><br><span class="line">                    mWebView.goBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mWebView.canGoBack()) &#123;</span><br><span class="line">        mWebView.goBack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里处理是在按返回键时，如果上一个界面是重定向界面，则直接调用goBack，或者也可以finish当前Activity</p>
<h4 id="WebView无法加载不信任网页SSL错误的处理"><a href="#WebView无法加载不信任网页SSL错误的处理" class="headerlink" title="WebView无法加载不信任网页SSL错误的处理"></a><strong>WebView无法加载不信任网页SSL错误的处理</strong></h4><p>有时我们的WebView会加载一些不信任的网页，这时候默认的处理是WebView停止加载了，而那些不信任的网页都不是由CA机构信任的，这时候你可以选择继续加载或者让手机内的浏览器来加载：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, <span class="keyword">final</span> SslErrorHandler <span class="keyword">handler</span>, SslError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续加载</span></span><br><span class="line">    <span class="keyword">handler</span>.<span class="keyword">proceed</span>();</span><br><span class="line">    <span class="comment">//或者其它处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义WebView加载出错界面"><a href="#自定义WebView加载出错界面" class="headerlink" title="自定义WebView加载出错界面"></a><strong>自定义WebView加载出错界面</strong></h4><p>出错的界面的显示，可以在这个方法中控制：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以重新加载一段Html专门用来显示错误界面，或者用布局显示一个出错的View，这时候需要把出错的WebView内容清除，可以使用：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">    view.loadDataWithBaseURL(<span class="keyword">null</span>,<span class="string">""</span>,<span class="string">"text/html"</span>,<span class="string">"UTF-8"</span>,<span class="keyword">null</span>);</span><br><span class="line">    errorView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取位置权限的处理"><a href="#获取位置权限的处理" class="headerlink" title="获取位置权限的处理"></a><strong>获取位置权限的处理</strong></h4><p>如果在WebView中有获取地理位置的请求，那么可以直接在代码中默认处理了，没必要弹出一个框框让用户每次都确认：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(String origin, GeolocationPermissions.Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onGeolocationPermissionsShowPrompt(origin, callback);</span><br><span class="line">    callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打造一个通用的WebViewActivity界面"><a href="#打造一个通用的WebViewActivity界面" class="headerlink" title="打造一个通用的WebViewActivity界面"></a><strong>打造一个通用的WebViewActivity界面</strong></h3><p>一个通用的WebViewActivity当然是样式和WebView内部处理的策略都统一样，这里只对样式进行说明，因为WebView内部的处理各个公司都不一样，但应该都需要包含这么几点吧：</p>
<blockquote>
<p>1、白名单检测<br>2、Url的跳转<br>3、出错的处理<br>4、…</p>
</blockquote>
<p>一个WebViewActivity界面，最主要的就是Toolbar标题栏的设计了，因为不同的app的WebViewActivity界面Toolbar上有不同的icon和操作，比如：分享按钮、刷新按钮、更多按钮，都不一样，既然需要通用，即可让调用者传入某个参数来动态改变这些东西吧，比如传一个ToolbarStyle来标识此WebViewActivity的风格是什么样的，背景色、字体颜色、图标等，包括点击时的动画效果，作为通用的界面，必须是让调用者简单操作，不可能调用时传入一个图标id还是一个Drawable，所以，主要需要用到tint，来对字体、图标的颜色动态改变，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorStateList <span class="title">createColorStateList</span><span class="params">(<span class="keyword">int</span> normal, <span class="keyword">int</span> pressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;normal, pressed&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-android.R.attr.state_pressed&#125;;</span><br><span class="line">    states[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_pressed&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorStateList(states, colors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">tintDrawable</span><span class="params">(Drawable drawable, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    final Drawable tintDrawable = DrawableCompat.wrap(drawable.mutate());</span><br><span class="line">    ColorStateList colorStateList = ColorStateList.valueOf(color);</span><br><span class="line">    DrawableCompat.setTintMode(tintDrawable, PorterDuff.Mode.SRC_IN);</span><br><span class="line">    DrawableCompat.setTintList(tintDrawable, colorStateList);</span><br><span class="line">    <span class="keyword">return</span> tintDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H5与Native界面互相唤起"><a href="#H5与Native界面互相唤起" class="headerlink" title="H5与Native界面互相唤起"></a><strong>H5与Native界面互相唤起</strong></h2><p>对于H5界面，有些操作往往是需要唤起Native界面的，比如：H5中的登录按钮，点击后往往唤起Native的登录界面来进行登录，而不是直接在H5登录，这样一个app就只需要一套登录了，而我们所做的便是拦截登录按钮的url：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    parserURL(url); <span class="comment">//解析url,如果符合跳转native界面的url规则，则跳转native界面</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">shouldOverrideUrlLoading</span><span class="params">(view, url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规则我们可以在Native的Activity的<code>intent-filter</code>中的<code>data</code>来定义，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".LoginActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">            <span class="attribute">android:host</span>=<span class="value">"native"</span></span><br><span class="line">            <span class="attribute">android:path</span>=<span class="value">"/login"</span></span><br><span class="line">            <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解析url过程是判断scheme、host、path的是否有完全与之匹配的，有则唤起</p>
<p>而Native唤H5，其实也是一个url的解析过程，只不过需要配置WebViewActivity的<code>intent-filter</code>的<code>data</code>，WebViewActivity的scheme配置为http和https</p>
<h3 id="startActivity-VS-UrlRouter"><a href="#startActivity-VS-UrlRouter" class="headerlink" title="startActivity VS UrlRouter"></a><strong>startActivity VS UrlRouter</strong></h3><p>上面说到了H5与Native互相调起，其实这个可以在app内做成一套界面跳转的方式，摒弃startActivity，为什么原生的跳转方式不佳？</p>
<blockquote>
<p>1、因为原生的跳转需要确定该Activity是已经存在的，否则编译将报错，这样带来的问题是不利于协同开发，如：A、B同学分别正在开发项目的两个不同的模块，此时B刚好需要跳A同学的某一个界面，如商品列表页跳商品详情页，这时候B就必须写个TODO，待B完成该模块后再写了。而通过url跳转，只需要传入一串url即可<br>2、原生的跳转Activity与目标Activity是耦合的，跳转Activity完全依赖于目标Activity<br>3、原生的跳转方式不利于管理所传递来的参数，获取参数时需要在跳转Activity的地方确定传递了几个参数、什么类型的参数，这样以来跳转的方式多了，就比较混乱了。当然一个原生跳转良好的设计是在目的Activity实现一个静态的start方法，其它界面要跳直接调用即可<br>4、最后一个就是在有参数传递的情况下，每次跳转都要写好多代码啊</p>
</blockquote>
<p>而UrlRouter框架的实现原理，一种实现是可以维护一套Activity与url的映射表，这种方式还是没有摆脱不利于协同开发这个毛病，另外一种是通过一串指定规则的url与manifest中配置的data匹配，具体跳转则是通过<code>intent.setData()</code>来设置跳转的url，这种方式比较好，不过需要处理下匹配到多个Activity时优先选择的问题</p>
<p><strong>JsBridge地址</strong>：<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">RainbowBridge</a></p>
<hr>
<p><strong>—转载请注明出处</strong></p>
]]></content:encoded>
      
      <comments>http://zhengxiaoyong.com/2016/04/20/Native%E4%B8%8EH5%E4%BA%A4%E4%BA%92%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
