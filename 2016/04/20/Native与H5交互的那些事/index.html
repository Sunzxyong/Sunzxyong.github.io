<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Native与H5交互的那些事 | zhengxiaoyong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页">
<meta property="og:type" content="article">
<meta property="og:title" content="Native与H5交互的那些事">
<meta property="og:url" content="http://zhengxiaoyong.me/2016/04/20/Native与H5交互的那些事/index.html">
<meta property="og:site_name" content="zhengxiaoyong">
<meta property="og:description" content="前言Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页">
<meta property="og:image" content="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/jsbridge.png">
<meta property="og:image" content="http://7xswxf.com2.z0.glb.clouddn.com/blog/js.gif">
<meta property="og:updated_time" content="2016-04-22T07:13:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Native与H5交互的那些事">
<meta name="twitter:description" content="前言Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页">
  
    <link rel="alternative" href="/atom.xml" title="zhengxiaoyong" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xswxf.com2.z0.glb.qiniucdn.com/image/icon.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">郑晓勇</a></h1>
		</hgroup>

		
		<p class="header-subtitle">The best always comes last</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/categories/性能优化">性能优化</a></li>
				        
							<li><a href="/categories/技术沉淀">技术沉淀</a></li>
				        
							<li><a href="/categories/Exchange">Exchange</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Sunzxyong" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/p/1005053048730677/home?from=page_100505&mod=TAB#place" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="/1175151739@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Exchange/" style="font-size: 10px;">Exchange</a> <a href="/tags/Fresco原理/" style="font-size: 10px;">Fresco原理</a> <a href="/tags/JsBridge/" style="font-size: 10px;">JsBridge</a> <a href="/tags/Splash页/" style="font-size: 10px;">Splash页</a> <a href="/tags/UrlRouter/" style="font-size: 10px;">UrlRouter</a> <a href="/tags/WebView/" style="font-size: 10px;">WebView</a> <a href="/tags/WebView安全/" style="font-size: 10px;">WebView安全</a> <a href="/tags/兼容性/" style="font-size: 10px;">兼容性</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/内存泄露/" style="font-size: 10px;">内存泄露</a> <a href="/tags/启动速度/" style="font-size: 10px;">启动速度</a> <a href="/tags/异步任务/" style="font-size: 10px;">异步任务</a> <a href="/tags/性能优化点/" style="font-size: 10px;">性能优化点</a> <a href="/tags/消费者/" style="font-size: 10px;">消费者</a> <a href="/tags/生产者/" style="font-size: 10px;">生产者</a> <a href="/tags/线程池/" style="font-size: 10px;">线程池</a> <a href="/tags/订阅者/" style="font-size: 10px;">订阅者</a> <a href="/tags/路由框架/" style="font-size: 10px;">路由框架</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/u010687392">我的CSDN的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">2016届毕业的应届小伙伴，喜欢Android、喜欢探索新技术、喜欢性能优化、喜欢代码的整洁、喜欢...目前就职于微店。微信：zxy1175151739</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">郑晓勇</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xswxf.com2.z0.glb.qiniucdn.com/image/icon.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">郑晓勇</h1>
			</hgroup>
			
			<p class="header-subtitle">The best always comes last</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/categories/性能优化">性能优化</a></li>
		        
					<li><a href="/categories/技术沉淀">技术沉淀</a></li>
		        
					<li><a href="/categories/Exchange">Exchange</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Sunzxyong" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/p/1005053048730677/home?from=page_100505&mod=TAB#place" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="/1175151739@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Native与H5交互的那些事" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/20/Native与H5交互的那些事/" class="article-date">
  	<time datetime="2016-04-20T04:55:28.000Z" itemprop="datePublished">2016-04-20</time>
</a>
	&nbsp;&nbsp;<div><span id="busuanzi_container_page_pv" style="font-size:12px">
  	阅读量:<span id="busuanzi_value_page_pv" style="font-size:13px"></span></span></div>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Native与H5交互的那些事
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JsBridge/">JsBridge</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebView/">WebView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebView安全/">WebView安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/兼容性/">兼容性</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术沉淀/">技术沉淀</a>
	</div>


        <div class="clearfix"></div>

      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Hybrid开发模式目前几乎每家公司都有涉及和使用，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势，而这种模式，在Android中必然需要WebView作为载体来展示H5内容和进行交互，而WebView的各种安全性、兼容性的问题，我想大多数人与它友谊的小床已经翻了，特别是4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span><br><span class="line">            alert(obj);</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">window</span>[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line">                 .getMethod(<span class="string">"getRuntime"</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免这个漏洞，即需要限制Js代码能够调用到的Native方法，官方于是在从4.2开始的版本可以通过为可以被Js调用的方法添加<code>@JavascriptInterface</code>注解来解决，而之前的版本虽然不能通过这种方法解决，但是可以使用Js的<code>prompt</code>方法进行解决，只不过<code>需要和前端协商好一套公共的协议</code>，除此之外，为了避免WebView加载任意url，也需要对url进行白名单检测，由于Android碎片化太严重，WebView也存在兼容性问题，WebView的内核也在4.4版本进行了改变，由webkit改为chromium，此外WebView还有一个非常明显的问题，就是内存泄露，根本原因就是Activity与WebView关联后，WebView内部的一些操作的执行在新线程中，这些时间无法确定，而可能导致WebView一直持有Activity的引用，不能回收。下面就谈谈怎样正确安全的让Native与H5交互<br><a id="more"></a></p>
<h2 id="1-Native与H5怎样安全的进行交互？"><a href="#1-Native与H5怎样安全的进行交互？" class="headerlink" title="1. Native与H5怎样安全的进行交互？"></a><strong>1. Native与H5怎样安全的进行交互？</strong></h2><p>要使得H5内的Js与Native之间安全的相互进行调用，我们除了可以通过添加<code>@JavascriptInterface</code>注解来解决（&gt;=4.2），还有通过<code>prompt</code>的方式，不过如果使用官方的方式，这就需要对4.2以下做兼容了，这样使得我们一个app中有两套Js与Native交互的方式，这样极其不好维护，我们应该只需要一套Js与Native交互的方式，所以，我们借助Js中的<code>prompt</code>方法来实现<code>一套安全的Js与Native交互的JsBridge框架</code></p>
<h3 id="1-1-Js与Native代码相互调用"><a href="#1-1-Js与Native代码相互调用" class="headerlink" title="1.1 Js与Native代码相互调用"></a><strong>1.1 Js与Native代码相互调用</strong></h3><p><strong>Native Invoke Js:</strong><br>我们知道如果Native需要调用Js中的方法，只需要使用<code>WebView:loadUrl();</code>方法即可直接调用指定Js代码，如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView<span class="class">.loadUrl</span>("javascript<span class="value">:<span class="function">setUserName</span>(<span class="string">'zhengxiaoyong'</span>);</span>");</span><br></pre></td></tr></table></figure>
<p>这样就直接调用了Js中的<code>setUserName</code>方法并把<code>zhengxiaoyong</code>这个名字传到这个方法中去了，接下来就是Js自己处理了</p>
<p><strong>Js Invoke Native:</strong><br>而如果Js要调用Native中的Java方法呢？这就需要我们自己实现了，因为我们不采取<code>JavascriptInterface</code>的方式，而采取prompt方式<br>对WebView熟悉的同学们应该都知道Js中对应的<code>window.alert()</code>、<code>window.confirm()</code>、<code>window.prompt()</code>这三个方法的调用在<code>WebChromeClient</code>中都有对应的回调方法，分别为：<br><code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt()</code>，对于它们传入的<code>message</code>，都可以在相应的回调方法中接收到，所以，对于Js调Native方法，我们可以借助这个信道，和前端协定好一段特定规则的<code>message</code>，这个规则中应至少包含这些信息：</p>
<blockquote>
<p>所调用Native方法所在类的类名<br>所调用Native的方法名<br>Js调用Native方法所传入的参数</p>
</blockquote>
<p>所以基于这些信息，很容易想到使用http协议的格式来协定规则，如下格式：</p>
<blockquote>
<p><strong>scheme://host:port/path?query</strong><br>对应的我们协定<code>prompt</code>传入<code>message</code>的格式为:<br><strong>jsbridge://class:port/method?params</strong></p>
</blockquote>
<p>这样以来，前端和app端协商好后，以后前端需要通过Js调用Native方法来获取一些信息或功能，就只需要按照协议的格式把需要调用的类名、方法名、参数放入对应得位置即可，而我们会在<code>onJsPrompt</code>方法中接受到，所以我们根据与前端协定好的协议来进行解析，我们可以用一个<code>Uri</code>来包装这段协议，然后通过<code>Uri:getHost、getPath、getQuery</code>方法获取对应的类名，方法名，参数数据，最后通过反射来调用指定类中指定的方法</p>
<p>而此时会有人问？<code>port</code>是用来干嘛的？params格式是KV还是什么格式？<br>当然，既然和前端协定好了协议的格式了，那么params肯定也是需要协定好的，可以用KV格式，也可以用一串Json字符串表示，为了解析方便，还是建议使用<code>Json格式</code><br>而<code>port</code>是用来干嘛的呢？</p>
<blockquote>
<p><code>port</code>我们并不会直接操作它，它是由Js代码自动生成的，port的作用是为了标识Js中的回调<code>function</code>,当Js调用Native方法时，我们会得到本次调用的<code>port</code>号，我们需要在Native方法执行完毕后再把该<code>port</code>、执行的后结果、是否调用成功、调用失败的msg等信息通过调用Js的<code>onComplete</code>方法传入，这时候Js凭什么知道你本次返回的信息是哪次调用的结果呢？就是通过<code>port</code>号，因为在Js调用Native方法时我们会把自动生成的<code>port</code>号和此次回调的<code>function</code>绑定在一起，这样以来Native方法返回结果时把<code>port</code>也带过来，就知道是哪次回调该用哪个<code>function</code>方法来处理</p>
</blockquote>
<p>自动生成<code>port</code>和绑定<code>function回调</code>的Js代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">generatePort: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Math</span>.floor(<span class="type">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">50</span>)) + '' + increase++;</span><br><span class="line">&#125;,</span><br><span class="line">//调用<span class="type">Native</span>方法</span><br><span class="line">callMethod: function (clazz, <span class="keyword">method</span>, param, callback) &#123;</span><br><span class="line">    <span class="keyword">var</span> port = <span class="type">PrivateMethod</span>.generatePort();</span><br><span class="line">    <span class="keyword">if</span> (typeof callback !== 'function') &#123;</span><br><span class="line">        callback = null;</span><br><span class="line">    &#125;</span><br><span class="line">    //绑定对应port的function回调函数</span><br><span class="line">    <span class="type">PrivateMethod</span>.registerCallback(port, callback);</span><br><span class="line">    <span class="type">PrivateMethod</span>.callNativeMethod(clazz, port, <span class="keyword">method</span>, param);</span><br><span class="line">&#125;,</span><br><span class="line">onComplete: function (port, <span class="literal">result</span>) &#123;</span><br><span class="line">    //把<span class="type">Native</span>返回的<span class="type">Json</span>字符串转为<span class="type">JSONObject</span></span><br><span class="line">    <span class="keyword">var</span> resultJson = <span class="type">PrivateMethod</span>.str2Json(<span class="literal">result</span>);</span><br><span class="line">    //获取对应port的function回调函数</span><br><span class="line">    <span class="keyword">var</span> callback = <span class="type">PrivateMethod</span>.getCallback(port).callback;</span><br><span class="line">    <span class="type">PrivateMethod</span>.unRegisterCallback(port);</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        //执行回调</span><br><span class="line">        callback &amp;&amp; callback(resultJson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Js代码上已经注释的很清楚了，就不多解释了。</p>
<p>经过上面介绍，那么在Native方法执行完成后，当然就需要把结果返回给Js了，那么结果的格式又是什么呢？返回给Js方法又是什么呢？<br>没错，还是需要和前端进行协定，建议数据的返回格式为Json字符串，基本格式为：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resultData = &#123;</span><br><span class="line">    status: &#123;</span><br><span class="line">        code: <span class="number">0</span>,<span class="comment">//0:成功，1:失败</span></span><br><span class="line">        msg: <span class="string">'请求超时'</span><span class="comment">//失败时候的提示，成功可为空</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">data</span>: &#123;&#125;<span class="comment">//数据，无数据可以为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中定义了一个<code>status</code>，这样的好处是无论在Native方法调用成功与否、Native方法是否有返回值，Js中都可以收到返回的信息，而这个Json字符串至少都会包含一个<code>status</code>Json对象来描述Native方法调用的状况</p>
<p>而返回给Js的方法自然是上面的<code>onComplete</code>方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">javascript</span><span class="pseudo">:RainbowBridge</span><span class="class">.onComplete</span>(<span class="tag">port</span>,<span class="tag">resultData</span>);</span><br></pre></td></tr></table></figure>
<p>ps:RainbowBridge是我的JsBridge框架的名字</p>
<hr>
<p>至此Js调用Native的流程就分析完成了，一切都看起来那么美妙，因为，我们自己实现一套<code>Js Invoke Native</code>的主要目的是让Js调用Native更加安全，同时也只维护一套<code>JsBridge</code>框架更加方便，那么这个安全性表现在哪里了？<br>我们知道之前原生的方式漏洞就是恶意Js代码可能会调用Native中的其它方法，那么答案出来了，如果需要让<code>Js Invoke Native</code>保证安全性，只需要限制我们通过反射可调用的方法，所以，在JsBridge框架中，我们需要对Js能调用的Native方法给予一定的规则，只有符合这些规则Js才能调用，而我的规则是：</p>
<blockquote>
<p><strong>1、</strong>Native方法包含public static void 这些修饰符（当然还可能有其它的，如：synchronized）<br><strong>2、</strong>Native方法的参数数量和类型只能有这三个：WebView、JSONObject、JsCallback。为什么要传入这三个参数呢？<br><strong>2.1、</strong>第一个参数是为了提供一个WebView对象，以便获取对应Context和执行WebView的一些方法<br><strong>2.2、</strong>第二个参数就是Js中传入过来的参数，这个肯定要的<br><strong>2.3、</strong>第三个参数就是当Native方法执行完毕后，把执行后的结果回调给Js对应的方法中</p>
</blockquote>
<p>所以符合Js调用的Native方法格式为：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> ***(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">	//get some info ...</span><br><span class="line">	<span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断Js调用的方法是否符合该格式的代码为，符合则存入一个Map中供Js调用：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> putMethod(<span class="type">Class</span>&lt;?&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz == null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">ArrayMap</span>&lt;<span class="type">String</span>, <span class="type">Method</span>&gt; arrayMap = new <span class="type">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span>;</span><br><span class="line">    <span class="type">Method</span>[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="type">int</span> length = methods.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">method</span> = methods[i];</span><br><span class="line">        <span class="type">int</span> methodModifiers = <span class="keyword">method</span>.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> ((methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">PUBLIC</span>) != <span class="number">0</span> &amp;&amp; (methodModifiers &amp; <span class="type">Modifier</span>.<span class="type">STATIC</span>) != <span class="number">0</span> &amp;&amp; <span class="keyword">method</span>.getReturnType() == <span class="type">void</span>.class) &#123;</span><br><span class="line">            <span class="type">Class</span>&lt;?&gt;[] parameterTypes = <span class="keyword">method</span>.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes != null &amp;&amp; parameterTypes.length == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">WebView</span>.class == parameterTypes[<span class="number">0</span>] &amp;&amp; <span class="type">JSONObject</span>.class == parameterTypes[<span class="number">1</span>] &amp;&amp; <span class="type">JsCallback</span>.class == parameterTypes[<span class="number">2</span>]) &#123;</span><br><span class="line">                    arrayMap.put(<span class="keyword">method</span>.getName(), <span class="keyword">method</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mArrayMap.put(clazz.getSimpleName(), arrayMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于有返回值的方法，并不需要设置它的返回值，因为方法的结果最后我们是通过<code>JsCallback.invokeJsCallback</code>来进行对Js层的回调，比如我贴一个符合该格式的Native方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> getOsSdk(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="literal">result</span> = new <span class="type">JSONObject</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="literal">result</span>.put(<span class="string">"os_sdk"</span>, <span class="type">Build</span>.<span class="type">VERSION</span>.<span class="type">SDK_INT</span>);</span><br><span class="line">    &#125; catch (<span class="type">JSONException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Js调Native代码执行耗时操作情况处理"><a href="#Js调Native代码执行耗时操作情况处理" class="headerlink" title="Js调Native代码执行耗时操作情况处理"></a><strong>Js调Native代码执行耗时操作情况处理</strong></h4><p>一般情况下，比如我们通过Js调用Native方法来获取AppName、OsSDK版本、IMSI号、用户信息等都不会有问题，但是，假如该Native方法需要执行一些耗时操作，如：IO、sp、Bitmap Decode、SQLite等，这时为了保护UI的流畅性，我们需要让这些操作执行在异步线程中，待执行完毕再把结果回调给Js，而我们可以提供一个线程池来专门处理这些耗时操作，如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> doAsync(<span class="type">WebView</span> webView, <span class="type">JSONObject</span> data, final <span class="type">JsCallback</span> callback) &#123;</span><br><span class="line">    <span class="type">AsyncTaskExecutor</span>.runOnAsyncThread(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">        @<span class="type">Override</span></span><br><span class="line">        public <span class="type">void</span> run() &#123;</span><br><span class="line">            //<span class="type">IO</span>、sp、<span class="type">Bitmap</span> <span class="type">Decode</span>、<span class="type">SQLite</span></span><br><span class="line">            <span class="type">JsCallback</span>.invokeJsCallback(callback, <span class="literal">true</span>, <span class="literal">result</span>, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>【注】：对于WebView，它的方法的调用只能在主线程中调用，当设计到WebView的方法调用时，切记不可以放在异步线程中调用，否则就GG了.</strong></p>
<h4 id="Js调Native流程图"><a href="#Js调Native流程图" class="headerlink" title="Js调Native流程图"></a><strong>Js调Native流程图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.qiniucdn.com/blog/jsbridge.png" alt="JsInvokeNative"></p>
<h4 id="JsBridge效果图"><a href="#JsBridge效果图" class="headerlink" title="JsBridge效果图"></a><strong>JsBridge效果图</strong></h4><p><img src="http://7xswxf.com2.z0.glb.clouddn.com/blog/js.gif" alt="RainbowBridge"><br>RainbowBridge:<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">github地址</a></p>
<h3 id="1-2-白名单Check"><a href="#1-2-白名单Check" class="headerlink" title="1.2 白名单Check"></a><strong>1.2 白名单Check</strong></h3><p>上面我们介绍了JsBridge的基本原理，实现了Js与Native相互调用，而且还避免了恶意Js代码调用Native方法的安全问题，通过这样我们保证了Js调用Native方法的安全性，即Js不能随意调用任意Native方法，不过，对于WebView容器来说，它并不关心所加载的url是Js代码还是网页地址，它所做的工作就是执行我们传入的url，而WebView加载url的方式有两种：get和post，方式如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadUrl<span class="comment">(url)</span>;<span class="comment">//get</span></span><br><span class="line">mWebView.postUrl<span class="comment">(url,data)</span>;<span class="comment">//post</span></span><br></pre></td></tr></table></figure>
<p>对于这两种方式，也有不同的应用点，一般get方式用于查，也就是传入的数据不那么重要，比如：商品列表页、商品详情页等，这些传入的数据只是一些商品类的信息。而post方式一般用于改，post传入的数据往往是比较私密的，比如：订单界面、购物车界面等，这些界面只有在把用户的信息post给服务器后，服务器才能正确的返回相应的信息显示在界面上。所以，对于post方式涉及到用户的私密信息，我们总不能给一个url就把私密数据往这个url里面发吧，当然不可能的，这涉及到安全问题，那么就需要一个白名单机制来检查url是否是我们自己的，是我们自己的那么即可以post数据，不是我们自己的那就不post数据，而白名单的定义通常可以以我们自己的域名来判断，搞一个正则表达式，所以我们可以重写WebView的<code>postUrl</code>方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就对不是我们自己的url进行了拦截，不把数据发送到不是我们自己的服务器中</p>
<p>至此，白名单的Check还没有完成，因为这只是对WebView加载Url时候做的检查，而在WebView内各中链接的跳转、其中有些url还可能被运营商劫持注入了广告，这就有可能在WebView容器内的跳转到某些界面后，该界面的url并不是我们自己的，但是它里面有Js代码调用Native方法来获取一些数据，虽然说Js并不能随便调我们的Native方法，但是有些我们指定可以被调用的Native方法可能有一些获取设备信息、读取文件、获取用户信息等方法，所以，我们也应该在Js调用Native方法时做一层白名单Check，这样才能保证我们的信息安全</p>
<p>所以，白名单检测需要在两个地方进行检测：</p>
<blockquote>
<p>1、WebView:postUrl()前检测url的合法性<br>2、Js调用Native方法前检测当前界面url的合法性</p>
</blockquote>
<p>具体代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postUrl</span><span class="params">(String url, <span class="keyword">byte</span>[] postData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(url)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, postData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.postUrl(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * <span class="doctag">@param</span> webView WebView</span><br><span class="line"> * <span class="doctag">@param</span> message rainbow://class:port/method?params</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(WebView webView, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span> || TextUtils.isEmpty(message))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (JsBridgeUrlCheckUtil.isTrustUrl(webView.getUrl())) &#123;</span><br><span class="line">        parseMessage(message);</span><br><span class="line">        invokeNativeMethod(webView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-移除默认内置接口"><a href="#1-3-移除默认内置接口" class="headerlink" title="1.3 移除默认内置接口"></a><strong>1.3 移除默认内置接口</strong></h3><p>WebView内置默认也注入了一些接口，如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除默认内置接口,防止远程代码执行漏洞攻击</span></span><br><span class="line"><span class="keyword">if</span> (Build.<span class="keyword">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"searchBoxJavaBridge_"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibility"</span>);</span><br><span class="line">    mWebView.removeJavascriptInterface(<span class="string">"accessibilityTraversal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些接口虽然不会影响用prompt方式实现的Js与Native交互，但是在使用addJavascriptInterface方式时，有可能有安全问题，最好移除</p>
<h2 id="2-WebView相关"><a href="#2-WebView相关" class="headerlink" title="2. WebView相关"></a><strong>2. WebView相关</strong></h2><h3 id="2-1-WebView的配置"><a href="#2-1-WebView的配置" class="headerlink" title="2.1 WebView的配置"></a><strong>2.1 WebView的配置</strong></h3><p>下面给出WebView的通用配置：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line">webSettings.setSupportZoom(<span class="literal">false</span>);</span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">false</span>);</span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDatabaseEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setGeolocationEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">webSettings.setAppCachePath(getApplicationContext().getCacheDir().getPath());</span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">"UTF-8"</span>);</span><br><span class="line">//屏幕自适应</span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>);</span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    webSettings.setDisplayZoomControls(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Build.<span class="literal">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setLoadsImagesAutomatically(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mWebView.setScrollBarStyle(WDWebView.SCROLLBARS_INSIDE_OVERLAY);</span><br><span class="line">mWebView.setHorizontalScrollBarEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setHorizontalFadingEdgeEnabled(<span class="literal">false</span>);</span><br><span class="line">mWebView.setVerticalFadingEdgeEnabled(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>其中有一项配置，是在4.4以上版本时设置网页内图片可以自动加载，而4.4以下版本则不可自动加载，原因是4.4WebView内核的改变，使得WebView的性能更优，所以在4.4以下版本不让图片自动加载，而是先让WebView加载网页的其它静态资源：js、css、文本等等，待网页把这些静态资源加载完成后，在<code>onPageFinished</code>方法中再把图片自动加载打开让网页加载图片：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">    <span class="keyword">if</span> (!mWebView.getSettings().getLoadsImagesAutomatically()) &#123;</span><br><span class="line">        mWebView.getSettings().setLoadsImagesAutomatically(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-WebView的独立进程"><a href="#2-2-WebView的独立进程" class="headerlink" title="2.2 WebView的独立进程"></a><strong>2.2 WebView的独立进程</strong></h3><p>通常来说，WebView的使用会带来诸多问题，内存泄露就是最常见的问题，为了避免WebView内存泄露，目前最流行的有两种做法：</p>
<blockquote>
<p>1、独立进程，简单暴力，不过可能涉及到进程间通信<br>2、动态添加WebView，对传入WebView中使用的Context使用弱引用，动态添加WebView意思在布局创建个ViewGroup用来放置WebView，Activity创建时add进来，在Activity停止时remove掉</p>
</blockquote>
<p>个人推荐独立进程，好处主要有两点，一是在WebViewActivity使用完毕后直接干掉该进程，防止了内存泄露，二是为我们的app主进程减少了额外的内存占用量</p>
<p>使用独立进程还需注意一点，这个进程中在有多个WebViewActivity，不能在Activity销毁时就干掉进程，不然其它Activity也会蹦了，此时应该在该进程创建一个Activity的维护集合，集合为空时即可干掉进程</p>
<p>关于WebView的销毁，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">destroyWebView</span><span class="params">(WebView webView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (webView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    webView.stopLoading();</span><br><span class="line">    ViewParent viewParent = webView.getParent();</span><br><span class="line">    <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup)</span><br><span class="line">        ((ViewGroup) viewParent).removeView(webView);</span><br><span class="line">    webView.removeAllViews();</span><br><span class="line">    webView.destroy();</span><br><span class="line">    webView = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-WebView的兼容性"><a href="#2-3-WebView的兼容性" class="headerlink" title="2.3 WebView的兼容性"></a><strong>2.3 WebView的兼容性</strong></h3><h4 id="2-3-1-不同版本硬件加速的问题"><a href="#2-3-1-不同版本硬件加速的问题" class="headerlink" title="2.3.1 不同版本硬件加速的问题"></a><strong>2.3.1 不同版本硬件加速的问题</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 &amp;&amp; shouldOpenHardware()) &#123;</span><br><span class="line">    mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOpenHardware</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(Build.BRAND))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-不同设备点击WebView输入框键盘的不弹起"><a href="#2-3-2-不同设备点击WebView输入框键盘的不弹起" class="headerlink" title="2.3.2 不同设备点击WebView输入框键盘的不弹起"></a><strong>2.3.2 不同设备点击WebView输入框键盘的不弹起</strong></h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWebView != <span class="keyword">null</span>)</span><br><span class="line">                mWebView.requestFocus();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"><a href="#2-3-3-三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况" class="headerlink" title="2.3.3 三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况"></a><strong>2.3.3 三星手机硬件加速关闭后导致H5弹出的对话框出现不消失情况</strong></h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">brand </span>= <span class="keyword">android.os.Build.BRAND;</span><br><span class="line"></span><span class="label">if</span> (<span class="string">"samsung"</span>.equalsIgnoreCase(<span class="keyword">brand) </span>&amp;&amp; <span class="keyword">Build.VERSION.SDK_INT </span>&gt;= <span class="keyword">Build.VERSION_CODES.LOLLIPOP) </span>&#123;</span><br><span class="line">    getWindow().setFlags(</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">            WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-不同版本shouldOverrideUrlLoading的回调时机"><a href="#2-3-4-不同版本shouldOverrideUrlLoading的回调时机" class="headerlink" title="2.3.4 不同版本shouldOverrideUrlLoading的回调时机"></a><strong>2.3.4 不同版本shouldOverrideUrlLoading的回调时机</strong></h4><p>对于<code>shouldOverrideUrlLoading</code>的加载时机，有些同学经常与<code>onProgressChanged</code>这个方法的加载时机混淆，这两个方法有两点不同：</p>
<blockquote>
<p>1、<code>shouldOverrideUrlLoading</code>只会走Get方式的请求，Post方式的请求将不会回调这个方法，而<code>onProgressChanged</code>对Get和Post都会走<br>2、<code>shouldOverrideUrlLoading</code>都知道在WebView内部点击链接（Get）会触发，它在Get请求打开界面时也会触发，<code>shouldOverrideUrlLoading</code>还有一点特殊，就是在按返回键返回到上一个页面时时不会触发的，而<code>onProgressChanged</code>在只要界面更新了都会触发</p>
</blockquote>
<p>对于<code>shouldOverrideUrlLoading</code>的返回值，返回true为剥夺WebView对该此请求的控制权，交给应用自己处理，所以WebView也不会加载该url了，返回false为WebView自己处理</p>
<p>对于<code>shouldOverrideUrlLoading</code>的调用时机，也会有不同，在3.0以上是会正常调用的，而在3.0以下，并不是每次都会调用，可以在<code>onPageStarted</code>方法中做处理，也没必要了，现在应该都适配4.0以上了</p>
<h4 id="2-3-5-页面重定向导致WebView-goBack-无效的处理"><a href="#2-3-5-页面重定向导致WebView-goBack-无效的处理" class="headerlink" title="2.3.5 页面重定向导致WebView:goBack()无效的处理"></a><strong>2.3.5 页面重定向导致WebView:goBack()无效的处理</strong></h4><p>像一些界面有重定向，比如：淘宝等，需要按多次（&gt;1）才能正常返回，一般都是二次，所以可以把那些具有重定向的界面存入一个集合中，在拦截返回事件中这样处理：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> onBackPressed() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWebView == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    WebBackForwardList backForwardList = mWebView.copyBackForwardList();</span><br><span class="line">    <span class="keyword">if</span> (backForwardList != <span class="keyword">null</span> &amp;&amp; backForwardList.getSize() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> currentIndex = backForwardList.getCurrentIndex();</span><br><span class="line">        WebHistoryItem historyItem = backForwardList.getItemAtIndex(currentIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (historyItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">String</span> backPageUrl = historyItem.getUrl();</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(backPageUrl))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">size</span> = REDIRECT_URL.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (backPageUrl.contains(REDIRECT_URL.<span class="built_in">get</span>(i)))</span><br><span class="line">                    mWebView.goBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mWebView.canGoBack()) &#123;</span><br><span class="line">        mWebView.goBack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里处理是在按返回键时，如果上一个界面是重定向界面，则直接调用goBack，或者也可以finish当前Activity</p>
<h4 id="2-3-6-WebView无法加载不信任网页SSL错误的处理"><a href="#2-3-6-WebView无法加载不信任网页SSL错误的处理" class="headerlink" title="2.3.6 WebView无法加载不信任网页SSL错误的处理"></a><strong>2.3.6 WebView无法加载不信任网页SSL错误的处理</strong></h4><p>有时我们的WebView会加载一些不信任的网页，这时候默认的处理是WebView停止加载了，而那些不信任的网页都不是由CA机构信任的，这时候你可以选择继续加载或者让手机内的浏览器来加载：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, <span class="keyword">final</span> SslErrorHandler <span class="keyword">handler</span>, SslError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续加载</span></span><br><span class="line">    <span class="keyword">handler</span>.<span class="keyword">proceed</span>();</span><br><span class="line">    <span class="comment">//或者其它处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-7-自定义WebView加载出错界面"><a href="#2-3-7-自定义WebView加载出错界面" class="headerlink" title="2.3.7 自定义WebView加载出错界面"></a><strong>2.3.7 自定义WebView加载出错界面</strong></h4><p>出错的界面的显示，可以在这个方法中控制：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以重新加载一段Html专门用来显示错误界面，或者用布局显示一个出错的View，这时候需要把出错的WebView内容清除，可以使用：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, WebResourceRequest request, WebResourceError <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onReceivedError(view, request, <span class="keyword">error</span>);</span><br><span class="line">    view.loadDataWithBaseURL(<span class="keyword">null</span>,<span class="string">""</span>,<span class="string">"text/html"</span>,<span class="string">"UTF-8"</span>,<span class="keyword">null</span>);</span><br><span class="line">    errorView.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-8-获取位置权限的处理"><a href="#2-3-8-获取位置权限的处理" class="headerlink" title="2.3.8 获取位置权限的处理"></a><strong>2.3.8 获取位置权限的处理</strong></h4><p>如果在WebView中有获取地理位置的请求，那么可以直接在代码中默认处理了，没必要弹出一个框框让用户每次都确认：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGeolocationPermissionsShowPrompt</span><span class="params">(String origin, GeolocationPermissions.Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onGeolocationPermissionsShowPrompt(origin, callback);</span><br><span class="line">    callback.invoke(origin, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-打造一个通用的WebViewActivity界面"><a href="#2-4-打造一个通用的WebViewActivity界面" class="headerlink" title="2.4 打造一个通用的WebViewActivity界面"></a><strong>2.4 打造一个通用的WebViewActivity界面</strong></h3><p>一个通用的WebViewActivity当然是样式和WebView内部处理的策略都统一样，这里只对样式进行说明，因为WebView内部的处理各个公司都不一样，但应该都需要包含这么几点吧：</p>
<blockquote>
<p>1、白名单检测<br>2、Url的跳转<br>3、出错的处理<br>4、…</p>
</blockquote>
<p>一个WebViewActivity界面，最主要的就是Toolbar标题栏的设计了，因为不同的app的WebViewActivity界面Toolbar上有不同的icon和操作，比如：分享按钮、刷新按钮、更多按钮，都不一样，既然需要通用，即可让调用者传入某个参数来动态改变这些东西吧，比如传一个ToolbarStyle来标识此WebViewActivity的风格是什么样的，背景色、字体颜色、图标等，包括点击时的动画效果，作为通用的界面，必须是让调用者简单操作，不可能调用时传入一个图标id还是一个Drawable，所以，主要需要用到tint，来对字体、图标的颜色动态改变，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ColorStateList <span class="title">createColorStateList</span><span class="params">(<span class="keyword">int</span> normal, <span class="keyword">int</span> pressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;normal, pressed&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-android.R.attr.state_pressed&#125;;</span><br><span class="line">    states[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_pressed&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ColorStateList(states, colors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Drawable <span class="title">tintDrawable</span><span class="params">(Drawable drawable, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    final Drawable tintDrawable = DrawableCompat.wrap(drawable.mutate());</span><br><span class="line">    ColorStateList colorStateList = ColorStateList.valueOf(color);</span><br><span class="line">    DrawableCompat.setTintMode(tintDrawable, PorterDuff.Mode.SRC_IN);</span><br><span class="line">    DrawableCompat.setTintList(tintDrawable, colorStateList);</span><br><span class="line">    <span class="keyword">return</span> tintDrawable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-H5与Native界面互相唤起"><a href="#3-H5与Native界面互相唤起" class="headerlink" title="3. H5与Native界面互相唤起"></a><strong>3. H5与Native界面互相唤起</strong></h2><p>对于H5界面，有些操作往往是需要唤起Native界面的，比如：H5中的登录按钮，点击后往往唤起Native的登录界面来进行登录，而不是直接在H5登录，这样一个app就只需要一套登录了，而我们所做的便是拦截登录按钮的url：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">    parserURL(url); <span class="comment">//解析url,如果符合跳转native界面的url规则，则跳转native界面</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">shouldOverrideUrlLoading</span><span class="params">(view, url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规则我们可以在Native的Activity的<code>intent-filter</code>中的<code>data</code>来定义，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".LoginActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">data</span></span><br><span class="line">            <span class="attribute">android:host</span>=<span class="value">"native"</span></span><br><span class="line">            <span class="attribute">android:path</span>=<span class="value">"/login"</span></span><br><span class="line">            <span class="attribute">android:scheme</span>=<span class="value">"activity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>解析url过程是判断scheme、host、path的是否有完全与之匹配的，有则唤起</p>
<p>而Native唤H5，其实也是一个url的解析过程，只不过需要配置WebViewActivity的<code>intent-filter</code>的<code>data</code>，WebViewActivity的scheme配置为http和https</p>
<h3 id="startActivity-VS-UrlRouter"><a href="#startActivity-VS-UrlRouter" class="headerlink" title="startActivity VS UrlRouter"></a><strong>startActivity VS UrlRouter</strong></h3><p>上面说到了H5与Native互相调起，其实这个可以在app内做成一套界面跳转的方式，摒弃startActivity，为什么原生的跳转方式不佳？</p>
<blockquote>
<p>1、因为原生的跳转需要确定该Activity是已经存在的，否则编译将报错，这样带来的问题是不利于协同开发，如：A、B同学分别正在开发项目的两个不同的模块，此时B刚好需要跳A同学的某一个界面，如商品列表页跳商品详情页，这时候B就必须写个TODO，待B完成该模块后再写了。而通过url跳转，只需要传入一串url即可<br>2、原生的跳转Activity与目标Activity是耦合的，跳转Activity完全依赖于目标Activity<br>3、原生的跳转方式不利于管理所传递来的参数，获取参数时需要在跳转Activity的地方确定传递了几个参数、什么类型的参数，这样以来跳转的方式多了，就比较混乱了。当然一个原生跳转良好的设计是在目的Activity实现一个静态的start方法，其它界面要跳直接调用即可<br>4、最后一个就是在有参数传递的情况下，每次跳转都要写好多代码啊</p>
</blockquote>
<p>而UrlRouter框架的实现原理，一种实现是可以维护一套Activity与url的映射表，这种方式还是没有摆脱不利于协同开发这个毛病，另外一种是通过一串指定规则的url与manifest中配置的data匹配，具体跳转则是通过<code>intent.setData()</code>来设置跳转的url，这种方式比较好，不过需要处理下匹配到多个Activity时优先选择的问题</p>
<p><strong>JsBridge地址</strong>：<a href="https://github.com/Sunzxyong/RainbowBridge" target="_blank" rel="external">RainbowBridge</a></p>
<hr>
<p><strong>—转载请注明出处</strong></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/24/UrlRouter路由框架的设计/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          UrlRouter路由框架的设计
        
      </div>
    </a>
  
  
    <a href="/2016/02/23/Android性能优化之Bitmap的内存优化/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Android性能优化之Bitmap的内存优化</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Native与H5交互的那些事" data-title="Native与H5交互的那些事" data-url="http://zhengxiaoyong.me/2016/04/20/Native与H5交互的那些事/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  <div class="outer">
	
    <div id="footer-info">
	<div class="footer-center”>
		<span id="busuanzi_container_site_pv" style="font-size:14px”>
    		<p style=“color:#3C3C3C”>您是本站的第</p><span id="busuanzi_value_site_pv" style="font-size:16px"></span>位访客小伙伴</span>
		<span style="font-size:12px">
    			&nbsp;| &copy; 2016 郑晓勇
    	</span>
	</div>
    </div>
  </div>

</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>